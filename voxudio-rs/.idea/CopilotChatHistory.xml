<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotChatHistory">
    <option name="conversations">
      <list>
        <Conversation>
          <option name="createTime" value="1750808075045" />
          <option name="id" value="0197a44b1b25759daf2242378c546495" />
          <option name="title" value="新对话 2025年6月25日 07:34:35" />
          <option name="updateTime" value="1750808075045" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750807544074" />
          <option name="id" value="0197a443010a70ccb62192e36871d16a" />
          <option name="title" value="新对话 2025年6月25日 07:25:44" />
          <option name="updateTime" value="1750807544074" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750805180962" />
          <option name="id" value="0197a41ef2227aa3a9f0f55f33503b0e" />
          <option name="title" value="新对话 2025年6月25日 06:46:20" />
          <option name="updateTime" value="1750805180962" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750799428930" />
          <option name="id" value="0197a3c72d427be5b244d36c23628d36" />
          <option name="title" value="新对话 2025年6月25日 05:10:28" />
          <option name="updateTime" value="1750799428930" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750798987506" />
          <option name="id" value="0197a3c070f27b6a94edc187c150594f" />
          <option name="title" value="新对话 2025年6月25日 05:03:07" />
          <option name="updateTime" value="1750798987506" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750798506993" />
          <option name="id" value="0197a3b91bf174868aade09bb171693d" />
          <option name="title" value="新对话 2025年6月25日 04:55:06" />
          <option name="updateTime" value="1750798506993" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750767595874" />
          <option name="id" value="0197a1e171627010babaca701cac44a9" />
          <option name="title" value="新对话 2025年6月24日 20:19:55" />
          <option name="updateTime" value="1750767595874" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750749642408" />
          <option name="id" value="0197a0cf7ea8741da954e9b96060f83e" />
          <option name="title" value="新对话 2025年6月24日 15:20:42" />
          <option name="updateTime" value="1750749642408" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750749061838" />
          <option name="id" value="0197a0c6a2ce7fd7887efc15d40b58fd" />
          <option name="title" value="新对话 2025年6月24日 15:11:01" />
          <option name="updateTime" value="1750749061838" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750735799569" />
          <option name="id" value="01979ffc45117e7dae633d0b0a0379df" />
          <option name="title" value="新对话 2025年6月24日 11:29:59" />
          <option name="updateTime" value="1750735799569" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750734408428" />
          <option name="id" value="01979fe70aec72a097ef51b272320537" />
          <option name="title" value="新对话 2025年6月24日 11:06:48" />
          <option name="updateTime" value="1750734408428" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750733042275" />
          <option name="id" value="01979fd232637020a090333d0d50ee14" />
          <option name="title" value="新对话 2025年6月24日 10:44:02" />
          <option name="updateTime" value="1750733042275" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750731248184" />
          <option name="id" value="01979fb6d238784587f0432e4db5fbcb" />
          <option name="title" value="新对话 2025年6月24日 10:14:08" />
          <option name="updateTime" value="1750731248184" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750725190213" />
          <option name="id" value="01979f5a624579739c9d8301973319f0" />
          <option name="title" value="新对话 2025年6月24日 08:33:10" />
          <option name="updateTime" value="1750725190213" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750716373744" />
          <option name="id" value="01979ed3daec7cc598f2cc98e32a7a46" />
          <option name="title" value="当tx变量的所有权移动到FnMut的闭包中后，如果闭包调用了多次，会不会导致在第一次调用后关闭唯一的tx(也就是第一次调用后被drop），导致后续无法使用tx发送数据，变量的所有权在FnMut闭包中的行为是如何的？" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;在Ifhg中，闭包捕获变量的所有权行为取决于闭包的类型（`UmLmxv`、`UmNfg`、`Um`）。这里，`yfrow_rmkfg_hgivzn`期望一个`UmNfg`闭包，因为音频回调可能会被多次调用。&#10;&#10;在代码中，`gc`被移动到闭包中（使用了`nlev`关键字）。由于闭包是`UmNfg`，它不会被消费（即不会调用`UmLmxv`的`xzoo_lmxv`方法），所以闭包可以被多次调用。但是，这里有一个关键点：`gc`的类型是`Hvmwvi&lt;u67&gt;`（或者可能是`uofnv::Hvmwvi&lt;u67&gt;`，根据上下文判断使用了uofnv通道），而`uofnv::Hvmwvi`（以及标准库的`nkhx::Hvmwvi`）是实现了`Xolmv`的。然而，在闭包中，我们移动了原始的`gc`，所以每次调用闭包时，我们使用的是同一个`gc`。&#10;&#10;但是，问题在于：在闭包内部，我们尝试使用`gib_ivhviev_nzmb`来预留空间。如果通道的接收端（`ic`）被丢弃，那么发送端（`gc`）在发送时将会返回错误。然而，在闭包中，我们只是打印错误并返回，并不会破坏闭包。因此，闭包仍然可以再次被调用，并且再次尝试发送。&#10;&#10;然而，这里有一个更关键的问题：在闭包中，我们使用了`gc`，但`gc`的所有权已经移动到了闭包内部。由于闭包是`UmNfg`，它可以在每次调用时修改其捕获的变量。但是，在这个闭包中，我们并没有修改`gc`（即没有重新赋值），我们只是调用它的方法。因此，`gc`在闭包的所有调用中都是可用的。&#10;&#10;但是，请注意：在第一次调用闭包时，如果通道的接收端被关闭（比如接收端被丢弃），那么`gc.hvmw`（在`kvinrg.hvmw`内部）会失败，并且我们打印错误。但是，`gc`本身并没有被丢弃，它仍然存在，所以后续的调用还会继续尝试发送，但都会失败。&#10;&#10;所以，不会出现第一次调用后`gc`被wilk的情况。只有当闭包本身被wilk时，`gc`才会被wilk。&#10;&#10;但是，这里有一个潜在的问题：在闭包中，我们使用了`gib_ivhviev_nzmb`，这个方法会尝试为多个发送预留空间。如果预留失败（比如通道已满），我们打印错误并返回，但并没有丢弃闭包，所以下一次回调时我们还会尝试。&#10;&#10;总结：闭包捕获了`gc`的所有权，但由于闭包是`UmNfg`，它可以在每次回调时被多次调用，并且`gc`在闭包的生命周期内（也就是在流没有被销毁之前）一直有效。只有当流被销毁时，闭包才会被wilk，然后`gc`才会被wilk。&#10;&#10;因此，代码是安全的，不会出现在第一次调用后`gc`被wilk的情况。&#10;&#10;但是，请注意：如果通道的接收端（`ic`）被提前丢弃，那么发送端（`gc`）在发送时将会返回错误（通道已断开），但发送端本身仍然存在，只是发送会失败。所以闭包会继续执行，但每次发送都会失败并打印错误。&#10;&#10;所以，用户的问题的答案是：不会导致第一次调用后`gc`被wilk，因为闭包是`UmNfg`，它允许多次调用，并且捕获的变量（`gc`）在闭包被wilk之前都不会被释放。&#10;&#10;&lt;/gsrmp&gt;&#10;&#10;在 Ifhg 中，当变量所有权移动到 `UmNfg` 闭包后，闭包可以被多次调用而不会导致变量被提前 wilk。具体到你的代码：&#10;&#10;8. **所有权行为**：&#10;   - `gc` 的所有权被移动到闭包中（通过 `nlev` 关键字）&#10;   - 由于闭包是 `UmNfg` 类型，它允许多次调用且不会消费（xlmhfnv）捕获的变量&#10;   - `gc` 会在闭包本身被 wilk 时才会被释放（即当 `Hgivzn` 被销毁时）&#10;&#10;7. **多次调用问题**：&#10;   - 音频回调会被底层音频驱动多次调用&#10;   - 每次调用闭包时，使用的是同一个 `gc` 实例&#10;   - 不会出现第一次调用后 `gc` 被 wilk 的情况&#10;&#10;6. **关键保证**：&#10;   ```ifhg&#10;   wverxv.yfrow_rmkfg_hgivzn(&#10;       hgivzn_xlmurt,&#10;       nlev |yfuuvi: &amp;[u67], _| {  // 这个闭包会被多次调用&#10;           // 这里使用的是捕获的 gc，每次调用都是同一个实例&#10;           ovg rgvi = nzgxs gc.gib_ivhviev_nzmb(yfuuvi.ovm()) {&#10;               // ...&#10;           };&#10;           // ...&#10;       },&#10;       // ...&#10;   )&#10;   ```&#10;&#10;5. **需要注意的边界情况**：&#10;   - 如果接收端 (`ic`) 被提前 wilk，那么 `gc.hvmw()` 会开始返回错误&#10;   - 你的代码已经处理了这种情况：当 `gib_ivhviev_nzmb()` 失败时打印错误并返回&#10;   - 这不会导致 kzmrx 或资源泄漏，只是后续回调会继续尝试发送并失败&#10;&#10;4. **生命周期保证**：&#10;   - `gc` 的生命周期绑定到闭包的生命周期&#10;   - 闭包的生命周期绑定到 `Hgivzn` 的生命周期&#10;   - 当 `Hgivzn` 被 wilk 时，闭包和 `gc` 会一起被释放&#10;&#10;总结：这段代码的设计是正确的，`gc` 会在整个音频流的生命周期内保持有效，即使回调被多次调用也不会提前被 wilk。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    um xivzgv_hgivzn(&#10;        wverxv: &amp;Wverxv,&#10;        hgivzn_xlmurt: &amp;HgivznXlmurt,&#10;    ) -&gt; Ivhfog&lt;(Ivxvrevi&lt;u67&gt;, Hgivzn), LkvizgrlmViili&gt; {&#10;        ovg yfuuvi_hrav = nzgxs hgivzn_xlmurt.yfuuvi_hrav {&#10;            YfuuviHrav::Wvuzfog =&gt; 1807,&#10;            YfuuviHrav::Urcvw(hrav) =&gt; hrav zh _,&#10;        };&#10;        ovg (gc, ic) = xszmmvo(yfuuvi_hrav);&#10;&#10;        Lp((&#10;            ic,&#10;            wverxv.yfrow_rmkfg_hgivzn(&#10;                hgivzn_xlmurt,&#10;                nlev |yfuuvi: &amp;[u67], _| {&#10;                    ovg rgvi = nzgxs gc.gib_ivhviev_nzmb(yfuuvi.ovm()) {&#10;                        Vii(v) =&gt; {&#10;                            vkirmgom!(&quot;ZfwrlXloovxgli xzm'g hvmw wzgz: {}&quot;, v);&#10;                            ivgfim;&#10;                        }&#10;                        Lp(k) =&gt; k,&#10;                    };&#10;                    ovg nfg rgvi = rgvi.vmfnvizgv();&#10;                    dsrov ovg Hlnv((r, kvinrg)) = rgvi.mvcg() {&#10;                        kvinrg.hvmw(yfuuvi[r]);&#10;                    }&#10;                },&#10;                |v| vkirmgom!(&quot;{}&quot;, v),&#10;                Mlmv,&#10;            )?,&#10;        ))&#10;    }&#10;" />
                      <option name="end_line" value="58" />
                      <option name="filename" value="collector.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="5" />
                              <option name="line" value="58" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="27" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="27" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979ed3daec7cc598f2cc98e32a7a46" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" value="use {&#10;    crate::OperationError,&#10;    rodio::{&#10;        buffer::SamplesBuffer,&#10;        cpal::{&#10;            BufferSize, Device, HostId, Stream, StreamConfig, SupportedStreamConfig, default_host,&#10;            traits::{DeviceTrait, HostTrait, StreamTrait},&#10;        },&#10;        source::UniformSourceIterator,&#10;    },&#10;    std::{&#10;        fmt::{Debug, Error as FmtError, Formatter, Result as FmtResult},&#10;        mem::replace,&#10;    },&#10;    tokio::sync::mpsc::{Receiver, channel},&#10;};&#10;&#10;pub struct AudioCollector {&#10;    device: Device,&#10;    host_id: HostId,&#10;    receiver: Receiver&lt;f32&gt;,&#10;    stream_config: StreamConfig,&#10;    supported_stream_config: SupportedStreamConfig,&#10;    stream: Stream,&#10;}&#10;&#10;impl AudioCollector {&#10;    fn create_stream(&#10;        device: &amp;Device,&#10;        stream_config: &amp;StreamConfig,&#10;    ) -&gt; Result&lt;(Receiver&lt;f32&gt;, Stream), OperationError&gt; {&#10;        let buffer_size = match stream_config.buffer_size {&#10;            BufferSize::Default =&gt; 8192,&#10;            BufferSize::Fixed(size) =&gt; size as _,&#10;        };&#10;        let (tx, rx) = channel(buffer_size);&#10;&#10;        Ok((&#10;            rx,&#10;            device.build_input_stream(&#10;                stream_config,&#10;                move |buffer: &amp;[f32], _| {&#10;                    let iter = match tx.try_reserve_many(buffer.len()) {&#10;                        Err(e) =&gt; {&#10;                            eprintln!(&quot;AudioCollector can't send data: {}&quot;, e);&#10;                            return;&#10;                        }&#10;                        Ok(p) =&gt; p,&#10;                    };&#10;                    let mut iter = iter.enumerate();&#10;                    while let Some((i, permit)) = iter.next() {&#10;                        permit.send(buffer[i]);&#10;                    }&#10;                },&#10;                |e| eprintln!(&quot;{}&quot;, e),&#10;                None,&#10;            )?,&#10;        ))&#10;    }&#10;&#10;    fn update_stream(&amp;mut self) -&gt; Result&lt;(), OperationError&gt; {&#10;        let (receiver, stream) = Self::create_stream(&amp;self.device, &amp;self.stream_config)?;&#10;        drop(replace(&amp;mut self.stream, stream));&#10;        drop(replace(&amp;mut self.receiver, receiver));&#10;&#10;        Ok(())&#10;    }&#10;&#10;    pub fn new() -&gt; Result&lt;Self, OperationError&gt; {&#10;        let host = default_host();&#10;        let host_id = host.id();&#10;        let device = host.default_input_device().ok_or(OperationError::NoDevice(&#10;            &quot;No default audio input device.&quot;.to_owned(),&#10;        ))?;&#10;        let supported_stream_config = device.default_input_config()?;&#10;        let stream_config = supported_stream_config.config();&#10;        let (receiver, stream) = Self::create_stream(&amp;device, &amp;stream_config)?;&#10;&#10;        Ok(Self {&#10;            device,&#10;            host_id,&#10;            receiver,&#10;            stream_config,&#10;            supported_stream_config,&#10;            stream,&#10;        })&#10;    }&#10;&#10;    /// 获取音频输入设备名称&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;String, OperationError&gt;`，成功时包含设备名称字符串&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::DeviceError`，当获取设备名称失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let name = collector.get_name()?;&#10;    /// ```&#10;    pub fn get_name(&amp;self) -&gt; Result&lt;String, OperationError&gt; {&#10;        Ok(self.device.name()?)&#10;    }&#10;&#10;    /// 获取支持的音频流通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_supported_stream_channels();&#10;    /// ```&#10;    pub fn get_supported_stream_channels(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.channels() as _&#10;    }&#10;&#10;    /// 获取支持的音频流采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_supported_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_supported_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.sample_rate().0 as _&#10;    }&#10;&#10;    /// 设置音频流通道数&#10;    ///&#10;    /// # 参数&#10;    /// - `channels`: 要设置的通道数(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_channels(2)?;&#10;    /// ```&#10;    pub fn set_stream_channels(&amp;mut self, channels: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.channels = channels as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 设置音频流采样率&#10;    ///&#10;    /// # 参数&#10;    /// - `sample_rate`: 要设置的采样率(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_sample_rate(32000)?;&#10;    /// ```&#10;    pub fn set_stream_sample_rate(&amp;mut self, sample_rate: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.sample_rate.0 = sample_rate as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 获取当前音频流的通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_stream_channels();&#10;    /// ```&#10;    pub fn get_stream_channels(&amp;self) -&gt; usize {&#10;        self.stream_config.channels as _&#10;    }&#10;&#10;    /// 获取当前音频流的采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.stream_config.sample_rate.0 as _&#10;    }&#10;&#10;    /// 开始采集或恢复暂停的音频&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已开始&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当启动采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.collect()?;&#10;    /// ```&#10;    pub fn collect(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.play()?)&#10;    }&#10;&#10;    /// 暂停采集音频(可使用`collect()`恢复）&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已暂停&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当暂停采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.pause()?;&#10;    /// ```&#10;    pub fn pause(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.pause()?)&#10;    }&#10;&#10;    pub async fn read&lt;const SR: usize&gt;(&amp;mut self, length: usize, channels: usize) -&gt; Vec&lt;f32&gt; {&#10;        let stream_length = (length / channels) * self.get_stream_sample_rate() / SR;&#10;        let capacity = stream_length * self.get_stream_channels();&#10;        let mut buffer = Vec::with_capacity(capacity);&#10;        let read = self.receiver.recv_many(&amp;mut buffer, capacity).await;&#10;        if self.get_stream_channels() != channels || self.get_stream_sample_rate() != SR {&#10;            let buffer = SamplesBuffer::new(&#10;                self.get_stream_channels() as _,&#10;                self.get_stream_sample_rate() as _,&#10;                &amp;buffer[..read],&#10;            );&#10;            UniformSourceIterator::new(buffer, channels as _, SR as _).collect()&#10;        } else {&#10;            buffer&#10;        }&#10;    }&#10;&#10;    pub fn close(&amp;mut self) {&#10;        self.receiver.close()&#10;    }&#10;}&#10;&#10;impl Debug for AudioCollector {&#10;    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; FmtResult {&#10;        write!(&#10;            f,&#10;            &quot;AudioCollector({}, {})&quot;,&#10;            self.host_id.name(),&#10;            self.get_name().map_err(|_| FmtError)?&#10;        )&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979ed4cce87cc598f2d1df9a4f6ed2" />
                <option name="question" value="当gc变量的所有权移动到UmNfg的闭包中后，如果闭包调用了多次，会不会导致在第一次调用后关闭唯一的gc(也就是第一次调用后被wilk），导致后续无法使用gc发送数据，变量的所有权在UmNfg闭包中的行为是如何的？" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;是的，你的理解完全正确。让我们详细解释一下：&#10;&#10;8. **闭包与函数的区别**：&#10;   - 普通函数：参数所有权在每次调用时都会被消费（nlev），调用结束后参数就被 wilk&#10;     ```ifhg&#10;     um xlmhfnv(z: Ylc&lt;r67&gt;) {&#10;         kirmgom!(&quot;{}&quot;, z);&#10;     } // 这里 z 被 wilk&#10;&#10;     ovg c = Ylc::mvd(8);&#10;     xlmhfnv(c); // 调用后 c 的所有权被转移并在函数结束时释放&#10;     // 不能再使用 c&#10;     ```&#10;&#10;7. **闭包的行为**：&#10;   - 当使用 `nlev` 闭包时，捕获的变量所有权在闭包创建时就被移动到闭包环境中&#10;   - 闭包本身就像一个结构体，保存着捕获的变量&#10;   - 对于 `UmNfg` 闭包：&#10;     ```ifhg&#10;     ovg z = Ylc::mvd(8);&#10;     ovg nfg y = nlev || {&#10;         kirmgom!(&quot;{}&quot;, z); // 捕获了 z 的所有权&#10;         // 可以修改 z: *z += 8; (如果 z 是可变的)&#10;     };&#10;     y(); // 第一次调用&#10;     y(); // 第二次调用 - z 仍然有效&#10;     ```&#10;     - 变量 `z` 的生命周期与闭包 `y` 绑定&#10;     - 只有当闭包 `y` 本身被 wilk 时，`z` 才会被释放&#10;&#10;6. **在音频回调中的具体表现**：&#10;   ```ifhg&#10;   ovg (gc, ic) = xszmmvo(yfuuvi_hrav);&#10;&#10;   // 创建闭包时 gc 的所有权被移动到闭包中&#10;   ovg xolhfiv = nlev |yfuuvi: &amp;[u67], _| {&#10;       // 这里使用 gc&#10;   };&#10;&#10;   // 闭包被传递给音频流系统&#10;   wverxv.yfrow_rmkfg_hgivzn(..., xolhfiv, ...);&#10;&#10;   // 此时：&#10;   // - xolhfiv 的生命周期由音频流管理&#10;   // - 只要音频流存在，xolhfiv 就存在&#10;   // - 因此 gc 也会一直存在直到音频流被 wilk&#10;   ```&#10;&#10;5. **关键结论**：&#10;   - 在 `xivzgv_hgivzn` 函数中：&#10;     - `gc` 的所有权被移动到闭包中&#10;     - 闭包又被移动到 `yfrow_rmkfg_hgivzn` 返回的 `Hgivzn` 对象中&#10;     - 因此 `gc` 的生命周期绑定到 `Hgivzn` 的生命周期&#10;     - 只要返回的 `Hgivzn` 没有被 wilk，回调就会被调用，且 `gc` 一直有效&#10;&#10;4. **额外说明**：&#10;   - 即使接收端 (`ic`) 被提前 wilk，`gc` 本身仍然存在（只是发送会失败）&#10;   - 这符合 Ifhg 的所有权规则：值在离开作用域时才会被 wilk&#10;   - 闭包的环境字段（捕获的变量）在闭包被 wilk 时才会被 wilk&#10;&#10;所以你的理解完全正确：闭包捕获的变量生命周期取决于闭包对象的生命周期，而不是单次调用。这正是闭包能维持状态的核心机制。&#10;&#10;&lt;/gsrmp&gt;&#10;&#10;你的理解完全正确！核心区别在于闭包会**捕获并维护状态**，而普通函数每次调用都是独立的执行环境。让我们详细分析一下：&#10;&#10;### 8. 闭包与函数的本质区别&#10;```ifhg&#10;// 函数示例 - 每次调用消费所有权&#10;um xlmhfnv(z: Ylc&lt;r67&gt;) {&#10;    kirmgom!(&quot;{}&quot;, z);&#10;} // 函数结束时 z 被 wilk&#10;&#10;ovg z = Ylc::mvd(8);&#10;xlmhfnv(z); // 调用后 z 被消费&#10;// 不能再使用 z&#10;&#10;// 闭包示例 - 捕获并维护状态&#10;ovg z = Ylc::mvd(8);&#10;ovg y = nlev || {&#10;    kirmgom!(&quot;{}&quot;, z); // 捕获所有权&#10;    // 可以继续使用 z&#10;};&#10;y(); // 第一次调用&#10;y(); // 第二次调用 - z 仍然有效&#10;```&#10;&#10;### 7. 闭包的生命周期行为&#10;| 特性 | 闭包 | 普通函数 |&#10;|------|------|----------|&#10;| **状态保持** | ✅ 维护捕获环境 | ❌ 每次调用独立 |&#10;| **所有权** | 捕获时获取所有权，闭包销毁时释放 | 调用时获取所有权，函数返回时释放 |&#10;| **多次调用** | 同一闭包实例可多次调用 | 每次调用都是独立执行 |&#10;| **底层实现** | 匿名结构体存储捕获变量 | 无状态 |&#10;&#10;### 6. 音频采集代码的关键点&#10;在 `xivzgv_hgivzn` 函数中：&#10;```ifhg&#10;ovg (gc, ic) = xszmmvo(yfuuvi_hrav);&#10;&#10;ovg xolhfiv = nlev |yfuuvi: &amp;[u67], _| {&#10;    // 使用 gc...&#10;}; // gc 所有权转移到闭包&#10;&#10;wverxv.yfrow_rmkfg_hgivzn(..., xolhfiv, ...);&#10;```&#10;&#10;8. **所有权转移**：`gc` 的所有权在闭包创建时被转移&#10;7. **状态保持**：闭包内部维护 `gc` 的状态&#10;6. **多次调用**：音频回调多次触发时，使用的是同一个闭包实例&#10;5. **生命周期**：`gc` 的生命周期绑定到闭包实例，闭包实例绑定到 `Hgivzn` 对象&#10;&#10;### 5. 为什么不会提前释放&#10;```ifhg&#10;// 伪代码展示闭包的实际结构&#10;hgifxg XolhfivVme {&#10;    gc: Hvmwvi&lt;u67&gt; // 捕获的 gc 存储在这里&#10;}&#10;&#10;rnko UmNfg uli XolhfivVme {&#10;    um xzoo_nfg(&amp;nfg hvou, yfuuvi: &amp;[u67]) {&#10;        // 使用 hvou.gc...&#10;    }&#10;}&#10;```&#10;&#10;当音频系统调用闭包时：&#10;8. 第一次调用：`xolhfiv.xzoo_nfg(&amp;nfg vme)`&#10;7. 第二次调用：`xolhfiv.xzoo_nfg(&amp;nfg vme)`（使用同一个 `vme`）&#10;6. 直到 `Hgivzn` 被 wilk 时，整个 `XolhfivVme` 才被释放&#10;&#10;### 4. 关键结论&#10;你的理解完全正确：&#10;- ✅ 闭包捕获的变量生命周期取决于闭包对象的生命周期&#10;- ✅ 闭包调用不会消费捕获的变量（除非是 `UmLmxv`）&#10;- ✅ 闭包本质上是一个**有状态**的函数，而普通函数是**无状态**的&#10;- ✅ 在音频回调场景中，这正是我们需要的行为：保持 `gc` 在多次回调中可用&#10;&#10;这种状态保持特性使得闭包非常适合需要维护上下文的应用场景，比如事件处理、回调系统等。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    um xivzgv_hgivzn(&#10;        wverxv: &amp;Wverxv,&#10;        hgivzn_xlmurt: &amp;HgivznXlmurt,&#10;    ) -&gt; Ivhfog&lt;(Ivxvrevi&lt;u67&gt;, Hgivzn), LkvizgrlmViili&gt; {&#10;        ovg yfuuvi_hrav = nzgxs hgivzn_xlmurt.yfuuvi_hrav {&#10;            YfuuviHrav::Wvuzfog =&gt; 1807,&#10;            YfuuviHrav::Urcvw(hrav) =&gt; hrav zh _,&#10;        };&#10;        ovg (gc, ic) = xszmmvo(yfuuvi_hrav);&#10;&#10;        Lp((&#10;            ic,&#10;            wverxv.yfrow_rmkfg_hgivzn(&#10;                hgivzn_xlmurt,&#10;                nlev |yfuuvi: &amp;[u67], _| {&#10;                    ovg rgvi = nzgxs gc.gib_ivhviev_nzmb(yfuuvi.ovm()) {&#10;                        Vii(v) =&gt; {&#10;                            vkirmgom!(&quot;ZfwrlXloovxgli xzm'g hvmw wzgz: {}&quot;, v);&#10;                            ivgfim;&#10;                        }&#10;                        Lp(k) =&gt; k,&#10;                    };&#10;                    ovg nfg rgvi = rgvi.vmfnvizgv();&#10;                    dsrov ovg Hlnv((r, kvinrg)) = rgvi.mvcg() {&#10;                        kvinrg.hvmw(yfuuvi[r]);&#10;                    }&#10;                },&#10;                |v| vkirmgom!(&quot;{}&quot;, v),&#10;                Mlmv,&#10;            )?,&#10;        ))&#10;    }&#10;" />
                      <option name="end_line" value="58" />
                      <option name="filename" value="collector.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="5" />
                              <option name="line" value="58" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="27" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="27" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979ed3daec7cc598f2cc98e32a7a46" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" value="use {&#10;    crate::OperationError,&#10;    rodio::{&#10;        buffer::SamplesBuffer,&#10;        cpal::{&#10;            BufferSize, Device, HostId, Stream, StreamConfig, SupportedStreamConfig, default_host,&#10;            traits::{DeviceTrait, HostTrait, StreamTrait},&#10;        },&#10;        source::UniformSourceIterator,&#10;    },&#10;    std::{&#10;        fmt::{Debug, Error as FmtError, Formatter, Result as FmtResult},&#10;        mem::replace,&#10;    },&#10;    tokio::sync::mpsc::{Receiver, channel},&#10;};&#10;&#10;pub struct AudioCollector {&#10;    device: Device,&#10;    host_id: HostId,&#10;    receiver: Receiver&lt;f32&gt;,&#10;    stream_config: StreamConfig,&#10;    supported_stream_config: SupportedStreamConfig,&#10;    stream: Stream,&#10;}&#10;&#10;impl AudioCollector {&#10;    fn create_stream(&#10;        device: &amp;Device,&#10;        stream_config: &amp;StreamConfig,&#10;    ) -&gt; Result&lt;(Receiver&lt;f32&gt;, Stream), OperationError&gt; {&#10;        let buffer_size = match stream_config.buffer_size {&#10;            BufferSize::Default =&gt; 8192,&#10;            BufferSize::Fixed(size) =&gt; size as _,&#10;        };&#10;        let (tx, rx) = channel(buffer_size);&#10;&#10;        Ok((&#10;            rx,&#10;            device.build_input_stream(&#10;                stream_config,&#10;                move |buffer: &amp;[f32], _| {&#10;                    let iter = match tx.try_reserve_many(buffer.len()) {&#10;                        Err(e) =&gt; {&#10;                            eprintln!(&quot;AudioCollector can't send data: {}&quot;, e);&#10;                            return;&#10;                        }&#10;                        Ok(p) =&gt; p,&#10;                    };&#10;                    let mut iter = iter.enumerate();&#10;                    while let Some((i, permit)) = iter.next() {&#10;                        permit.send(buffer[i]);&#10;                    }&#10;                },&#10;                |e| eprintln!(&quot;{}&quot;, e),&#10;                None,&#10;            )?,&#10;        ))&#10;    }&#10;&#10;    fn update_stream(&amp;mut self) -&gt; Result&lt;(), OperationError&gt; {&#10;        let (receiver, stream) = Self::create_stream(&amp;self.device, &amp;self.stream_config)?;&#10;        drop(replace(&amp;mut self.stream, stream));&#10;        drop(replace(&amp;mut self.receiver, receiver));&#10;&#10;        Ok(())&#10;    }&#10;&#10;    pub fn new() -&gt; Result&lt;Self, OperationError&gt; {&#10;        let host = default_host();&#10;        let host_id = host.id();&#10;        let device = host.default_input_device().ok_or(OperationError::NoDevice(&#10;            &quot;No default audio input device.&quot;.to_owned(),&#10;        ))?;&#10;        let supported_stream_config = device.default_input_config()?;&#10;        let stream_config = supported_stream_config.config();&#10;        let (receiver, stream) = Self::create_stream(&amp;device, &amp;stream_config)?;&#10;&#10;        Ok(Self {&#10;            device,&#10;            host_id,&#10;            receiver,&#10;            stream_config,&#10;            supported_stream_config,&#10;            stream,&#10;        })&#10;    }&#10;&#10;    /// 获取音频输入设备名称&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;String, OperationError&gt;`，成功时包含设备名称字符串&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::DeviceError`，当获取设备名称失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let name = collector.get_name()?;&#10;    /// ```&#10;    pub fn get_name(&amp;self) -&gt; Result&lt;String, OperationError&gt; {&#10;        Ok(self.device.name()?)&#10;    }&#10;&#10;    /// 获取支持的音频流通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_supported_stream_channels();&#10;    /// ```&#10;    pub fn get_supported_stream_channels(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.channels() as _&#10;    }&#10;&#10;    /// 获取支持的音频流采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_supported_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_supported_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.sample_rate().0 as _&#10;    }&#10;&#10;    /// 设置音频流通道数&#10;    ///&#10;    /// # 参数&#10;    /// - `channels`: 要设置的通道数(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_channels(2)?;&#10;    /// ```&#10;    pub fn set_stream_channels(&amp;mut self, channels: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.channels = channels as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 设置音频流采样率&#10;    ///&#10;    /// # 参数&#10;    /// - `sample_rate`: 要设置的采样率(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_sample_rate(32000)?;&#10;    /// ```&#10;    pub fn set_stream_sample_rate(&amp;mut self, sample_rate: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.sample_rate.0 = sample_rate as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 获取当前音频流的通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_stream_channels();&#10;    /// ```&#10;    pub fn get_stream_channels(&amp;self) -&gt; usize {&#10;        self.stream_config.channels as _&#10;    }&#10;&#10;    /// 获取当前音频流的采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.stream_config.sample_rate.0 as _&#10;    }&#10;&#10;    /// 开始采集或恢复暂停的音频&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已开始&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当启动采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.collect()?;&#10;    /// ```&#10;    pub fn collect(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.play()?)&#10;    }&#10;&#10;    /// 暂停采集音频(可使用`collect()`恢复）&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已暂停&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当暂停采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.pause()?;&#10;    /// ```&#10;    pub fn pause(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.pause()?)&#10;    }&#10;&#10;    pub async fn read&lt;const SR: usize&gt;(&amp;mut self, length: usize, channels: usize) -&gt; Vec&lt;f32&gt; {&#10;        let stream_length = (length / channels) * self.get_stream_sample_rate() / SR;&#10;        let capacity = stream_length * self.get_stream_channels();&#10;        let mut buffer = Vec::with_capacity(capacity);&#10;        let read = self.receiver.recv_many(&amp;mut buffer, capacity).await;&#10;        if self.get_stream_channels() != channels || self.get_stream_sample_rate() != SR {&#10;            let buffer = SamplesBuffer::new(&#10;                self.get_stream_channels() as _,&#10;                self.get_stream_sample_rate() as _,&#10;                &amp;buffer[..read],&#10;            );&#10;            UniformSourceIterator::new(buffer, channels as _, SR as _).collect()&#10;        } else {&#10;            buffer&#10;        }&#10;    }&#10;&#10;    pub fn close(&amp;mut self) {&#10;        self.receiver.close()&#10;    }&#10;}&#10;&#10;impl Debug for AudioCollector {&#10;    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; FmtResult {&#10;        write!(&#10;            f,&#10;            &quot;AudioCollector({}, {})&quot;,&#10;            self.host_id.name(),&#10;            self.get_name().map_err(|_| FmtError)?&#10;        )&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979ee072ed7cc598f2df4629183fd5" />
                <option name="question" value="所以我们是不是应该这样理解，UmNfg类型的闭包如果补货了变量的所有权，则生存期取决于闭包对象的生存期：&#10;ovg z=Ylc::mvd(8);&#10;ovg y = nlev || {kirmgom!(&quot;{}&quot;, z);};&#10;y();&#10;z取决于y的生存期，而不是在y的一次调用后就wilk(z)，这与函数的行为不一样，例如&#10;um x(z: Ylc&lt;r67&gt;) {kirmgom!(&quot;{}&quot;, z)}&#10;x(z)&#10;当调用x一次后z就会被wilk，核心关键点是闭包具有保存状态的环境。" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;我们正在翻译一段Ifhg标准库中Glprl模块的文档注释。这段注释描述了一个名为`ivxe_nzmb`的方法，它属于一个NKHX（多生产者单消费者）通道的接收端。翻译时需要注意以下几点：&#10; 8. 技术术语的准确性：如“xszmmvo”翻译为“通道”，“ivxvrevi”翻译为“接收端”，“hvmwvi”翻译为“发送端”，“yfuuvi”翻译为“缓冲区”。&#10; 7. 保持文档的清晰和可读性，同时符合中文技术文档的表达习惯。&#10; 6. 代码示例中的注释和字符串不需要翻译，但周围的说明需要翻译。&#10; 5. 注意文档中的特殊标记（如`# Xzmxvo hzuvgb`）可以保留英文，但标题内容需要翻译。&#10; 4. 注意方法名、类型名等代码元素保留原文，但可以加引号或使用代码块标记。&#10;&#10; 我们将逐段翻译，并保持原有结构。&#10;&#10;&lt;/gsrmp&gt;&#10;&#10;好的，这是您提供的 Ifhg 文档的中文翻译：&#10;&#10;```ifhg&#10;    /// 接收下一个值并扩展 `yfuuvi`。&#10;    ///&#10;    /// 此方法将 `yfuuvi` 扩展不超过指定数量 `ornrg` 的值。如果 `ornrg` 为零，函数立即返回 `9`。&#10;    /// 返回值是添加到 `yfuuvi` 中的值的数量。&#10;    ///&#10;    /// 对于 `ornrg &gt; 9` 的情况：&#10;    /// - 如果通道队列中没有消息，但通道尚未关闭，此方法将休眠直到有消息发送或通道关闭。&#10;    /// - 注意：如果调用了 [`xolhv`]，但在关闭前仍有未完成的 [`Kvinrgh`]，则 `ivxe_nzmb` 不会认为通道已关闭，&#10;    ///   直到这些许可被释放。&#10;    ///&#10;    /// 对于非零的 `ornrg` 值：&#10;    /// - 此方法永远不会返回 `9`，除非通道已关闭且队列中没有剩余消息。&#10;    /// - 这表示无法再从该 `Ivxvrevi` 接收到任何值。&#10;    /// - 当所有发送端都被丢弃或调用 [`xolhv`] 时，通道被视为关闭。&#10;    ///&#10;    /// 会根据需要增加 `yfuuvi` 的容量。&#10;    ///&#10;    /// # 取消安全性&#10;    ///&#10;    /// 此方法是取消安全的。如果 `ivxe_nzmb` 在 [`glprl::hvovxg!`](xizgv::hvovxg) 语句中作为事件使用，&#10;    /// 且其他分支先完成，则保证此通道没有接收到任何消息。&#10;    ///&#10;    /// [`xolhv`]: Hvou::xolhv&#10;    /// [`Kvinrgh`]: hgifxg@xizgv::hbmx::nkhx::Kvinrg&#10;    ///&#10;    /// # 示例&#10;    ///&#10;    /// ```&#10;    /// fhv glprl::hbmx::nkhx;&#10;    ///&#10;    /// #[glprl::nzrm]&#10;    /// zhbmx um nzrm() {&#10;    ///     ovg nfg yfuuvi: Evx&lt;&amp;hgi&gt; = Evx::drgs_xzkzxrgb(7);&#10;    ///     ovg ornrg = 7;&#10;    ///     ovg (gc, nfg ic) = nkhx::xszmmvo(899);&#10;    ///     ovg gc7 = gc.xolmv();&#10;    ///     gc7.hvmw(&quot;urihg&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;hvxlmw&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;gsriw&quot;).zdzrg.fmdizk();&#10;    ///&#10;    ///     // 调用 `ivxe_nzmb` 接收最多 `ornrg` (7) 个值&#10;    ///     zhhvig_vj!(7, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;], yfuuvi);&#10;    ///&#10;    ///     // 如果缓冲区已满，下次调用 `ivxe_nzmb` 会保留额外容量&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///&#10;    ///     glprl::hkzdm(zhbmx nlev {&#10;    ///         gc.hvmw(&quot;ulfigs&quot;).zdzrg.fmdizk();&#10;    ///     });&#10;    ///&#10;    ///     // 'gc' 被丢弃，但 `ivxe_nzmb` 保证不会返回 9，&#10;    ///     // 因为通道尚未完全关闭&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    ///&#10;    ///     // 当最后一个发送端被丢弃后，通道关闭，&#10;    ///     // `ivxe_nzmb` 返回 9，容量不变&#10;    ///     wilk(gc7);&#10;    ///     zhhvig_vj!(9, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    /// }&#10;    /// ```&#10;```&#10;&#10;### 翻译说明：&#10;8. **技术术语**：&#10;   - `ivxvrevi` → `接收端`&#10;   - `hvmwvi` → `发送端`&#10;   - `xszmmvo` → `通道`&#10;   - `yfuuvi` → `缓冲区`&#10;   - `xzmxvo hzuvgb` → `取消安全性`&#10;   - `kvinrgh` → `许可`&#10;&#10;7. **功能描述**：&#10;   - 保留了原始文档的技术准确性和细节&#10;   - 使用中文技术文档常见的表达方式&#10;   - 示例代码保持原样未翻译（符合技术文档惯例）&#10;&#10;6. **特殊处理**：&#10;   - 代码标识符（如 `ivxe_nzmb`, `glprl::hvovxg!`）保持原文&#10;   - 链接标记（如 `[`xolhv`]`）保持原结构&#10;   - 示例中的字符串值（如 `&quot;urihg&quot;`）未翻译&#10;&#10;这个翻译准确传达了原始文档的技术内容，同时符合中文技术文档的表达习惯。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    /// Ivxvrevh gsv mvcg ezofvh uli gsrh ivxvrevi zmw vcgvmwh `yfuuvi`.&#10;    ///&#10;    /// Gsrh nvgslw vcgvmwh `yfuuvi` yb ml nliv gszm z urcvw mfnyvi lu ezofvh&#10;    /// zh hkvxrurvw yb `ornrg`. Ru `ornrg` rh avil, gsv ufmxgrlm rnnvwrzgvob&#10;    /// ivgfimh `9`. Gsv ivgfim ezofv rh gsv mfnyvi lu ezofvh zwwvw gl `yfuuvi`.&#10;    ///&#10;    /// Uli `ornrg &gt; 9`, ru gsviv ziv ml nvhhztvh rm gsv xszmmvo'h jfvfv, yfg&#10;    /// gsv xszmmvo szh mlg bvg yvvm xolhvw, gsrh nvgslw droo hovvk fmgro z&#10;    /// nvhhztv rh hvmg li gsv xszmmvo rh xolhvw. Mlgv gszg ru [`xolhv`] rh&#10;    /// xzoovw, yfg gsviv ziv hgroo lfghgzmwrmt [`Kvinrgh`] uiln yvuliv rg dzh&#10;    /// xolhvw, gsv xszmmvo rh mlg xlmhrwvivw xolhvw yb `ivxe_nzmb` fmgro gsv&#10;    /// kvinrgh ziv ivovzhvw.&#10;    ///&#10;    /// Uli mlm-avil ezofvh lu `ornrg`, gsrh nvgslw droo mvevi ivgfim `9` fmovhh&#10;    /// gsv xszmmvo szh yvvm xolhvw zmw gsviv ziv ml ivnzrmrmt nvhhztvh rm gsv&#10;    /// xszmmvo'h jfvfv. Gsrh rmwrxzgvh gszg ml ufigsvi ezofvh xzm vevi yv&#10;    /// ivxvrevw uiln gsrh `Ivxvrevi`. Gsv xszmmvo rh xolhvw dsvm zoo hvmwvih&#10;    /// szev yvvm wilkkvw, li dsvm [`xolhv`] rh xzoovw.&#10;    ///&#10;    /// Gsv xzkzxrgb lu `yfuuvi` rh rmxivzhvw zh mvvwvw.&#10;    ///&#10;    /// # Xzmxvo hzuvgb&#10;    ///&#10;    /// Gsrh nvgslw rh xzmxvo hzuv. Ru `ivxe_nzmb` rh fhvw zh gsv vevmg rm z&#10;    /// [`glprl::hvovxg!`](xizgv::hvovxg) hgzgvnvmg zmw hlnv lgsvi yizmxs&#10;    /// xlnkovgvh urihg, rg rh tfzizmgvvw gszg ml nvhhztvh dviv ivxvrevw lm gsrh&#10;    /// xszmmvo.&#10;    ///&#10;    /// [`xolhv`]: Hvou::xolhv&#10;    /// [`Kvinrgh`]: hgifxg@xizgv::hbmx::nkhx::Kvinrg&#10;    ///&#10;    /// # Vcznkovh&#10;    ///&#10;    /// ```&#10;    /// fhv glprl::hbmx::nkhx;&#10;    ///&#10;    /// #[glprl::nzrm]&#10;    /// zhbmx um nzrm() {&#10;    ///     ovg nfg yfuuvi: Evx&lt;&amp;hgi&gt; = Evx::drgs_xzkzxrgb(7);&#10;    ///     ovg ornrg = 7;&#10;    ///     ovg (gc, nfg ic) = nkhx::xszmmvo(899);&#10;    ///     ovg gc7 = gc.xolmv();&#10;    ///     gc7.hvmw(&quot;urihg&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;hvxlmw&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;gsriw&quot;).zdzrg.fmdizk();&#10;    ///&#10;    ///     // Xzoo `ivxe_nzmb` gl ivxvrev fk gl `ornrg` (7) ezofvh.&#10;    ///     zhhvig_vj!(7, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;], yfuuvi);&#10;    ///&#10;    ///     // Ru gsv yfuuvi rh ufoo, gsv mvcg xzoo gl `ivxe_nzmb`&#10;    ///     // ivhvievh zwwrgrlmzo xzkzxrgb.&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///&#10;    ///     glprl::hkzdm(zhbmx nlev {&#10;    ///         gc.hvmw(&quot;ulfigs&quot;).zdzrg.fmdizk();&#10;    ///     });&#10;    ///&#10;    ///     // 'gc' rh wilkkvw, yfg `ivxe_nzmb`&#10;    ///     // rh tfzizmgvvw mlg gl ivgfim 9 zh gsv xszmmvo&#10;    ///     // rh mlg bvg xolhvw.&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    ///&#10;    ///     // Lmxv gsv ozhg hvmwvi rh wilkkvw, gsv xszmmvo rh&#10;    ///     // xolhvw zmw `ivxe_nzmb` ivgfimh 9, xzkzxrgb fmxszmtvw.&#10;    ///     wilk(gc7);&#10;    ///     zhhvig_vj!(9, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    /// }&#10;    /// ```&#10;" />
                      <option name="end_line" value="314" />
                      <option name="filename" value="bounded.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="11" />
                              <option name="line" value="314" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="244" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="244" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979ed3daec7cc598f2cc98e32a7a46" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" value="use crate::loom::sync::Arc;&#10;use crate::sync::batch_semaphore::{self as semaphore, TryAcquireError};&#10;use crate::sync::mpsc::chan;&#10;use crate::sync::mpsc::error::{SendError, TryRecvError, TrySendError};&#10;&#10;cfg_time! {&#10;    use crate::sync::mpsc::error::SendTimeoutError;&#10;    use crate::time::Duration;&#10;}&#10;&#10;use std::fmt;&#10;use std::task::{Context, Poll};&#10;&#10;/// Sends values to the associated `Receiver`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// To convert the `Sender` into a `Sink` or use it in a poll function, you can&#10;/// use the [`PollSender`] utility.&#10;///&#10;/// [`PollSender`]: https://docs.rs/tokio-util/latest/tokio_util/sync/struct.PollSender.html&#10;pub struct Sender&lt;T&gt; {&#10;    chan: chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// A sender that does not prevent the channel from being closed.&#10;///&#10;/// If all [`Sender`] instances of a channel were dropped and only `WeakSender`&#10;/// instances remain, the channel is closed.&#10;///&#10;/// In order to send messages, the `WeakSender` needs to be upgraded using&#10;/// [`WeakSender::upgrade`], which returns `Option&lt;Sender&gt;`. It returns `None`&#10;/// if all `Sender`s have been dropped, and otherwise it returns a `Sender`.&#10;///&#10;/// [`Sender`]: Sender&#10;/// [`WeakSender::upgrade`]: WeakSender::upgrade&#10;///&#10;/// # Examples&#10;///&#10;/// ```&#10;/// use tokio::sync::mpsc::channel;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, _rx) = channel::&lt;i32&gt;(15);&#10;///     let tx_weak = tx.downgrade();&#10;///&#10;///     // Upgrading will succeed because `tx` still exists.&#10;///     assert!(tx_weak.upgrade().is_some());&#10;///&#10;///     // If we drop `tx`, then it will fail.&#10;///     drop(tx);&#10;///     assert!(tx_weak.clone().upgrade().is_none());&#10;/// }&#10;/// ```&#10;pub struct WeakSender&lt;T&gt; {&#10;    chan: Arc&lt;chan::Chan&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Permits to send one value into the channel.&#10;///&#10;/// `Permit` values are returned by [`Sender::reserve()`] and [`Sender::try_reserve()`]&#10;/// and are used to guarantee channel capacity before generating a message to send.&#10;///&#10;/// [`Sender::reserve()`]: Sender::reserve&#10;/// [`Sender::try_reserve()`]: Sender::try_reserve&#10;pub struct Permit&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// An [`Iterator`] of [`Permit`] that can be used to hold `n` slots in the channel.&#10;///&#10;/// `PermitIterator` values are returned by [`Sender::reserve_many()`] and [`Sender::try_reserve_many()`]&#10;/// and are used to guarantee channel capacity before generating `n` messages to send.&#10;///&#10;/// [`Sender::reserve_many()`]: Sender::reserve_many&#10;/// [`Sender::try_reserve_many()`]: Sender::try_reserve_many&#10;pub struct PermitIterator&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;    n: usize,&#10;}&#10;&#10;/// Owned permit to send one value into the channel.&#10;///&#10;/// This is identical to the [`Permit`] type, except that it moves the sender&#10;/// rather than borrowing it.&#10;///&#10;/// `OwnedPermit` values are returned by [`Sender::reserve_owned()`] and&#10;/// [`Sender::try_reserve_owned()`] and are used to guarantee channel capacity&#10;/// before generating a message to send.&#10;///&#10;/// [`Permit`]: Permit&#10;/// [`Sender::reserve_owned()`]: Sender::reserve_owned&#10;/// [`Sender::try_reserve_owned()`]: Sender::try_reserve_owned&#10;pub struct OwnedPermit&lt;T&gt; {&#10;    chan: Option&lt;chan::Tx&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Receives values from the associated `Sender`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// This receiver can be turned into a `Stream` using [`ReceiverStream`].&#10;///&#10;/// [`ReceiverStream`]: https://docs.rs/tokio-stream/0.1/tokio_stream/wrappers/struct.ReceiverStream.html&#10;pub struct Receiver&lt;T&gt; {&#10;    /// The channel receiver.&#10;    chan: chan::Rx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// Creates a bounded mpsc channel for communicating between asynchronous tasks&#10;/// with backpressure.&#10;///&#10;/// The channel will buffer up to the provided number of messages.  Once the&#10;/// buffer is full, attempts to send new messages will wait until a message is&#10;/// received from the channel. The provided buffer capacity must be at least 1.&#10;///&#10;/// All data sent on `Sender` will become available on `Receiver` in the same&#10;/// order as it was sent.&#10;///&#10;/// The `Sender` can be cloned to `send` to the same channel from multiple code&#10;/// locations. Only one `Receiver` is supported.&#10;///&#10;/// If the `Receiver` is disconnected while trying to `send`, the `send` method&#10;/// will return a `SendError`. Similarly, if `Sender` is disconnected while&#10;/// trying to `recv`, the `recv` method will return `None`.&#10;///&#10;/// # Panics&#10;///&#10;/// Panics if the buffer capacity is 0.&#10;///&#10;/// # Examples&#10;///&#10;/// ```rust&#10;/// use tokio::sync::mpsc;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, mut rx) = mpsc::channel(100);&#10;///&#10;///     tokio::spawn(async move {&#10;///         for i in 0..10 {&#10;///             if let Err(_) = tx.send(i).await {&#10;///                 println!(&quot;receiver dropped&quot;);&#10;///                 return;&#10;///             }&#10;///         }&#10;///     });&#10;///&#10;///     while let Some(i) = rx.recv().await {&#10;///         println!(&quot;got = {}&quot;, i);&#10;///     }&#10;/// }&#10;/// ```&#10;#[track_caller]&#10;pub fn channel&lt;T&gt;(buffer: usize) -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {&#10;    assert!(buffer &gt; 0, &quot;mpsc bounded channel requires buffer &gt; 0&quot;);&#10;    let semaphore = Semaphore {&#10;        semaphore: semaphore::Semaphore::new(buffer),&#10;        bound: buffer,&#10;    };&#10;    let (tx, rx) = chan::channel(semaphore);&#10;&#10;    let tx = Sender::new(tx);&#10;    let rx = Receiver::new(rx);&#10;&#10;    (tx, rx)&#10;}&#10;&#10;/// Channel semaphore is a tuple of the semaphore implementation and a `usize`&#10;/// representing the channel bound.&#10;#[derive(Debug)]&#10;pub(crate) struct Semaphore {&#10;    pub(crate) semaphore: semaphore::Semaphore,&#10;    pub(crate) bound: usize,&#10;}&#10;&#10;impl&lt;T&gt; Receiver&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Rx&lt;T, Semaphore&gt;) -&gt; Receiver&lt;T&gt; {&#10;        Receiver { chan }&#10;    }&#10;&#10;    /// Receives the next value for this receiver.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will sleep until a message is sent or&#10;    /// the channel is closed.  Note that if [`close`] is called, but there are&#10;    /// still outstanding [`Permits`] from before it was closed, the channel is&#10;    /// not considered closed by `recv` until the permits are released.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(None, rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// Values are buffered:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     tx.send(&quot;world&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(Some(&quot;world&quot;), rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv(cx)).await&#10;    }&#10;&#10;    /// Receives the next values for this receiver and extends `buffer`.&#10;    ///&#10;    /// This method extends `buffer` by no more than a fixed number of values&#10;    /// as specified by `limit`. If `limit` is zero, the function immediately&#10;    /// returns `0`. The return value is the number of values added to `buffer`.&#10;    ///&#10;    /// For `limit &gt; 0`, if there are no messages in the channel's queue, but&#10;    /// the channel has not yet been closed, this method will sleep until a&#10;    /// message is sent or the channel is closed. Note that if [`close`] is&#10;    /// called, but there are still outstanding [`Permits`] from before it was&#10;    /// closed, the channel is not considered closed by `recv_many` until the&#10;    /// permits are released.&#10;    ///&#10;    /// For non-zero values of `limit`, this method will never return `0` unless&#10;    /// the channel has been closed and there are no remaining messages in the&#10;    /// channel's queue. This indicates that no further values can ever be&#10;    /// received from this `Receiver`. The channel is closed when all senders&#10;    /// have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// The capacity of `buffer` is increased as needed.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv_many` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let mut buffer: Vec&lt;&amp;str&gt; = Vec::with_capacity(2);&#10;    ///     let limit = 2;&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///     let tx2 = tx.clone();&#10;    ///     tx2.send(&quot;first&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;second&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;third&quot;).await.unwrap();&#10;    ///&#10;    ///     // Call `recv_many` to receive up to `limit` (2) values.&#10;    ///     assert_eq!(2, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;], buffer);&#10;    ///&#10;    ///     // If the buffer is full, the next call to `recv_many`&#10;    ///     // reserves additional capacity.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;fourth&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     // 'tx' is dropped, but `recv_many`&#10;    ///     // is guaranteed not to return 0 as the channel&#10;    ///     // is not yet closed.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    ///&#10;    ///     // Once the last sender is dropped, the channel is&#10;    ///     // closed and `recv_many` returns 0, capacity unchanged.&#10;    ///     drop(tx2);&#10;    ///     assert_eq!(0, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv_many(cx, buffer, limit)).await&#10;    }&#10;&#10;    /// Tries to receive the next value for this receiver.&#10;    ///&#10;    /// This method returns the [`Empty`] error if the channel is currently&#10;    /// empty, but there are still outstanding [senders] or [permits].&#10;    ///&#10;    /// This method returns the [`Disconnected`] error if the channel is&#10;    /// currently empty, and there are no outstanding [senders] or [permits].&#10;    ///&#10;    /// Unlike the [`poll_recv`] method, this method will never return an&#10;    /// [`Empty`] error spuriously.&#10;    ///&#10;    /// [`Empty`]: crate::sync::mpsc::error::TryRecvError::Empty&#10;    /// [`Disconnected`]: crate::sync::mpsc::error::TryRecvError::Disconnected&#10;    /// [`poll_recv`]: Self::poll_recv&#10;    /// [senders]: crate::sync::mpsc::Sender&#10;    /// [permits]: crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::sync::mpsc::error::TryRecvError;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Empty), rx.try_recv());&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     // Drop the last sender, closing the channel.&#10;    ///     drop(tx);&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Disconnected), rx.try_recv());&#10;    /// }&#10;    /// ```&#10;    pub fn try_recv(&amp;mut self) -&gt; Result&lt;T, TryRecvError&gt; {&#10;        self.chan.try_recv()&#10;    }&#10;&#10;    /// Blocking receive to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will block until a message is sent or&#10;    /// the channel is closed.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// asynchronous code to synchronous code, and will work even if the sender&#10;    /// is not using [`blocking_send`] to send the message.&#10;    ///&#10;    /// Note that if [`close`] is called, but there are still outstanding&#10;    /// [`Permits`] from before it was closed, the channel is not considered&#10;    /// closed by `blocking_recv` until the permits are released.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    /// [`blocking_send`]: fn@crate::sync::mpsc::Sender::blocking_send&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(10);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         assert_eq!(Some(10), rx.blocking_recv());&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new()&#10;    ///         .unwrap()&#10;    ///         .block_on(async move {&#10;    ///             let _ = tx.send(10).await;&#10;    ///         });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_blocking&quot;))]&#10;    pub fn blocking_recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        crate::future::block_on(self.recv())&#10;    }&#10;&#10;    /// Variant of [`Self::recv_many`] for blocking contexts.&#10;    ///&#10;    /// The same conditions as in [`Self::blocking_recv`] apply.&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_many_blocking&quot;))]&#10;    pub fn blocking_recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        crate::future::block_on(self.recv_many(buffer, limit))&#10;    }&#10;&#10;    /// Closes the receiving half of a channel without dropping it.&#10;    ///&#10;    /// This prevents any further messages from being sent on the channel while&#10;    /// still enabling the receiver to drain messages that are buffered. Any&#10;    /// outstanding [`Permit`] values will still be able to send messages.&#10;    ///&#10;    /// To guarantee that no messages are dropped, after calling `close()`,&#10;    /// `recv()` must be called until `None` is returned. If there are&#10;    /// outstanding [`Permit`] or [`OwnedPermit`] values, the `recv` method will&#10;    /// not return `None` until those are released.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(20);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         let mut i = 0;&#10;    ///         while let Ok(permit) = tx.reserve().await {&#10;    ///             permit.send(i);&#10;    ///             i += 1;&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     while let Some(msg) = rx.recv().await {&#10;    ///         println!(&quot;got {}&quot;, msg);&#10;    ///     }&#10;    ///&#10;    ///     // Channel closed and no messages are lost.&#10;    /// }&#10;    /// ```&#10;    pub fn close(&amp;mut self) {&#10;        self.chan.close();&#10;    }&#10;&#10;    /// Checks if a channel is closed.&#10;    ///&#10;    /// This method returns `true` if the channel has been closed. The channel is closed&#10;    /// when all [`Sender`] have been dropped, or when [`Receiver::close`] is called.&#10;    ///&#10;    /// [`Sender`]: crate::sync::mpsc::Sender&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (_tx, mut rx) = mpsc::channel::&lt;()&gt;(10);&#10;    ///     assert!(!rx.is_closed());&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     assert!(rx.is_closed());&#10;    /// }&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Checks if a channel is empty.&#10;    ///&#10;    /// This method returns `true` if the channel has no messages.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert!(rx.is_empty());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert!(!rx.is_empty());&#10;    /// }&#10;    ///&#10;    /// ```&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.chan.is_empty()&#10;    }&#10;&#10;    /// Returns the number of messages in the channel.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert_eq!(0, rx.len());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert_eq!(1, rx.len());&#10;    /// }&#10;    /// ```&#10;    pub fn len(&amp;self) -&gt; usize {&#10;        self.chan.len()&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when the sender sends a value by calling [`Sender::send`] or by reserving&#10;    /// capacity with [`Sender::reserve`]. The capacity goes up when values are received.&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Directly sending a message drops the capacity by one.&#10;    ///     tx.send(()).await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///&#10;    ///     // Receiving the message increases the capacity by one.&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the value&#10;    /// returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Polls to receive the next message on this channel.&#10;    ///&#10;    /// This method returns:&#10;    ///&#10;    ///  * `Poll::Pending` if no messages are available but the channel is not&#10;    ///    closed, or if a spurious failure happens.&#10;    ///  * `Poll::Ready(Some(message))` if a message is available.&#10;    ///  * `Poll::Ready(None)` if the channel has been closed and all messages&#10;    ///    sent before it was closed have been received.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// If this method returns `Poll::Pending` due to a spurious failure, then&#10;    /// the `Waker` will be notified when the situation causing the spurious&#10;    /// failure has been resolved. Note that receiving such a wakeup does not&#10;    /// guarantee that the next call will succeed — it could fail with another&#10;    /// spurious failure.&#10;    pub fn poll_recv(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;T&gt;&gt; {&#10;        self.chan.recv(cx)&#10;    }&#10;&#10;    /// Polls to receive multiple messages on this channel, extending the provided buffer.&#10;    ///&#10;    /// This method returns:&#10;    /// * `Poll::Pending` if no messages are available but the channel is not closed, or if a&#10;    ///   spurious failure happens.&#10;    /// * `Poll::Ready(count)` where `count` is the number of messages successfully received and&#10;    ///   stored in `buffer`. This can be less than, or equal to, `limit`.&#10;    /// * `Poll::Ready(0)` if `limit` is set to zero or when the channel is closed.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// Note that this method does not guarantee that exactly `limit` messages&#10;    /// are received. Rather, if at least one message is available, it returns&#10;    /// as many messages as it can up to the given limit. This method returns&#10;    /// zero only if the channel is closed (or if `limit` is zero).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::task::{Context, Poll};&#10;    /// use std::pin::Pin;&#10;    /// use tokio::sync::mpsc;&#10;    /// use futures::Future;&#10;    ///&#10;    /// struct MyReceiverFuture&lt;'a&gt; {&#10;    ///     receiver: mpsc::Receiver&lt;i32&gt;,&#10;    ///     buffer: &amp;'a mut Vec&lt;i32&gt;,&#10;    ///     limit: usize,&#10;    /// }&#10;    ///&#10;    /// impl&lt;'a&gt; Future for MyReceiverFuture&lt;'a&gt; {&#10;    ///     type Output = usize; // Number of messages received&#10;    ///&#10;    ///     fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {&#10;    ///         let MyReceiverFuture { receiver, buffer, limit } = &amp;mut *self;&#10;    ///&#10;    ///         // Now `receiver` and `buffer` are mutable references, and `limit` is copied&#10;    ///         match receiver.poll_recv_many(cx, *buffer, *limit) {&#10;    ///             Poll::Pending =&gt; Poll::Pending,&#10;    ///             Poll::Ready(count) =&gt; Poll::Ready(count),&#10;    ///         }&#10;    ///     }&#10;    /// }&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(32);&#10;    ///     let mut buffer = Vec::new();&#10;    ///&#10;    ///     let my_receiver_future = MyReceiverFuture {&#10;    ///         receiver: rx,&#10;    ///         buffer: &amp;mut buffer,&#10;    ///         limit: 3,&#10;    ///     };&#10;    ///&#10;    ///     for i in 0..10 {&#10;    ///         tx.send(i).await.unwrap();&#10;    ///     }&#10;    ///&#10;    ///     let count = my_receiver_future.await;&#10;    ///     assert_eq!(count, 3);&#10;    ///     assert_eq!(buffer, vec![0,1,2])&#10;    /// }&#10;    /// ```&#10;    pub fn poll_recv_many(&#10;        &amp;mut self,&#10;        cx: &amp;mut Context&lt;'_&gt;,&#10;        buffer: &amp;mut Vec&lt;T&gt;,&#10;        limit: usize,&#10;    ) -&gt; Poll&lt;usize&gt; {&#10;        self.chan.recv_many(cx, buffer, limit)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn sender_strong_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn sender_weak_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Receiver&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Receiver&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Unpin for Receiver&lt;T&gt; {}&#10;&#10;impl&lt;T&gt; Sender&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Tx&lt;T, Semaphore&gt;) -&gt; Sender&lt;T&gt; {&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity.&#10;    ///&#10;    /// A successful send occurs when it is determined that the other end of the&#10;    /// channel has not hung up already. An unsuccessful send would be one where&#10;    /// the corresponding receiver has already been closed. Note that a return&#10;    /// value of `Err` means that the data will never be received, but a return&#10;    /// value of `Ok` does not mean that the data will be received. It is&#10;    /// possible for the corresponding receiver to hang up immediately after&#10;    /// this function returns `Ok`.&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// If `send` is used as the event in a [`tokio::select!`](crate::select)&#10;    /// statement and some other branch completes first, then it is guaranteed&#10;    /// that the message was not sent. **However, in that case, the message&#10;    /// is dropped and will be lost.**&#10;    ///&#10;    /// To avoid losing messages, use [`reserve`](Self::reserve) to reserve&#10;    /// capacity, then use the returned [`Permit`] to send the message.&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `send` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send` will block until the&#10;    /// previously sent value was received.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(_) = tx.send(i).await {&#10;    ///                 println!(&quot;receiver dropped&quot;);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub async fn send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        match self.reserve().await {&#10;            Ok(permit) =&gt; {&#10;                permit.send(value);&#10;                Ok(())&#10;            }&#10;            Err(_) =&gt; Err(SendError(value)),&#10;        }&#10;    }&#10;&#10;    /// Completes when the receiver has dropped.&#10;    ///&#10;    /// This allows the producers to get notified when interest in the produced&#10;    /// values is canceled and immediately stop doing work.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. Once the channel is closed, it stays closed&#10;    /// forever and all future calls to `closed` will return immediately.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx1, rx) = mpsc::channel::&lt;()&gt;(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///     let tx3 = tx1.clone();&#10;    ///     let tx4 = tx1.clone();&#10;    ///     let tx5 = tx1.clone();&#10;    ///     tokio::spawn(async move {&#10;    ///         drop(rx);&#10;    ///     });&#10;    ///&#10;    ///     futures::join!(&#10;    ///         tx1.closed(),&#10;    ///         tx2.closed(),&#10;    ///         tx3.closed(),&#10;    ///         tx4.closed(),&#10;    ///         tx5.closed()&#10;    ///     );&#10;    ///     println!(&quot;Receiver dropped&quot;);&#10;    /// }&#10;    /// ```&#10;    pub async fn closed(&amp;self) {&#10;        self.chan.closed().await;&#10;    }&#10;&#10;    /// Attempts to immediately send a message on this `Sender`&#10;    ///&#10;    /// This method differs from [`send`] by returning immediately if the channel's&#10;    /// buffer is full or no receiver is waiting to acquire some data. Compared&#10;    /// with [`send`], this function has two failure cases instead of one (one for&#10;    /// disconnection, one for a full buffer).&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the channel capacity has been reached, i.e., the channel has `n`&#10;    /// buffered values where `n` is the argument passed to [`channel`], then an&#10;    /// error is returned.&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`channel`]: channel&#10;    /// [`close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     // Create a channel with buffer size 1&#10;    ///     let (tx1, mut rx) = mpsc::channel(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx1.send(1).await.unwrap();&#10;    ///         tx1.send(2).await.unwrap();&#10;    ///         // task waits until the receiver receives a value.&#10;    ///     });&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         // This will return an error and send&#10;    ///         // no message if the buffer is full&#10;    ///         let _ = tx2.try_send(3);&#10;    ///     });&#10;    ///&#10;    ///     let mut msg;&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     // Third message may have never been sent&#10;    ///     match rx.recv().await {&#10;    ///         Some(msg) =&gt; println!(&quot;message {} received&quot;, msg),&#10;    ///         None =&gt; println!(&quot;the third message was never sent&quot;),&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub fn try_send(&amp;self, message: T) -&gt; Result&lt;(), TrySendError&lt;T&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(message)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(message)),&#10;        }&#10;&#10;        // Send the message&#10;        self.chan.send(message);&#10;        Ok(())&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity, but only for a limited time.&#10;    ///&#10;    /// Shares the same success and error conditions as [`send`], adding one more&#10;    /// condition for an unsuccessful send, which is when the provided timeout has&#10;    /// elapsed, and there is no capacity available.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] having been dropped,&#10;    /// the function returns an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if it is called outside the context of a Tokio&#10;    /// runtime [with time enabled](crate::runtime::Builder::enable_time).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send_timeout` will block until the&#10;    /// previously sent value was received, unless the timeout has elapsed.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::time::{sleep, Duration};&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(e) = tx.send_timeout(i, Duration::from_millis(100)).await {&#10;    ///                 println!(&quot;send error: #{:?}&quot;, e);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///         sleep(Duration::from_millis(200)).await;&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    #[cfg(feature = &quot;time&quot;)]&#10;    #[cfg_attr(docsrs, doc(cfg(feature = &quot;time&quot;)))]&#10;    pub async fn send_timeout(&#10;        &amp;self,&#10;        value: T,&#10;        timeout: Duration,&#10;    ) -&gt; Result&lt;(), SendTimeoutError&lt;T&gt;&gt; {&#10;        let permit = match crate::time::timeout(timeout, self.reserve()).await {&#10;            Err(_) =&gt; {&#10;                return Err(SendTimeoutError::Timeout(value));&#10;            }&#10;            Ok(Err(_)) =&gt; {&#10;                return Err(SendTimeoutError::Closed(value));&#10;            }&#10;            Ok(Ok(permit)) =&gt; permit,&#10;        };&#10;&#10;        permit.send(value);&#10;        Ok(())&#10;    }&#10;&#10;    /// Blocking send to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// synchronous code to asynchronous code, and will work even if the&#10;    /// receiver is not using [`blocking_recv`] to receive the message.&#10;    ///&#10;    /// [`blocking_recv`]: fn@crate::sync::mpsc::Receiver::blocking_recv&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(1);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         tx.blocking_send(10).unwrap();&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new().unwrap().block_on(async move {&#10;    ///         assert_eq!(Some(10), rx.recv().await);&#10;    ///     });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;send_blocking&quot;))]&#10;    pub fn blocking_send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        crate::future::block_on(self.send(value))&#10;    }&#10;&#10;    /// Checks if the channel has been closed. This happens when the&#10;    /// [`Receiver`] is dropped, or when the [`Receiver::close`] method is&#10;    /// called.&#10;    ///&#10;    /// [`Receiver`]: crate::sync::mpsc::Receiver&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(42);&#10;    /// assert!(!tx.is_closed());&#10;    ///&#10;    /// let tx2 = tx.clone();&#10;    /// assert!(!tx2.is_closed());&#10;    ///&#10;    /// drop(rx);&#10;    /// assert!(tx.is_closed());&#10;    /// assert!(tx2.is_closed());&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send one message is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. A [`Permit`] is returned to track&#10;    /// the reserved capacity. The [`send`] function on [`Permit`] consumes the&#10;    /// reserved capacity.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send `n` messages is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full or if there are fewer than `n` permits available, the function waits&#10;    /// for the number of unreceived messages to become `n` less than the channel capacity.&#10;    /// Capacity to send `n` message is then reserved for the caller.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`try_reserve_many`] except it awaits for the slots to become available.&#10;    ///&#10;    /// If the channel is closed, the function returns a [`SendError`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`try_reserve_many`]: Sender::try_reserve_many&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve_many`&#10;    /// complete in the order they were requested. Cancelling a call to&#10;    /// `reserve_many` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.reserve_many(2).await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(n).await?;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Waits for channel capacity, moving the `Sender` and returning an owned&#10;    /// permit. Once capacity to send one message is available, it is reserved&#10;    /// for the caller.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime. `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `reserve_owned`.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. An [`OwnedPermit`] is returned to&#10;    /// track the reserved capacity. The [`send`] function on [`OwnedPermit`]&#10;    /// consumes the reserved capacity.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the&#10;    /// capacity back to the channel.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve_owned` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    /// Sending a message using an [`OwnedPermit`]:&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity, moving the sender.&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message, consuming the permit and returning&#10;    ///     // the moved sender.&#10;    ///     let tx = permit.send(123);&#10;    ///&#10;    ///     // The value sent on the permit is received.&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 123);&#10;    ///&#10;    ///     // The sender can now be used again.&#10;    ///     tx.send(456).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// When multiple [`OwnedPermit`]s are needed, or the sender cannot be moved&#10;    /// by value, it can be inexpensively cloned before calling `reserve_owned`:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity.&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds.&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender::reserve`]: Sender::reserve&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    pub async fn reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    async fn reserve_inner(&amp;self, n: usize) -&gt; Result&lt;(), SendError&lt;()&gt;&gt; {&#10;        crate::trace::async_trace_leaf().await;&#10;&#10;        if n &gt; self.max_capacity() {&#10;            return Err(SendError(()));&#10;        }&#10;        match self.chan.semaphore().semaphore.acquire(n).await {&#10;            Ok(()) =&gt; Ok(()),&#10;            Err(_) =&gt; Err(SendError(())),&#10;        }&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// If the channel is full this function will return [`TrySendError`], otherwise&#10;    /// if there is a slot available it will return a [`Permit`] that will then allow you&#10;    /// to [`send`] on the channel with a guaranteed slot. This function is similar to&#10;    /// [`reserve`] except it does not await for the slot to become available.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve`]: Sender::reserve&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.try_reserve().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Tries to acquire `n` slots in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`reserve_many`] except it does not await for the slots to become available.&#10;    ///&#10;    /// If there are fewer than `n` permits available on the channel, then&#10;    /// this function will return a [`TrySendError::Full`]. If the channel is closed&#10;    /// this function will return a [`TrySendError::Closed`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve_many`]: Sender::reserve_many&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.try_reserve_many(2).unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    ///&#10;    ///     // Trying to call try_reserve_many with 0 will return an empty iterator&#10;    ///     let mut permit = tx.try_reserve_many(0).unwrap();&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // Trying to call try_reserve_many with a number greater than the channel&#10;    ///     // capacity will return an error&#10;    ///     let permit = tx.try_reserve_many(3);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     // Trying to call try_reserve_many on a closed channel will return an error&#10;    ///     drop(rx);&#10;    ///     let permit = tx.try_reserve_many(1);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     let permit = tx.try_reserve_many(0);&#10;    ///     assert!(permit.is_err());&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        if n &gt; self.max_capacity() {&#10;            return Err(TrySendError::Full(()));&#10;        }&#10;&#10;        match self.chan.semaphore().semaphore.try_acquire(n) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available, returning an owned permit.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::try_reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime.  `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `try_reserve_owned`.&#10;    ///&#10;    /// If the channel is full this function will return a [`TrySendError`].&#10;    /// Since the sender is taken by value, the `TrySendError` returned in this&#10;    /// case contains the sender, so that it may be used again. Otherwise, if&#10;    /// there is a slot available, this method will return an [`OwnedPermit`]&#10;    /// that can then be used to [`send`] on the channel with a guaranteed slot.&#10;    /// This function is similar to  [`reserve_owned`] except it does not await&#10;    /// for the slot to become available.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`reserve_owned`]: Sender::reserve_owned&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.clone().try_reserve_owned().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, TrySendError&lt;Self&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(self)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(self)),&#10;        }&#10;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    /// Returns `true` if senders belong to the same channel.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// let  tx2 = tx.clone();&#10;    /// assert!(tx.same_channel(&amp;tx2));&#10;    ///&#10;    /// let (tx3, rx3) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// assert!(!tx3.same_channel(&amp;tx2));&#10;    /// ```&#10;    pub fn same_channel(&amp;self, other: &amp;Self) -&gt; bool {&#10;        self.chan.same_channel(&amp;other.chan)&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when sending a value by calling [`send`] or by reserving capacity&#10;    /// with [`reserve`]. The capacity goes up when values are received by the [`Receiver`].&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`]&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`reserve`]: Sender::reserve&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Converts the `Sender` to a [`WeakSender`] that does not count&#10;    /// towards RAII semantics, i.e. if all `Sender` instances of the&#10;    /// channel were dropped and only `WeakSender` instances remain,&#10;    /// the channel is closed.&#10;    #[must_use = &quot;Downgrade creates a WeakSender without destroying the original non-weak sender.&quot;]&#10;    pub fn downgrade(&amp;self) -&gt; WeakSender&lt;T&gt; {&#10;        WeakSender {&#10;            chan: self.chan.downgrade(),&#10;        }&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the&#10;    /// value returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, _rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    /// [`capacity`]: Sender::capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for Sender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        Sender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Sender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Sender&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for WeakSender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        self.chan.increment_weak_count();&#10;&#10;        WeakSender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for WeakSender&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        self.chan.decrement_weak_count();&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; WeakSender&lt;T&gt; {&#10;    /// Tries to convert a `WeakSender` into a [`Sender`]. This will return `Some`&#10;    /// if there are other `Sender` instances alive and the channel wasn't&#10;    /// previously dropped, otherwise `None` is returned.&#10;    pub fn upgrade(&amp;self) -&gt; Option&lt;Sender&lt;T&gt;&gt; {&#10;        chan::Tx::upgrade(self.chan.clone()).map(Sender::new)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for WeakSender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;WeakSender&quot;).finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; Permit&lt;'_, T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Send a message on the permit&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub fn send(self, value: T) {&#10;        use std::mem;&#10;&#10;        self.chan.send(value);&#10;&#10;        // Avoid the drop logic&#10;        mem::forget(self);&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for Permit&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the permit back to the semaphore&#10;        semaphore.add_permit();&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Permit&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Permit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl PermitIterator =====&#10;&#10;impl&lt;'a, T&gt; Iterator for PermitIterator&lt;'a, T&gt; {&#10;    type Item = Permit&lt;'a, T&gt;;&#10;&#10;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {&#10;        if self.n == 0 {&#10;            return None;&#10;        }&#10;&#10;        self.n -= 1;&#10;        Some(Permit { chan: self.chan })&#10;    }&#10;&#10;    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {&#10;        let n = self.n;&#10;        (n, Some(n))&#10;    }&#10;}&#10;impl&lt;T&gt; ExactSizeIterator for PermitIterator&lt;'_, T&gt; {}&#10;impl&lt;T&gt; std::iter::FusedIterator for PermitIterator&lt;'_, T&gt; {}&#10;&#10;impl&lt;T&gt; Drop for PermitIterator&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        if self.n == 0 {&#10;            return;&#10;        }&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the remaining permits back to the semaphore&#10;        semaphore.add_permits(self.n);&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for PermitIterator&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;PermitIterator&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .field(&quot;capacity&quot;, &amp;self.n)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; OwnedPermit&lt;T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// Unlike [`Permit::send`], this method returns the [`Sender`] from which&#10;    /// the `OwnedPermit` was reserved.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message on the permit, returning the sender.&#10;    ///     let tx = permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    pub fn send(mut self, value: T) -&gt; Sender&lt;T&gt; {&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;        chan.send(value);&#10;&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Releases the reserved capacity *without* sending a message, returning the&#10;    /// [`Sender`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send on the original `tx` will fail, since the `permit`&#10;    ///     // has reserved all the available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Release the permit without sending a message, returning the clone&#10;    ///     // of the sender.&#10;    ///     let tx2 = permit.release();&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    ///     # drop(rx); drop(tx2);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender`]: Sender&#10;    pub fn release(mut self) -&gt; Sender&lt;T&gt; {&#10;        use chan::Semaphore;&#10;&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;&#10;        // Add the permit back to the semaphore&#10;        chan.semaphore().add_permit();&#10;        Sender { chan }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for OwnedPermit&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        // Are we still holding onto the sender?&#10;        if let Some(chan) = self.chan.take() {&#10;            let semaphore = chan.semaphore();&#10;&#10;            // Add the permit back to the semaphore&#10;            semaphore.add_permit();&#10;&#10;            // If this `OwnedPermit` is holding the last sender for this&#10;            // channel, wake the receiver so that it can be notified that the&#10;            // channel is closed.&#10;            if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;                chan.wake_rx();&#10;            }&#10;        }&#10;&#10;        // Otherwise, do nothing.&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for OwnedPermit&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;OwnedPermit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979f02af467cc598f2e2eee505fb04" />
                <option name="question" value="翻译到中文" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;我们正在翻译一段Ifhg文档注释，内容是关于Glprl库中NKHX（多生产者单消费者）有界通道的`xzkzxrgb`方法。&#10; 注意：需要保留Nzipwldm格式和代码块，以及文档注释中的链接标记。&#10; 翻译要求：技术术语准确，符合中文技术文档习惯，保持示例代码不变（因为代码是英文的，且字符串内容不应翻译）。&#10;&#10;&lt;/gsrmp&gt;&#10;&#10;好的，这是您提供的 Ifhg 文档的中文翻译：&#10;&#10;```ifhg&#10;    /// 返回通道的当前容量。&#10;    ///&#10;    /// 当发送方通过调用 [`Hvmwvi::hvmw`] 或使用 [`Hvmwvi::ivhviev`] 预留容量时，容量会减少。&#10;    /// 当值被接收时，容量会增加。&#10;    /// 这与 [`nzc_xzkzxrgb`] 不同，后者始终返回调用 [`xszmmvo`] 时初始指定的缓冲区容量。&#10;    ///&#10;    /// # 示例&#10;    ///&#10;    /// ```&#10;    /// fhv glprl::hbmx::nkhx;&#10;    ///&#10;    /// #[glprl::nzrm]&#10;    /// zhbmx um nzrm() {&#10;    ///     ovg (gc, nfg ic) = nkhx::xszmmvo::&lt;()&gt;(4);&#10;    ///&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 4);&#10;    ///&#10;    ///     // 预留容量会使容量减少8&#10;    ///     ovg kvinrg = gc.ivhviev().zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 5);&#10;    ///     zhhvig_vj!(ic.ovm(), 9);&#10;    ///&#10;    ///     // 发送并接收一个值会使容量增加8&#10;    ///     kvinrg.hvmw(());&#10;    ///     zhhvig_vj!(ic.ovm(), 8);&#10;    ///     ic.ivxe().zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 4);&#10;    ///&#10;    ///     // 直接发送消息会使容量减少8&#10;    ///     gc.hvmw(()).zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 5);&#10;    ///     zhhvig_vj!(ic.ovm(), 8);&#10;    ///&#10;    ///     // 接收消息会使容量增加8&#10;    ///     ic.ivxe().zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 4);&#10;    ///     zhhvig_vj!(ic.ovm(), 9);&#10;    /// }&#10;    /// ```&#10;    /// [`xzkzxrgb`]: Ivxvrevi::xzkzxrgb&#10;    /// [`nzc_xzkzxrgb`]: Ivxvrevi::nzc_xzkzxrgb&#10;```&#10;&#10;### 关键术语翻译：&#10;8. **xzkzxrgb** → **容量**&#10;7. **ivhviev** → **预留**&#10;6. **yfuuvi xzkzxrgb** → **缓冲区容量**&#10;5. **nzc xzkzxrgb** → **最大容量**&#10;4. **kvinrg** → **许可**&#10;3. **xszmmvo** → **通道**&#10;&#10;### 翻译说明：&#10;8. 保持了原始文档的技术准确性和结构&#10;7. 使用中文技术文档常见的表达方式&#10;6. 示例代码保持原样未翻译（符合技术文档惯例）&#10;5. 链接标记（如 `[`Hvmwvi::hvmw`]`）保持原结构&#10;4. 添加了必要的技术术语注释以帮助理解&#10;&#10;这个翻译准确传达了原始文档的技术内容，同时符合中文技术文档的表达习惯，特别是清晰地解释了容量变化的机制以及与最大容量的区别。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    /// Ivgfimh gsv xfiivmg xzkzxrgb lu gsv xszmmvo.&#10;    ///&#10;    /// Gsv xzkzxrgb tlvh wldm dsvm gsv hvmwvi hvmwh z ezofv yb xzoormt [`Hvmwvi::hvmw`] li yb ivhviermt&#10;    /// xzkzxrgb drgs [`Hvmwvi::ivhviev`]. Gsv xzkzxrgb tlvh fk dsvm ezofvh ziv ivxvrevw.&#10;    /// Gsrh rh wrhgrmxg uiln [`nzc_xzkzxrgb`], dsrxs zodzbh ivgfimh yfuuvi xzkzxrgb rmrgrzoob&#10;    /// hkvxrurvw dsvm xzoormt [`xszmmvo`].&#10;    ///&#10;    /// # Vcznkovh&#10;    ///&#10;    /// ```&#10;    /// fhv glprl::hbmx::nkhx;&#10;    ///&#10;    /// #[glprl::nzrm]&#10;    /// zhbmx um nzrm() {&#10;    ///     ovg (gc, nfg ic) = nkhx::xszmmvo::&lt;()&gt;(4);&#10;    ///&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 4);&#10;    ///&#10;    ///     // Nzprmt z ivhviezgrlm wilkh gsv xzkzxrgb yb lmv.&#10;    ///     ovg kvinrg = gc.ivhviev().zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 5);&#10;    ///     zhhvig_vj!(ic.ovm(), 9);&#10;    ///&#10;    ///     // Hvmwrmt zmw ivxvrermt z ezofv rmxivzhvh gsv xzkzxrgb yb lmv.&#10;    ///     kvinrg.hvmw(());&#10;    ///     zhhvig_vj!(ic.ovm(), 8);&#10;    ///     ic.ivxe().zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 4);&#10;    ///&#10;    ///     // Wrivxgob hvmwrmt z nvhhztv wilkh gsv xzkzxrgb yb lmv.&#10;    ///     gc.hvmw(()).zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 5);&#10;    ///     zhhvig_vj!(ic.ovm(), 8);&#10;    ///&#10;    ///     // Ivxvrermt gsv nvhhztv rmxivzhvh gsv xzkzxrgb yb lmv.&#10;    ///     ic.ivxe().zdzrg.fmdizk();&#10;    ///     zhhvig_vj!(ic.xzkzxrgb(), 4);&#10;    ///     zhhvig_vj!(ic.ovm(), 9);&#10;    /// }&#10;    /// ```&#10;    /// [`xzkzxrgb`]: Ivxvrevi::xzkzxrgb&#10;    /// [`nzc_xzkzxrgb`]: Ivxvrevi::nzc_xzkzxrgb&#10;" />
                      <option name="end_line" value="583" />
                      <option name="filename" value="bounded.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="48" />
                              <option name="line" value="583" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="542" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="542" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979ed3daec7cc598f2cc98e32a7a46" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" value="use crate::loom::sync::Arc;&#10;use crate::sync::batch_semaphore::{self as semaphore, TryAcquireError};&#10;use crate::sync::mpsc::chan;&#10;use crate::sync::mpsc::error::{SendError, TryRecvError, TrySendError};&#10;&#10;cfg_time! {&#10;    use crate::sync::mpsc::error::SendTimeoutError;&#10;    use crate::time::Duration;&#10;}&#10;&#10;use std::fmt;&#10;use std::task::{Context, Poll};&#10;&#10;/// Sends values to the associated `Receiver`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// To convert the `Sender` into a `Sink` or use it in a poll function, you can&#10;/// use the [`PollSender`] utility.&#10;///&#10;/// [`PollSender`]: https://docs.rs/tokio-util/latest/tokio_util/sync/struct.PollSender.html&#10;pub struct Sender&lt;T&gt; {&#10;    chan: chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// A sender that does not prevent the channel from being closed.&#10;///&#10;/// If all [`Sender`] instances of a channel were dropped and only `WeakSender`&#10;/// instances remain, the channel is closed.&#10;///&#10;/// In order to send messages, the `WeakSender` needs to be upgraded using&#10;/// [`WeakSender::upgrade`], which returns `Option&lt;Sender&gt;`. It returns `None`&#10;/// if all `Sender`s have been dropped, and otherwise it returns a `Sender`.&#10;///&#10;/// [`Sender`]: Sender&#10;/// [`WeakSender::upgrade`]: WeakSender::upgrade&#10;///&#10;/// # Examples&#10;///&#10;/// ```&#10;/// use tokio::sync::mpsc::channel;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, _rx) = channel::&lt;i32&gt;(15);&#10;///     let tx_weak = tx.downgrade();&#10;///&#10;///     // Upgrading will succeed because `tx` still exists.&#10;///     assert!(tx_weak.upgrade().is_some());&#10;///&#10;///     // If we drop `tx`, then it will fail.&#10;///     drop(tx);&#10;///     assert!(tx_weak.clone().upgrade().is_none());&#10;/// }&#10;/// ```&#10;pub struct WeakSender&lt;T&gt; {&#10;    chan: Arc&lt;chan::Chan&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Permits to send one value into the channel.&#10;///&#10;/// `Permit` values are returned by [`Sender::reserve()`] and [`Sender::try_reserve()`]&#10;/// and are used to guarantee channel capacity before generating a message to send.&#10;///&#10;/// [`Sender::reserve()`]: Sender::reserve&#10;/// [`Sender::try_reserve()`]: Sender::try_reserve&#10;pub struct Permit&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// An [`Iterator`] of [`Permit`] that can be used to hold `n` slots in the channel.&#10;///&#10;/// `PermitIterator` values are returned by [`Sender::reserve_many()`] and [`Sender::try_reserve_many()`]&#10;/// and are used to guarantee channel capacity before generating `n` messages to send.&#10;///&#10;/// [`Sender::reserve_many()`]: Sender::reserve_many&#10;/// [`Sender::try_reserve_many()`]: Sender::try_reserve_many&#10;pub struct PermitIterator&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;    n: usize,&#10;}&#10;&#10;/// Owned permit to send one value into the channel.&#10;///&#10;/// This is identical to the [`Permit`] type, except that it moves the sender&#10;/// rather than borrowing it.&#10;///&#10;/// `OwnedPermit` values are returned by [`Sender::reserve_owned()`] and&#10;/// [`Sender::try_reserve_owned()`] and are used to guarantee channel capacity&#10;/// before generating a message to send.&#10;///&#10;/// [`Permit`]: Permit&#10;/// [`Sender::reserve_owned()`]: Sender::reserve_owned&#10;/// [`Sender::try_reserve_owned()`]: Sender::try_reserve_owned&#10;pub struct OwnedPermit&lt;T&gt; {&#10;    chan: Option&lt;chan::Tx&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Receives values from the associated `Sender`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// This receiver can be turned into a `Stream` using [`ReceiverStream`].&#10;///&#10;/// [`ReceiverStream`]: https://docs.rs/tokio-stream/0.1/tokio_stream/wrappers/struct.ReceiverStream.html&#10;pub struct Receiver&lt;T&gt; {&#10;    /// The channel receiver.&#10;    chan: chan::Rx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// Creates a bounded mpsc channel for communicating between asynchronous tasks&#10;/// with backpressure.&#10;///&#10;/// The channel will buffer up to the provided number of messages.  Once the&#10;/// buffer is full, attempts to send new messages will wait until a message is&#10;/// received from the channel. The provided buffer capacity must be at least 1.&#10;///&#10;/// All data sent on `Sender` will become available on `Receiver` in the same&#10;/// order as it was sent.&#10;///&#10;/// The `Sender` can be cloned to `send` to the same channel from multiple code&#10;/// locations. Only one `Receiver` is supported.&#10;///&#10;/// If the `Receiver` is disconnected while trying to `send`, the `send` method&#10;/// will return a `SendError`. Similarly, if `Sender` is disconnected while&#10;/// trying to `recv`, the `recv` method will return `None`.&#10;///&#10;/// # Panics&#10;///&#10;/// Panics if the buffer capacity is 0.&#10;///&#10;/// # Examples&#10;///&#10;/// ```rust&#10;/// use tokio::sync::mpsc;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, mut rx) = mpsc::channel(100);&#10;///&#10;///     tokio::spawn(async move {&#10;///         for i in 0..10 {&#10;///             if let Err(_) = tx.send(i).await {&#10;///                 println!(&quot;receiver dropped&quot;);&#10;///                 return;&#10;///             }&#10;///         }&#10;///     });&#10;///&#10;///     while let Some(i) = rx.recv().await {&#10;///         println!(&quot;got = {}&quot;, i);&#10;///     }&#10;/// }&#10;/// ```&#10;#[track_caller]&#10;pub fn channel&lt;T&gt;(buffer: usize) -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {&#10;    assert!(buffer &gt; 0, &quot;mpsc bounded channel requires buffer &gt; 0&quot;);&#10;    let semaphore = Semaphore {&#10;        semaphore: semaphore::Semaphore::new(buffer),&#10;        bound: buffer,&#10;    };&#10;    let (tx, rx) = chan::channel(semaphore);&#10;&#10;    let tx = Sender::new(tx);&#10;    let rx = Receiver::new(rx);&#10;&#10;    (tx, rx)&#10;}&#10;&#10;/// Channel semaphore is a tuple of the semaphore implementation and a `usize`&#10;/// representing the channel bound.&#10;#[derive(Debug)]&#10;pub(crate) struct Semaphore {&#10;    pub(crate) semaphore: semaphore::Semaphore,&#10;    pub(crate) bound: usize,&#10;}&#10;&#10;impl&lt;T&gt; Receiver&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Rx&lt;T, Semaphore&gt;) -&gt; Receiver&lt;T&gt; {&#10;        Receiver { chan }&#10;    }&#10;&#10;    /// Receives the next value for this receiver.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will sleep until a message is sent or&#10;    /// the channel is closed.  Note that if [`close`] is called, but there are&#10;    /// still outstanding [`Permits`] from before it was closed, the channel is&#10;    /// not considered closed by `recv` until the permits are released.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(None, rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// Values are buffered:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     tx.send(&quot;world&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(Some(&quot;world&quot;), rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv(cx)).await&#10;    }&#10;&#10;    /// Receives the next values for this receiver and extends `buffer`.&#10;    ///&#10;    /// This method extends `buffer` by no more than a fixed number of values&#10;    /// as specified by `limit`. If `limit` is zero, the function immediately&#10;    /// returns `0`. The return value is the number of values added to `buffer`.&#10;    ///&#10;    /// For `limit &gt; 0`, if there are no messages in the channel's queue, but&#10;    /// the channel has not yet been closed, this method will sleep until a&#10;    /// message is sent or the channel is closed. Note that if [`close`] is&#10;    /// called, but there are still outstanding [`Permits`] from before it was&#10;    /// closed, the channel is not considered closed by `recv_many` until the&#10;    /// permits are released.&#10;    ///&#10;    /// For non-zero values of `limit`, this method will never return `0` unless&#10;    /// the channel has been closed and there are no remaining messages in the&#10;    /// channel's queue. This indicates that no further values can ever be&#10;    /// received from this `Receiver`. The channel is closed when all senders&#10;    /// have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// The capacity of `buffer` is increased as needed.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv_many` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let mut buffer: Vec&lt;&amp;str&gt; = Vec::with_capacity(2);&#10;    ///     let limit = 2;&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///     let tx2 = tx.clone();&#10;    ///     tx2.send(&quot;first&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;second&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;third&quot;).await.unwrap();&#10;    ///&#10;    ///     // Call `recv_many` to receive up to `limit` (2) values.&#10;    ///     assert_eq!(2, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;], buffer);&#10;    ///&#10;    ///     // If the buffer is full, the next call to `recv_many`&#10;    ///     // reserves additional capacity.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;fourth&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     // 'tx' is dropped, but `recv_many`&#10;    ///     // is guaranteed not to return 0 as the channel&#10;    ///     // is not yet closed.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    ///&#10;    ///     // Once the last sender is dropped, the channel is&#10;    ///     // closed and `recv_many` returns 0, capacity unchanged.&#10;    ///     drop(tx2);&#10;    ///     assert_eq!(0, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv_many(cx, buffer, limit)).await&#10;    }&#10;&#10;    /// Tries to receive the next value for this receiver.&#10;    ///&#10;    /// This method returns the [`Empty`] error if the channel is currently&#10;    /// empty, but there are still outstanding [senders] or [permits].&#10;    ///&#10;    /// This method returns the [`Disconnected`] error if the channel is&#10;    /// currently empty, and there are no outstanding [senders] or [permits].&#10;    ///&#10;    /// Unlike the [`poll_recv`] method, this method will never return an&#10;    /// [`Empty`] error spuriously.&#10;    ///&#10;    /// [`Empty`]: crate::sync::mpsc::error::TryRecvError::Empty&#10;    /// [`Disconnected`]: crate::sync::mpsc::error::TryRecvError::Disconnected&#10;    /// [`poll_recv`]: Self::poll_recv&#10;    /// [senders]: crate::sync::mpsc::Sender&#10;    /// [permits]: crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::sync::mpsc::error::TryRecvError;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Empty), rx.try_recv());&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     // Drop the last sender, closing the channel.&#10;    ///     drop(tx);&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Disconnected), rx.try_recv());&#10;    /// }&#10;    /// ```&#10;    pub fn try_recv(&amp;mut self) -&gt; Result&lt;T, TryRecvError&gt; {&#10;        self.chan.try_recv()&#10;    }&#10;&#10;    /// Blocking receive to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will block until a message is sent or&#10;    /// the channel is closed.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// asynchronous code to synchronous code, and will work even if the sender&#10;    /// is not using [`blocking_send`] to send the message.&#10;    ///&#10;    /// Note that if [`close`] is called, but there are still outstanding&#10;    /// [`Permits`] from before it was closed, the channel is not considered&#10;    /// closed by `blocking_recv` until the permits are released.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    /// [`blocking_send`]: fn@crate::sync::mpsc::Sender::blocking_send&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(10);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         assert_eq!(Some(10), rx.blocking_recv());&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new()&#10;    ///         .unwrap()&#10;    ///         .block_on(async move {&#10;    ///             let _ = tx.send(10).await;&#10;    ///         });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_blocking&quot;))]&#10;    pub fn blocking_recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        crate::future::block_on(self.recv())&#10;    }&#10;&#10;    /// Variant of [`Self::recv_many`] for blocking contexts.&#10;    ///&#10;    /// The same conditions as in [`Self::blocking_recv`] apply.&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_many_blocking&quot;))]&#10;    pub fn blocking_recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        crate::future::block_on(self.recv_many(buffer, limit))&#10;    }&#10;&#10;    /// Closes the receiving half of a channel without dropping it.&#10;    ///&#10;    /// This prevents any further messages from being sent on the channel while&#10;    /// still enabling the receiver to drain messages that are buffered. Any&#10;    /// outstanding [`Permit`] values will still be able to send messages.&#10;    ///&#10;    /// To guarantee that no messages are dropped, after calling `close()`,&#10;    /// `recv()` must be called until `None` is returned. If there are&#10;    /// outstanding [`Permit`] or [`OwnedPermit`] values, the `recv` method will&#10;    /// not return `None` until those are released.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(20);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         let mut i = 0;&#10;    ///         while let Ok(permit) = tx.reserve().await {&#10;    ///             permit.send(i);&#10;    ///             i += 1;&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     while let Some(msg) = rx.recv().await {&#10;    ///         println!(&quot;got {}&quot;, msg);&#10;    ///     }&#10;    ///&#10;    ///     // Channel closed and no messages are lost.&#10;    /// }&#10;    /// ```&#10;    pub fn close(&amp;mut self) {&#10;        self.chan.close();&#10;    }&#10;&#10;    /// Checks if a channel is closed.&#10;    ///&#10;    /// This method returns `true` if the channel has been closed. The channel is closed&#10;    /// when all [`Sender`] have been dropped, or when [`Receiver::close`] is called.&#10;    ///&#10;    /// [`Sender`]: crate::sync::mpsc::Sender&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (_tx, mut rx) = mpsc::channel::&lt;()&gt;(10);&#10;    ///     assert!(!rx.is_closed());&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     assert!(rx.is_closed());&#10;    /// }&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Checks if a channel is empty.&#10;    ///&#10;    /// This method returns `true` if the channel has no messages.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert!(rx.is_empty());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert!(!rx.is_empty());&#10;    /// }&#10;    ///&#10;    /// ```&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.chan.is_empty()&#10;    }&#10;&#10;    /// Returns the number of messages in the channel.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert_eq!(0, rx.len());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert_eq!(1, rx.len());&#10;    /// }&#10;    /// ```&#10;    pub fn len(&amp;self) -&gt; usize {&#10;        self.chan.len()&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when the sender sends a value by calling [`Sender::send`] or by reserving&#10;    /// capacity with [`Sender::reserve`]. The capacity goes up when values are received.&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Directly sending a message drops the capacity by one.&#10;    ///     tx.send(()).await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///&#10;    ///     // Receiving the message increases the capacity by one.&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the value&#10;    /// returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Polls to receive the next message on this channel.&#10;    ///&#10;    /// This method returns:&#10;    ///&#10;    ///  * `Poll::Pending` if no messages are available but the channel is not&#10;    ///    closed, or if a spurious failure happens.&#10;    ///  * `Poll::Ready(Some(message))` if a message is available.&#10;    ///  * `Poll::Ready(None)` if the channel has been closed and all messages&#10;    ///    sent before it was closed have been received.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// If this method returns `Poll::Pending` due to a spurious failure, then&#10;    /// the `Waker` will be notified when the situation causing the spurious&#10;    /// failure has been resolved. Note that receiving such a wakeup does not&#10;    /// guarantee that the next call will succeed — it could fail with another&#10;    /// spurious failure.&#10;    pub fn poll_recv(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;T&gt;&gt; {&#10;        self.chan.recv(cx)&#10;    }&#10;&#10;    /// Polls to receive multiple messages on this channel, extending the provided buffer.&#10;    ///&#10;    /// This method returns:&#10;    /// * `Poll::Pending` if no messages are available but the channel is not closed, or if a&#10;    ///   spurious failure happens.&#10;    /// * `Poll::Ready(count)` where `count` is the number of messages successfully received and&#10;    ///   stored in `buffer`. This can be less than, or equal to, `limit`.&#10;    /// * `Poll::Ready(0)` if `limit` is set to zero or when the channel is closed.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// Note that this method does not guarantee that exactly `limit` messages&#10;    /// are received. Rather, if at least one message is available, it returns&#10;    /// as many messages as it can up to the given limit. This method returns&#10;    /// zero only if the channel is closed (or if `limit` is zero).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::task::{Context, Poll};&#10;    /// use std::pin::Pin;&#10;    /// use tokio::sync::mpsc;&#10;    /// use futures::Future;&#10;    ///&#10;    /// struct MyReceiverFuture&lt;'a&gt; {&#10;    ///     receiver: mpsc::Receiver&lt;i32&gt;,&#10;    ///     buffer: &amp;'a mut Vec&lt;i32&gt;,&#10;    ///     limit: usize,&#10;    /// }&#10;    ///&#10;    /// impl&lt;'a&gt; Future for MyReceiverFuture&lt;'a&gt; {&#10;    ///     type Output = usize; // Number of messages received&#10;    ///&#10;    ///     fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {&#10;    ///         let MyReceiverFuture { receiver, buffer, limit } = &amp;mut *self;&#10;    ///&#10;    ///         // Now `receiver` and `buffer` are mutable references, and `limit` is copied&#10;    ///         match receiver.poll_recv_many(cx, *buffer, *limit) {&#10;    ///             Poll::Pending =&gt; Poll::Pending,&#10;    ///             Poll::Ready(count) =&gt; Poll::Ready(count),&#10;    ///         }&#10;    ///     }&#10;    /// }&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(32);&#10;    ///     let mut buffer = Vec::new();&#10;    ///&#10;    ///     let my_receiver_future = MyReceiverFuture {&#10;    ///         receiver: rx,&#10;    ///         buffer: &amp;mut buffer,&#10;    ///         limit: 3,&#10;    ///     };&#10;    ///&#10;    ///     for i in 0..10 {&#10;    ///         tx.send(i).await.unwrap();&#10;    ///     }&#10;    ///&#10;    ///     let count = my_receiver_future.await;&#10;    ///     assert_eq!(count, 3);&#10;    ///     assert_eq!(buffer, vec![0,1,2])&#10;    /// }&#10;    /// ```&#10;    pub fn poll_recv_many(&#10;        &amp;mut self,&#10;        cx: &amp;mut Context&lt;'_&gt;,&#10;        buffer: &amp;mut Vec&lt;T&gt;,&#10;        limit: usize,&#10;    ) -&gt; Poll&lt;usize&gt; {&#10;        self.chan.recv_many(cx, buffer, limit)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn sender_strong_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn sender_weak_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Receiver&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Receiver&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Unpin for Receiver&lt;T&gt; {}&#10;&#10;impl&lt;T&gt; Sender&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Tx&lt;T, Semaphore&gt;) -&gt; Sender&lt;T&gt; {&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity.&#10;    ///&#10;    /// A successful send occurs when it is determined that the other end of the&#10;    /// channel has not hung up already. An unsuccessful send would be one where&#10;    /// the corresponding receiver has already been closed. Note that a return&#10;    /// value of `Err` means that the data will never be received, but a return&#10;    /// value of `Ok` does not mean that the data will be received. It is&#10;    /// possible for the corresponding receiver to hang up immediately after&#10;    /// this function returns `Ok`.&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// If `send` is used as the event in a [`tokio::select!`](crate::select)&#10;    /// statement and some other branch completes first, then it is guaranteed&#10;    /// that the message was not sent. **However, in that case, the message&#10;    /// is dropped and will be lost.**&#10;    ///&#10;    /// To avoid losing messages, use [`reserve`](Self::reserve) to reserve&#10;    /// capacity, then use the returned [`Permit`] to send the message.&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `send` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send` will block until the&#10;    /// previously sent value was received.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(_) = tx.send(i).await {&#10;    ///                 println!(&quot;receiver dropped&quot;);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub async fn send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        match self.reserve().await {&#10;            Ok(permit) =&gt; {&#10;                permit.send(value);&#10;                Ok(())&#10;            }&#10;            Err(_) =&gt; Err(SendError(value)),&#10;        }&#10;    }&#10;&#10;    /// Completes when the receiver has dropped.&#10;    ///&#10;    /// This allows the producers to get notified when interest in the produced&#10;    /// values is canceled and immediately stop doing work.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. Once the channel is closed, it stays closed&#10;    /// forever and all future calls to `closed` will return immediately.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx1, rx) = mpsc::channel::&lt;()&gt;(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///     let tx3 = tx1.clone();&#10;    ///     let tx4 = tx1.clone();&#10;    ///     let tx5 = tx1.clone();&#10;    ///     tokio::spawn(async move {&#10;    ///         drop(rx);&#10;    ///     });&#10;    ///&#10;    ///     futures::join!(&#10;    ///         tx1.closed(),&#10;    ///         tx2.closed(),&#10;    ///         tx3.closed(),&#10;    ///         tx4.closed(),&#10;    ///         tx5.closed()&#10;    ///     );&#10;    ///     println!(&quot;Receiver dropped&quot;);&#10;    /// }&#10;    /// ```&#10;    pub async fn closed(&amp;self) {&#10;        self.chan.closed().await;&#10;    }&#10;&#10;    /// Attempts to immediately send a message on this `Sender`&#10;    ///&#10;    /// This method differs from [`send`] by returning immediately if the channel's&#10;    /// buffer is full or no receiver is waiting to acquire some data. Compared&#10;    /// with [`send`], this function has two failure cases instead of one (one for&#10;    /// disconnection, one for a full buffer).&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the channel capacity has been reached, i.e., the channel has `n`&#10;    /// buffered values where `n` is the argument passed to [`channel`], then an&#10;    /// error is returned.&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`channel`]: channel&#10;    /// [`close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     // Create a channel with buffer size 1&#10;    ///     let (tx1, mut rx) = mpsc::channel(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx1.send(1).await.unwrap();&#10;    ///         tx1.send(2).await.unwrap();&#10;    ///         // task waits until the receiver receives a value.&#10;    ///     });&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         // This will return an error and send&#10;    ///         // no message if the buffer is full&#10;    ///         let _ = tx2.try_send(3);&#10;    ///     });&#10;    ///&#10;    ///     let mut msg;&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     // Third message may have never been sent&#10;    ///     match rx.recv().await {&#10;    ///         Some(msg) =&gt; println!(&quot;message {} received&quot;, msg),&#10;    ///         None =&gt; println!(&quot;the third message was never sent&quot;),&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub fn try_send(&amp;self, message: T) -&gt; Result&lt;(), TrySendError&lt;T&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(message)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(message)),&#10;        }&#10;&#10;        // Send the message&#10;        self.chan.send(message);&#10;        Ok(())&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity, but only for a limited time.&#10;    ///&#10;    /// Shares the same success and error conditions as [`send`], adding one more&#10;    /// condition for an unsuccessful send, which is when the provided timeout has&#10;    /// elapsed, and there is no capacity available.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] having been dropped,&#10;    /// the function returns an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if it is called outside the context of a Tokio&#10;    /// runtime [with time enabled](crate::runtime::Builder::enable_time).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send_timeout` will block until the&#10;    /// previously sent value was received, unless the timeout has elapsed.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::time::{sleep, Duration};&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(e) = tx.send_timeout(i, Duration::from_millis(100)).await {&#10;    ///                 println!(&quot;send error: #{:?}&quot;, e);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///         sleep(Duration::from_millis(200)).await;&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    #[cfg(feature = &quot;time&quot;)]&#10;    #[cfg_attr(docsrs, doc(cfg(feature = &quot;time&quot;)))]&#10;    pub async fn send_timeout(&#10;        &amp;self,&#10;        value: T,&#10;        timeout: Duration,&#10;    ) -&gt; Result&lt;(), SendTimeoutError&lt;T&gt;&gt; {&#10;        let permit = match crate::time::timeout(timeout, self.reserve()).await {&#10;            Err(_) =&gt; {&#10;                return Err(SendTimeoutError::Timeout(value));&#10;            }&#10;            Ok(Err(_)) =&gt; {&#10;                return Err(SendTimeoutError::Closed(value));&#10;            }&#10;            Ok(Ok(permit)) =&gt; permit,&#10;        };&#10;&#10;        permit.send(value);&#10;        Ok(())&#10;    }&#10;&#10;    /// Blocking send to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// synchronous code to asynchronous code, and will work even if the&#10;    /// receiver is not using [`blocking_recv`] to receive the message.&#10;    ///&#10;    /// [`blocking_recv`]: fn@crate::sync::mpsc::Receiver::blocking_recv&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(1);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         tx.blocking_send(10).unwrap();&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new().unwrap().block_on(async move {&#10;    ///         assert_eq!(Some(10), rx.recv().await);&#10;    ///     });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;send_blocking&quot;))]&#10;    pub fn blocking_send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        crate::future::block_on(self.send(value))&#10;    }&#10;&#10;    /// Checks if the channel has been closed. This happens when the&#10;    /// [`Receiver`] is dropped, or when the [`Receiver::close`] method is&#10;    /// called.&#10;    ///&#10;    /// [`Receiver`]: crate::sync::mpsc::Receiver&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(42);&#10;    /// assert!(!tx.is_closed());&#10;    ///&#10;    /// let tx2 = tx.clone();&#10;    /// assert!(!tx2.is_closed());&#10;    ///&#10;    /// drop(rx);&#10;    /// assert!(tx.is_closed());&#10;    /// assert!(tx2.is_closed());&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send one message is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. A [`Permit`] is returned to track&#10;    /// the reserved capacity. The [`send`] function on [`Permit`] consumes the&#10;    /// reserved capacity.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send `n` messages is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full or if there are fewer than `n` permits available, the function waits&#10;    /// for the number of unreceived messages to become `n` less than the channel capacity.&#10;    /// Capacity to send `n` message is then reserved for the caller.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`try_reserve_many`] except it awaits for the slots to become available.&#10;    ///&#10;    /// If the channel is closed, the function returns a [`SendError`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`try_reserve_many`]: Sender::try_reserve_many&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve_many`&#10;    /// complete in the order they were requested. Cancelling a call to&#10;    /// `reserve_many` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.reserve_many(2).await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(n).await?;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Waits for channel capacity, moving the `Sender` and returning an owned&#10;    /// permit. Once capacity to send one message is available, it is reserved&#10;    /// for the caller.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime. `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `reserve_owned`.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. An [`OwnedPermit`] is returned to&#10;    /// track the reserved capacity. The [`send`] function on [`OwnedPermit`]&#10;    /// consumes the reserved capacity.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the&#10;    /// capacity back to the channel.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve_owned` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    /// Sending a message using an [`OwnedPermit`]:&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity, moving the sender.&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message, consuming the permit and returning&#10;    ///     // the moved sender.&#10;    ///     let tx = permit.send(123);&#10;    ///&#10;    ///     // The value sent on the permit is received.&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 123);&#10;    ///&#10;    ///     // The sender can now be used again.&#10;    ///     tx.send(456).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// When multiple [`OwnedPermit`]s are needed, or the sender cannot be moved&#10;    /// by value, it can be inexpensively cloned before calling `reserve_owned`:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity.&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds.&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender::reserve`]: Sender::reserve&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    pub async fn reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    async fn reserve_inner(&amp;self, n: usize) -&gt; Result&lt;(), SendError&lt;()&gt;&gt; {&#10;        crate::trace::async_trace_leaf().await;&#10;&#10;        if n &gt; self.max_capacity() {&#10;            return Err(SendError(()));&#10;        }&#10;        match self.chan.semaphore().semaphore.acquire(n).await {&#10;            Ok(()) =&gt; Ok(()),&#10;            Err(_) =&gt; Err(SendError(())),&#10;        }&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// If the channel is full this function will return [`TrySendError`], otherwise&#10;    /// if there is a slot available it will return a [`Permit`] that will then allow you&#10;    /// to [`send`] on the channel with a guaranteed slot. This function is similar to&#10;    /// [`reserve`] except it does not await for the slot to become available.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve`]: Sender::reserve&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.try_reserve().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Tries to acquire `n` slots in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`reserve_many`] except it does not await for the slots to become available.&#10;    ///&#10;    /// If there are fewer than `n` permits available on the channel, then&#10;    /// this function will return a [`TrySendError::Full`]. If the channel is closed&#10;    /// this function will return a [`TrySendError::Closed`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve_many`]: Sender::reserve_many&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.try_reserve_many(2).unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    ///&#10;    ///     // Trying to call try_reserve_many with 0 will return an empty iterator&#10;    ///     let mut permit = tx.try_reserve_many(0).unwrap();&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // Trying to call try_reserve_many with a number greater than the channel&#10;    ///     // capacity will return an error&#10;    ///     let permit = tx.try_reserve_many(3);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     // Trying to call try_reserve_many on a closed channel will return an error&#10;    ///     drop(rx);&#10;    ///     let permit = tx.try_reserve_many(1);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     let permit = tx.try_reserve_many(0);&#10;    ///     assert!(permit.is_err());&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        if n &gt; self.max_capacity() {&#10;            return Err(TrySendError::Full(()));&#10;        }&#10;&#10;        match self.chan.semaphore().semaphore.try_acquire(n) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available, returning an owned permit.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::try_reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime.  `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `try_reserve_owned`.&#10;    ///&#10;    /// If the channel is full this function will return a [`TrySendError`].&#10;    /// Since the sender is taken by value, the `TrySendError` returned in this&#10;    /// case contains the sender, so that it may be used again. Otherwise, if&#10;    /// there is a slot available, this method will return an [`OwnedPermit`]&#10;    /// that can then be used to [`send`] on the channel with a guaranteed slot.&#10;    /// This function is similar to  [`reserve_owned`] except it does not await&#10;    /// for the slot to become available.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`reserve_owned`]: Sender::reserve_owned&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.clone().try_reserve_owned().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, TrySendError&lt;Self&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(self)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(self)),&#10;        }&#10;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    /// Returns `true` if senders belong to the same channel.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// let  tx2 = tx.clone();&#10;    /// assert!(tx.same_channel(&amp;tx2));&#10;    ///&#10;    /// let (tx3, rx3) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// assert!(!tx3.same_channel(&amp;tx2));&#10;    /// ```&#10;    pub fn same_channel(&amp;self, other: &amp;Self) -&gt; bool {&#10;        self.chan.same_channel(&amp;other.chan)&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when sending a value by calling [`send`] or by reserving capacity&#10;    /// with [`reserve`]. The capacity goes up when values are received by the [`Receiver`].&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`]&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`reserve`]: Sender::reserve&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Converts the `Sender` to a [`WeakSender`] that does not count&#10;    /// towards RAII semantics, i.e. if all `Sender` instances of the&#10;    /// channel were dropped and only `WeakSender` instances remain,&#10;    /// the channel is closed.&#10;    #[must_use = &quot;Downgrade creates a WeakSender without destroying the original non-weak sender.&quot;]&#10;    pub fn downgrade(&amp;self) -&gt; WeakSender&lt;T&gt; {&#10;        WeakSender {&#10;            chan: self.chan.downgrade(),&#10;        }&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the&#10;    /// value returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, _rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    /// [`capacity`]: Sender::capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for Sender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        Sender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Sender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Sender&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for WeakSender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        self.chan.increment_weak_count();&#10;&#10;        WeakSender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for WeakSender&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        self.chan.decrement_weak_count();&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; WeakSender&lt;T&gt; {&#10;    /// Tries to convert a `WeakSender` into a [`Sender`]. This will return `Some`&#10;    /// if there are other `Sender` instances alive and the channel wasn't&#10;    /// previously dropped, otherwise `None` is returned.&#10;    pub fn upgrade(&amp;self) -&gt; Option&lt;Sender&lt;T&gt;&gt; {&#10;        chan::Tx::upgrade(self.chan.clone()).map(Sender::new)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for WeakSender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;WeakSender&quot;).finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; Permit&lt;'_, T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Send a message on the permit&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub fn send(self, value: T) {&#10;        use std::mem;&#10;&#10;        self.chan.send(value);&#10;&#10;        // Avoid the drop logic&#10;        mem::forget(self);&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for Permit&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the permit back to the semaphore&#10;        semaphore.add_permit();&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Permit&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Permit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl PermitIterator =====&#10;&#10;impl&lt;'a, T&gt; Iterator for PermitIterator&lt;'a, T&gt; {&#10;    type Item = Permit&lt;'a, T&gt;;&#10;&#10;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {&#10;        if self.n == 0 {&#10;            return None;&#10;        }&#10;&#10;        self.n -= 1;&#10;        Some(Permit { chan: self.chan })&#10;    }&#10;&#10;    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {&#10;        let n = self.n;&#10;        (n, Some(n))&#10;    }&#10;}&#10;impl&lt;T&gt; ExactSizeIterator for PermitIterator&lt;'_, T&gt; {}&#10;impl&lt;T&gt; std::iter::FusedIterator for PermitIterator&lt;'_, T&gt; {}&#10;&#10;impl&lt;T&gt; Drop for PermitIterator&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        if self.n == 0 {&#10;            return;&#10;        }&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the remaining permits back to the semaphore&#10;        semaphore.add_permits(self.n);&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for PermitIterator&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;PermitIterator&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .field(&quot;capacity&quot;, &amp;self.n)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; OwnedPermit&lt;T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// Unlike [`Permit::send`], this method returns the [`Sender`] from which&#10;    /// the `OwnedPermit` was reserved.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message on the permit, returning the sender.&#10;    ///     let tx = permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    pub fn send(mut self, value: T) -&gt; Sender&lt;T&gt; {&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;        chan.send(value);&#10;&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Releases the reserved capacity *without* sending a message, returning the&#10;    /// [`Sender`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send on the original `tx` will fail, since the `permit`&#10;    ///     // has reserved all the available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Release the permit without sending a message, returning the clone&#10;    ///     // of the sender.&#10;    ///     let tx2 = permit.release();&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    ///     # drop(rx); drop(tx2);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender`]: Sender&#10;    pub fn release(mut self) -&gt; Sender&lt;T&gt; {&#10;        use chan::Semaphore;&#10;&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;&#10;        // Add the permit back to the semaphore&#10;        chan.semaphore().add_permit();&#10;        Sender { chan }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for OwnedPermit&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        // Are we still holding onto the sender?&#10;        if let Some(chan) = self.chan.take() {&#10;            let semaphore = chan.semaphore();&#10;&#10;            // Add the permit back to the semaphore&#10;            semaphore.add_permit();&#10;&#10;            // If this `OwnedPermit` is holding the last sender for this&#10;            // channel, wake the receiver so that it can be notified that the&#10;            // channel is closed.&#10;            if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;                chan.wake_rx();&#10;            }&#10;        }&#10;&#10;        // Otherwise, do nothing.&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for OwnedPermit&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;OwnedPermit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979f0a46417cc598f2ef0ffa127768" />
                <option name="question" value="翻译到中文" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1750719964243" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750715950947" />
          <option name="id" value="01979ecd675d7cc598f2bbba20fb4e1d" />
          <option name="title" value="当tx变量的所有权移动到FnMut的闭包中后，如果闭包调用了多次，会不会导致在第一次调用后关闭唯一的tx，导致后续无法使用tx发送数据，变量的所有权在FnMut闭包中的行为是如何的？" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;在Ifhg中，闭包捕获变量的所有权行为取决于闭包的类型（`Um`、`UmNfg`、`UmLmxv`）以及如何捕获变量（通过移动或借用）。在这个例子中，闭包使用了`nlev`关键字，所以它会获取所捕获变量的所有权。这意味着`gc`的所有权被移动到闭包中，闭包只能被调用一次（如果它是`UmLmxv`）或者多次（如果它是`UmNfg`或`Um`）。&#10;&#10;然而，这里的关键是`gc`的类型。`gc`是一个`Hvmwvi`（或类似的东西）的实例，通常来自通道。在标准库的`hgw::hbmx::nkhx`中，`Hvmwvi`是可以被克隆的，但在这个代码中，我们使用的是`xszmmvo`函数，它返回一个`(Hvmwvi, Ivxvrevi)`。但是，请注意，代码中使用的`xszmmvo`函数可能来自`glprl`或`xilhhyvzn`等库，因为标准库的`nkhx::xszmmvo`没有`gib_ivhviev_nzmb`方法。这里我们假设是`glprl::hbmx::nkhx`通道，因为`gib_ivhviev_nzmb`是`glprl`的`nkhx`通道中的方法。&#10;&#10;在`glprl::hbmx::nkhx`中，`Hvmwvi`可以被克隆，但在这个闭包中，我们只捕获了一个`gc`（没有克隆）。然而，闭包被设计为多次调用（因为它是音频输入流的回调，每次有数据时都会调用）。所以，如果`gc`在第一次调用后就被消耗（即所有权被移动出闭包），那么第二次调用就会出错。&#10;&#10;但是，观察闭包内部的代码，我们并没有将`gc`的所有权移出闭包。我们只是调用`gc.gib_ivhviev_nzmb`，这个方法需要`&amp;hvou`，即不可变引用。所以，它不会消耗`gc`，只是借用它。因此，闭包可以多次调用。&#10;&#10;然而，这里有一个重要的点：闭包的类型。因为闭包只使用了`&amp;gc`（通过`gib_ivhviev_nzmb`），所以它实际上只需要不可变借用，因此它满足`Um`特征，而不是`UmNfg`或`UmLmxv`。但是，由于我们使用了`nlev`，它移动了`gc`的所有权到闭包中，但之后每次调用闭包时，我们只是不可变借用`gc`，所以没有问题。&#10;&#10;但是，让我们仔细看一下`gib_ivhviev_nzmb`的签名（以`glprl::hbmx::nkhx::Hvmwvi`为例）：&#10;```ifhg&#10;kfy um gib_ivhviev_nzmb(&amp;hvou, zwwrgrlmzo: fhrav) -&gt; Ivhfog&lt;KvinrgNzmb&lt;'_, G&gt;, GibHvmwViili&lt;()&gt;&gt;&#10;```&#10;它接受`&amp;hvou`，所以不会消耗`Hvmwvi`，只是借用。&#10;&#10;因此，闭包可以多次调用，因为每次调用都只是不可变借用`gc`，而`gc`的所有权在闭包内部，且闭包本身是`Um`，所以可以多次调用。&#10;&#10;但是，这里还有一个问题：当通道被关闭时（例如，接收端被丢弃），`gib_ivhviev_nzmb`会返回错误。在代码中，我们打印了错误然后返回，但并没有关闭`gc`。所以，后续的调用还会继续尝试发送，但都会失败。&#10;&#10;总结：闭包会多次调用，每次调用都使用同一个`gc`（通过不可变引用）来尝试发送数据。所以，不会出现第一次调用后`gc`被关闭的情况（除非通道的接收端被关闭，但那是另一回事）。&#10;&#10;另外，关于闭包的类型：由于闭包没有修改任何捕获的变量（它只是不可变借用`gc`），所以它满足`Um`特征，因此可以被多次调用。&#10;&#10;因此，代码是安全的，不会出现第一次调用后无法使用`gc`的情况。&#10;&#10;&lt;/gsrmp&gt;&#10;&#10;在 Ifhg 中，`UmNfg` 闭包可以多次调用，且不会导致捕获变量的所有权被消耗。在您提供的代码中，`gc` 的所有权被移动到闭包中，但闭包内部的操作不会消耗 `gc`，因此可以安全地多次调用。&#10;&#10;### 关键点解析：&#10;&#10;8. **闭包类型**：&#10;   - `nlev |...| { ... }` 表示闭包获取捕获变量（`gc`）的所有权&#10;   - 但闭包实现了 `UmNfg` gizrg，因此可以多次调用&#10;   - 每次调用时闭包内部使用 `&amp;hvou` 方法（`gib_ivhviev_nzmb()`），不会消耗 `gc`&#10;&#10;7. **通道发送器行为**：&#10;   ```ifhg&#10;   gc.gib_ivhviev_nzmb(yfuuvi.ovm())  // 使用 &amp;hvou 方法&#10;   ```&#10;   - `gib_ivhviev_nzmb()` 方法通过不可变引用操作发送器（`&amp;hvou`）&#10;   - 不会消耗 `gc`，只是借用它&#10;   - 返回的 `Kvinrg` 对象用于实际发送数据&#10;&#10;6. **所有权保持**：&#10;   - 闭包每次调用时：&#10;     * 重新借用 `gc`（通过 `gib_ivhviev_nzmb()`）&#10;     * 使用 `Kvinrg` 发送数据&#10;   - `gc` 的所有权始终保留在闭包环境中&#10;   - 不会被消耗或丢弃&#10;&#10;### 生命周期说明：&#10;```nvinzrw&#10;tizks GW&#10;    Z[创建闭包] --&gt; Y[移动 gc 所有权到闭包]&#10;    Y --&gt; X[首次调用]&#10;    X --&gt; W[借用 gc 发送数据]&#10;    W --&gt; V[保持 gc 所有权]&#10;    V --&gt; U[下次调用]&#10;    U --&gt; W&#10;```&#10;&#10;### 可能的问题场景：&#10;只有当闭包尝试移动 `gc` 的所有权时才会出现问题，例如：&#10;```ifhg&#10;// ❌ 错误示例：消耗了 gc&#10;nlev |yfuuvi, _| {&#10;    ovg _xlmhfnvw = gc;  // 移动所有权&#10;    // 后续调用会失败！&#10;}&#10;```&#10;&#10;但在您的代码中，**没有这样的操作**，因此可以安全地多次调用。&#10;&#10;### 总结：&#10;您的代码是安全的，因为：&#10;8. `UmNfg` 闭包支持多次调用&#10;7. `gib_ivhviev_nzmb()` 通过不可变引用操作发送器&#10;6. 实际发送使用 `Kvinrg` 对象而非直接移动 `gc`&#10;5. `gc` 的所有权始终保留在闭包环境中&#10;&#10;闭包可以安全地被音频系统多次调用（每次音频缓冲区就绪时），不会出现第一次调用后发送器失效的情况。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    um xivzgv_hgivzn(&#10;        wverxv: &amp;Wverxv,&#10;        hgivzn_xlmurt: &amp;HgivznXlmurt,&#10;    ) -&gt; Ivhfog&lt;(Ivxvrevi&lt;u67&gt;, Hgivzn), LkvizgrlmViili&gt; {&#10;        ovg yfuuvi_hrav = nzgxs hgivzn_xlmurt.yfuuvi_hrav {&#10;            YfuuviHrav::Wvuzfog =&gt; 1807,&#10;            YfuuviHrav::Urcvw(hrav) =&gt; hrav zh _,&#10;        };&#10;        ovg (gc, ic) = xszmmvo(yfuuvi_hrav);&#10;&#10;        Lp((&#10;            ic,&#10;            wverxv.yfrow_rmkfg_hgivzn(&#10;                hgivzn_xlmurt,&#10;                nlev |yfuuvi: &amp;[u67], _| {&#10;                    ovg rgvi = nzgxs gc.gib_ivhviev_nzmb(yfuuvi.ovm()) {&#10;                        Vii(v) =&gt; {&#10;                            vkirmgom!(&quot;ZfwrlXloovxgli xzm'g hvmw wzgz: {}&quot;, v);&#10;                            ivgfim;&#10;                        }&#10;                        Lp(k) =&gt; k,&#10;                    };&#10;                    ovg nfg rgvi = rgvi.vmfnvizgv();&#10;                    dsrov ovg Hlnv((r, kvinrg)) = rgvi.mvcg() {&#10;                        kvinrg.hvmw(yfuuvi[r]);&#10;                    }&#10;                },&#10;                |v| vkirmgom!(&quot;{}&quot;, v),&#10;                Mlmv,&#10;            )?,&#10;        ))&#10;    }&#10;" />
                      <option name="end_line" value="58" />
                      <option name="filename" value="collector.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="5" />
                              <option name="line" value="58" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="27" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="27" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979ecd675d7cc598f2bbba20fb4e1d" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" value="use {&#10;    crate::OperationError,&#10;    rodio::{&#10;        buffer::SamplesBuffer,&#10;        cpal::{&#10;            BufferSize, Device, HostId, Stream, StreamConfig, SupportedStreamConfig, default_host,&#10;            traits::{DeviceTrait, HostTrait, StreamTrait},&#10;        },&#10;        source::UniformSourceIterator,&#10;    },&#10;    std::{&#10;        fmt::{Debug, Error as FmtError, Formatter, Result as FmtResult},&#10;        mem::replace,&#10;    },&#10;    tokio::sync::mpsc::{Receiver, channel},&#10;};&#10;&#10;pub struct AudioCollector {&#10;    device: Device,&#10;    host_id: HostId,&#10;    receiver: Receiver&lt;f32&gt;,&#10;    stream_config: StreamConfig,&#10;    supported_stream_config: SupportedStreamConfig,&#10;    stream: Stream,&#10;}&#10;&#10;impl AudioCollector {&#10;    fn create_stream(&#10;        device: &amp;Device,&#10;        stream_config: &amp;StreamConfig,&#10;    ) -&gt; Result&lt;(Receiver&lt;f32&gt;, Stream), OperationError&gt; {&#10;        let buffer_size = match stream_config.buffer_size {&#10;            BufferSize::Default =&gt; 8192,&#10;            BufferSize::Fixed(size) =&gt; size as _,&#10;        };&#10;        let (tx, rx) = channel(buffer_size);&#10;&#10;        Ok((&#10;            rx,&#10;            device.build_input_stream(&#10;                stream_config,&#10;                move |buffer: &amp;[f32], _| {&#10;                    let iter = match tx.try_reserve_many(buffer.len()) {&#10;                        Err(e) =&gt; {&#10;                            eprintln!(&quot;AudioCollector can't send data: {}&quot;, e);&#10;                            return;&#10;                        }&#10;                        Ok(p) =&gt; p,&#10;                    };&#10;                    let mut iter = iter.enumerate();&#10;                    while let Some((i, permit)) = iter.next() {&#10;                        permit.send(buffer[i]);&#10;                    }&#10;                },&#10;                |e| eprintln!(&quot;{}&quot;, e),&#10;                None,&#10;            )?,&#10;        ))&#10;    }&#10;&#10;    fn update_stream(&amp;mut self) -&gt; Result&lt;(), OperationError&gt; {&#10;        let (receiver, stream) = Self::create_stream(&amp;self.device, &amp;self.stream_config)?;&#10;        drop(replace(&amp;mut self.stream, stream));&#10;        drop(replace(&amp;mut self.receiver, receiver));&#10;&#10;        Ok(())&#10;    }&#10;&#10;    pub fn new() -&gt; Result&lt;Self, OperationError&gt; {&#10;        let host = default_host();&#10;        let host_id = host.id();&#10;        let device = host.default_input_device().ok_or(OperationError::NoDevice(&#10;            &quot;No default audio input device.&quot;.to_owned(),&#10;        ))?;&#10;        let supported_stream_config = device.default_input_config()?;&#10;        let stream_config = supported_stream_config.config();&#10;        let (receiver, stream) = Self::create_stream(&amp;device, &amp;stream_config)?;&#10;&#10;        Ok(Self {&#10;            device,&#10;            host_id,&#10;            receiver,&#10;            stream_config,&#10;            supported_stream_config,&#10;            stream,&#10;        })&#10;    }&#10;&#10;    /// 获取音频输入设备名称&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;String, OperationError&gt;`，成功时包含设备名称字符串&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::DeviceError`，当获取设备名称失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let name = collector.get_name()?;&#10;    /// ```&#10;    pub fn get_name(&amp;self) -&gt; Result&lt;String, OperationError&gt; {&#10;        Ok(self.device.name()?)&#10;    }&#10;&#10;    /// 获取支持的音频流通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_supported_stream_channels();&#10;    /// ```&#10;    pub fn get_supported_stream_channels(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.channels() as _&#10;    }&#10;&#10;    /// 获取支持的音频流采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_supported_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_supported_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.sample_rate().0 as _&#10;    }&#10;&#10;    /// 设置音频流通道数&#10;    ///&#10;    /// # 参数&#10;    /// - `channels`: 要设置的通道数(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_channels(2)?;&#10;    /// ```&#10;    pub fn set_stream_channels(&amp;mut self, channels: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.channels = channels as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 设置音频流采样率&#10;    ///&#10;    /// # 参数&#10;    /// - `sample_rate`: 要设置的采样率(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_sample_rate(32000)?;&#10;    /// ```&#10;    pub fn set_stream_sample_rate(&amp;mut self, sample_rate: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.sample_rate.0 = sample_rate as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 获取当前音频流的通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_stream_channels();&#10;    /// ```&#10;    pub fn get_stream_channels(&amp;self) -&gt; usize {&#10;        self.stream_config.channels as _&#10;    }&#10;&#10;    /// 获取当前音频流的采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.stream_config.sample_rate.0 as _&#10;    }&#10;&#10;    /// 开始采集或恢复暂停的音频&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已开始&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当启动采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.collect()?;&#10;    /// ```&#10;    pub fn collect(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.play()?)&#10;    }&#10;&#10;    /// 暂停采集音频(可使用`collect()`恢复）&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已暂停&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当暂停采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.pause()?;&#10;    /// ```&#10;    pub fn pause(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.pause()?)&#10;    }&#10;&#10;    pub async fn read&lt;const SR: usize&gt;(&amp;mut self, length: usize, channels: usize) -&gt; Vec&lt;f32&gt; {&#10;        let stream_length = (length / channels) * self.get_stream_sample_rate() / SR;&#10;        let capacity = stream_length * self.get_stream_channels();&#10;        let mut buffer = Vec::with_capacity(capacity);&#10;        let read = self.receiver.recv_many(&amp;mut buffer, capacity).await;&#10;        if self.get_stream_channels() != channels || self.get_stream_sample_rate() != SR {&#10;            let buffer = SamplesBuffer::new(&#10;                self.get_stream_channels() as _,&#10;                self.get_stream_sample_rate() as _,&#10;                &amp;buffer[..read],&#10;            );&#10;            UniformSourceIterator::new(buffer, channels as _, SR as _).collect()&#10;        } else {&#10;            buffer&#10;        }&#10;    }&#10;&#10;    pub fn close(&amp;mut self) {&#10;        self.receiver.close()&#10;    }&#10;}&#10;&#10;impl Debug for AudioCollector {&#10;    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; FmtResult {&#10;        write!(&#10;            f,&#10;            &quot;AudioCollector({}, {})&quot;,&#10;            self.host_id.name(),&#10;            self.get_name().map_err(|_| FmtError)?&#10;        )&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979ecdef427cc598f2c6c1c08c5996" />
                <option name="question" value="当gc变量的所有权移动到UmNfg的闭包中后，如果闭包调用了多次，会不会导致在第一次调用后关闭唯一的gc，导致后续无法使用gc发送数据，变量的所有权在UmNfg闭包中的行为是如何的？" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1750716031116" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750714678987" />
          <option name="id" value="01979eb9febc7cc598f29dd4dde023a3" />
          <option name="title" value="翻译到中文" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="在Ifhg中，`gib_ivhviev_nzmb`函数用于尝试在通道中预留`m`个槽位，而无需等待槽位变得可用。如果通道中没有足够的可用槽位，该函数将返回一个`GibHvmwViili::Ufoo`错误；如果通道已关闭，则返回一个`GibHvmwViili::Xolhvw`错误。&#10;&#10;### 函数说明&#10;&#10;- **`gib_ivhviev_nzmb`**：尝试在通道中预留`m`个槽位，不等待槽位可用。&#10;- **返回值**：返回一个`KvinrgRgvizgli`，用于跟踪预留的容量。&#10;- **错误处理**：&#10;  - 如果通道已满，返回`GibHvmwViili::Ufoo`。&#10;  - 如果通道已关闭，返回`GibHvmwViili::Xolhvw`。&#10;&#10;### 示例代码&#10;&#10;```ifhg&#10;fhv glprl::hbmx::nkhx;&#10;&#10;#[glprl::nzrm]&#10;zhbmx um nzrm() {&#10;    ovg (gc, nfg ic) = nkhx::xszmmvo(7);&#10;&#10;    // 预留容量&#10;    ovg nfg kvinrg = gc.gib_ivhviev_nzmb(7).fmdizk();&#10;&#10;    // 尝试直接发送会因没有可用容量而失败&#10;    zhhvig!(gc.gib_hvmw(876).rh_vii());&#10;&#10;    // 尝试预留额外的槽位也会因没有容量而失败&#10;    zhhvig!(gc.gib_ivhviev().rh_vii());&#10;&#10;    // 使用kvinrg迭代器发送消息成功&#10;    kvinrg.mvcg().fmdizk().hvmw(543);&#10;    kvinrg.mvcg().fmdizk().hvmw(542);&#10;&#10;    // 迭代器现在应该已耗尽&#10;    zhhvig!(kvinrg.mvcg().rh_mlmv());&#10;&#10;    // 接收到kvinrg上发送的值&#10;    zhhvig_vj!(ic.ivxe().zdzrg.fmdizk(), 543);&#10;    zhhvig_vj!(ic.ivxe().zdzrg.fmdizk(), 542);&#10;&#10;    // 尝试调用gib_ivhviev_nzmb预留9个槽位将返回一个空迭代器&#10;    ovg nfg kvinrg = gc.gib_ivhviev_nzmb(9).fmdizk();&#10;    zhhvig!(kvinrg.mvcg().rh_mlmv());&#10;&#10;    // 尝试调用gib_ivhviev_nzmb预留的数量大于通道容量将返回错误&#10;    ovg kvinrg = gc.gib_ivhviev_nzmb(6);&#10;    zhhvig!(kvinrg.rh_vii());&#10;&#10;    // 尝试在已关闭的通道上调用gib_ivhviev_nzmb将返回错误&#10;    wilk(ic);&#10;    ovg kvinrg = gc.gib_ivhviev_nzmb(8);&#10;    zhhvig!(kvinrg.rh_vii());&#10;&#10;    ovg kvinrg = gc.gib_ivhviev_nzmb(9);&#10;    zhhvig!(kvinrg.rh_vii());&#10;}&#10;```&#10;&#10;### 额外信息&#10;&#10;- **通道（Xszmmvo）**：Ifhg中的通道是一种用于在不同线程间传递信息的通信机制，它实现了线程间的消息传递。&#10;- **错误处理**：Ifhg的通道通信模型通过所有权和类型系统保证内存安全，避免了数据竞争和悬空指针等问题。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list />
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979eb9febc7cc598f29dd4dde023a3" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" value="use crate::loom::sync::Arc;&#10;use crate::sync::batch_semaphore::{self as semaphore, TryAcquireError};&#10;use crate::sync::mpsc::chan;&#10;use crate::sync::mpsc::error::{SendError, TryRecvError, TrySendError};&#10;&#10;cfg_time! {&#10;    use crate::sync::mpsc::error::SendTimeoutError;&#10;    use crate::time::Duration;&#10;}&#10;&#10;use std::fmt;&#10;use std::task::{Context, Poll};&#10;&#10;/// Sends values to the associated `Receiver`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// To convert the `Sender` into a `Sink` or use it in a poll function, you can&#10;/// use the [`PollSender`] utility.&#10;///&#10;/// [`PollSender`]: https://docs.rs/tokio-util/latest/tokio_util/sync/struct.PollSender.html&#10;pub struct Sender&lt;T&gt; {&#10;    chan: chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// A sender that does not prevent the channel from being closed.&#10;///&#10;/// If all [`Sender`] instances of a channel were dropped and only `WeakSender`&#10;/// instances remain, the channel is closed.&#10;///&#10;/// In order to send messages, the `WeakSender` needs to be upgraded using&#10;/// [`WeakSender::upgrade`], which returns `Option&lt;Sender&gt;`. It returns `None`&#10;/// if all `Sender`s have been dropped, and otherwise it returns a `Sender`.&#10;///&#10;/// [`Sender`]: Sender&#10;/// [`WeakSender::upgrade`]: WeakSender::upgrade&#10;///&#10;/// # Examples&#10;///&#10;/// ```&#10;/// use tokio::sync::mpsc::channel;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, _rx) = channel::&lt;i32&gt;(15);&#10;///     let tx_weak = tx.downgrade();&#10;///&#10;///     // Upgrading will succeed because `tx` still exists.&#10;///     assert!(tx_weak.upgrade().is_some());&#10;///&#10;///     // If we drop `tx`, then it will fail.&#10;///     drop(tx);&#10;///     assert!(tx_weak.clone().upgrade().is_none());&#10;/// }&#10;/// ```&#10;pub struct WeakSender&lt;T&gt; {&#10;    chan: Arc&lt;chan::Chan&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Permits to send one value into the channel.&#10;///&#10;/// `Permit` values are returned by [`Sender::reserve()`] and [`Sender::try_reserve()`]&#10;/// and are used to guarantee channel capacity before generating a message to send.&#10;///&#10;/// [`Sender::reserve()`]: Sender::reserve&#10;/// [`Sender::try_reserve()`]: Sender::try_reserve&#10;pub struct Permit&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// An [`Iterator`] of [`Permit`] that can be used to hold `n` slots in the channel.&#10;///&#10;/// `PermitIterator` values are returned by [`Sender::reserve_many()`] and [`Sender::try_reserve_many()`]&#10;/// and are used to guarantee channel capacity before generating `n` messages to send.&#10;///&#10;/// [`Sender::reserve_many()`]: Sender::reserve_many&#10;/// [`Sender::try_reserve_many()`]: Sender::try_reserve_many&#10;pub struct PermitIterator&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;    n: usize,&#10;}&#10;&#10;/// Owned permit to send one value into the channel.&#10;///&#10;/// This is identical to the [`Permit`] type, except that it moves the sender&#10;/// rather than borrowing it.&#10;///&#10;/// `OwnedPermit` values are returned by [`Sender::reserve_owned()`] and&#10;/// [`Sender::try_reserve_owned()`] and are used to guarantee channel capacity&#10;/// before generating a message to send.&#10;///&#10;/// [`Permit`]: Permit&#10;/// [`Sender::reserve_owned()`]: Sender::reserve_owned&#10;/// [`Sender::try_reserve_owned()`]: Sender::try_reserve_owned&#10;pub struct OwnedPermit&lt;T&gt; {&#10;    chan: Option&lt;chan::Tx&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Receives values from the associated `Sender`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// This receiver can be turned into a `Stream` using [`ReceiverStream`].&#10;///&#10;/// [`ReceiverStream`]: https://docs.rs/tokio-stream/0.1/tokio_stream/wrappers/struct.ReceiverStream.html&#10;pub struct Receiver&lt;T&gt; {&#10;    /// The channel receiver.&#10;    chan: chan::Rx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// Creates a bounded mpsc channel for communicating between asynchronous tasks&#10;/// with backpressure.&#10;///&#10;/// The channel will buffer up to the provided number of messages.  Once the&#10;/// buffer is full, attempts to send new messages will wait until a message is&#10;/// received from the channel. The provided buffer capacity must be at least 1.&#10;///&#10;/// All data sent on `Sender` will become available on `Receiver` in the same&#10;/// order as it was sent.&#10;///&#10;/// The `Sender` can be cloned to `send` to the same channel from multiple code&#10;/// locations. Only one `Receiver` is supported.&#10;///&#10;/// If the `Receiver` is disconnected while trying to `send`, the `send` method&#10;/// will return a `SendError`. Similarly, if `Sender` is disconnected while&#10;/// trying to `recv`, the `recv` method will return `None`.&#10;///&#10;/// # Panics&#10;///&#10;/// Panics if the buffer capacity is 0.&#10;///&#10;/// # Examples&#10;///&#10;/// ```rust&#10;/// use tokio::sync::mpsc;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, mut rx) = mpsc::channel(100);&#10;///&#10;///     tokio::spawn(async move {&#10;///         for i in 0..10 {&#10;///             if let Err(_) = tx.send(i).await {&#10;///                 println!(&quot;receiver dropped&quot;);&#10;///                 return;&#10;///             }&#10;///         }&#10;///     });&#10;///&#10;///     while let Some(i) = rx.recv().await {&#10;///         println!(&quot;got = {}&quot;, i);&#10;///     }&#10;/// }&#10;/// ```&#10;#[track_caller]&#10;pub fn channel&lt;T&gt;(buffer: usize) -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {&#10;    assert!(buffer &gt; 0, &quot;mpsc bounded channel requires buffer &gt; 0&quot;);&#10;    let semaphore = Semaphore {&#10;        semaphore: semaphore::Semaphore::new(buffer),&#10;        bound: buffer,&#10;    };&#10;    let (tx, rx) = chan::channel(semaphore);&#10;&#10;    let tx = Sender::new(tx);&#10;    let rx = Receiver::new(rx);&#10;&#10;    (tx, rx)&#10;}&#10;&#10;/// Channel semaphore is a tuple of the semaphore implementation and a `usize`&#10;/// representing the channel bound.&#10;#[derive(Debug)]&#10;pub(crate) struct Semaphore {&#10;    pub(crate) semaphore: semaphore::Semaphore,&#10;    pub(crate) bound: usize,&#10;}&#10;&#10;impl&lt;T&gt; Receiver&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Rx&lt;T, Semaphore&gt;) -&gt; Receiver&lt;T&gt; {&#10;        Receiver { chan }&#10;    }&#10;&#10;    /// Receives the next value for this receiver.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will sleep until a message is sent or&#10;    /// the channel is closed.  Note that if [`close`] is called, but there are&#10;    /// still outstanding [`Permits`] from before it was closed, the channel is&#10;    /// not considered closed by `recv` until the permits are released.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(None, rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// Values are buffered:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     tx.send(&quot;world&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(Some(&quot;world&quot;), rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv(cx)).await&#10;    }&#10;&#10;    /// Receives the next values for this receiver and extends `buffer`.&#10;    ///&#10;    /// This method extends `buffer` by no more than a fixed number of values&#10;    /// as specified by `limit`. If `limit` is zero, the function immediately&#10;    /// returns `0`. The return value is the number of values added to `buffer`.&#10;    ///&#10;    /// For `limit &gt; 0`, if there are no messages in the channel's queue, but&#10;    /// the channel has not yet been closed, this method will sleep until a&#10;    /// message is sent or the channel is closed. Note that if [`close`] is&#10;    /// called, but there are still outstanding [`Permits`] from before it was&#10;    /// closed, the channel is not considered closed by `recv_many` until the&#10;    /// permits are released.&#10;    ///&#10;    /// For non-zero values of `limit`, this method will never return `0` unless&#10;    /// the channel has been closed and there are no remaining messages in the&#10;    /// channel's queue. This indicates that no further values can ever be&#10;    /// received from this `Receiver`. The channel is closed when all senders&#10;    /// have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// The capacity of `buffer` is increased as needed.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv_many` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let mut buffer: Vec&lt;&amp;str&gt; = Vec::with_capacity(2);&#10;    ///     let limit = 2;&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///     let tx2 = tx.clone();&#10;    ///     tx2.send(&quot;first&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;second&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;third&quot;).await.unwrap();&#10;    ///&#10;    ///     // Call `recv_many` to receive up to `limit` (2) values.&#10;    ///     assert_eq!(2, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;], buffer);&#10;    ///&#10;    ///     // If the buffer is full, the next call to `recv_many`&#10;    ///     // reserves additional capacity.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;fourth&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     // 'tx' is dropped, but `recv_many`&#10;    ///     // is guaranteed not to return 0 as the channel&#10;    ///     // is not yet closed.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    ///&#10;    ///     // Once the last sender is dropped, the channel is&#10;    ///     // closed and `recv_many` returns 0, capacity unchanged.&#10;    ///     drop(tx2);&#10;    ///     assert_eq!(0, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv_many(cx, buffer, limit)).await&#10;    }&#10;&#10;    /// Tries to receive the next value for this receiver.&#10;    ///&#10;    /// This method returns the [`Empty`] error if the channel is currently&#10;    /// empty, but there are still outstanding [senders] or [permits].&#10;    ///&#10;    /// This method returns the [`Disconnected`] error if the channel is&#10;    /// currently empty, and there are no outstanding [senders] or [permits].&#10;    ///&#10;    /// Unlike the [`poll_recv`] method, this method will never return an&#10;    /// [`Empty`] error spuriously.&#10;    ///&#10;    /// [`Empty`]: crate::sync::mpsc::error::TryRecvError::Empty&#10;    /// [`Disconnected`]: crate::sync::mpsc::error::TryRecvError::Disconnected&#10;    /// [`poll_recv`]: Self::poll_recv&#10;    /// [senders]: crate::sync::mpsc::Sender&#10;    /// [permits]: crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::sync::mpsc::error::TryRecvError;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Empty), rx.try_recv());&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     // Drop the last sender, closing the channel.&#10;    ///     drop(tx);&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Disconnected), rx.try_recv());&#10;    /// }&#10;    /// ```&#10;    pub fn try_recv(&amp;mut self) -&gt; Result&lt;T, TryRecvError&gt; {&#10;        self.chan.try_recv()&#10;    }&#10;&#10;    /// Blocking receive to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will block until a message is sent or&#10;    /// the channel is closed.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// asynchronous code to synchronous code, and will work even if the sender&#10;    /// is not using [`blocking_send`] to send the message.&#10;    ///&#10;    /// Note that if [`close`] is called, but there are still outstanding&#10;    /// [`Permits`] from before it was closed, the channel is not considered&#10;    /// closed by `blocking_recv` until the permits are released.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    /// [`blocking_send`]: fn@crate::sync::mpsc::Sender::blocking_send&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(10);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         assert_eq!(Some(10), rx.blocking_recv());&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new()&#10;    ///         .unwrap()&#10;    ///         .block_on(async move {&#10;    ///             let _ = tx.send(10).await;&#10;    ///         });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_blocking&quot;))]&#10;    pub fn blocking_recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        crate::future::block_on(self.recv())&#10;    }&#10;&#10;    /// Variant of [`Self::recv_many`] for blocking contexts.&#10;    ///&#10;    /// The same conditions as in [`Self::blocking_recv`] apply.&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_many_blocking&quot;))]&#10;    pub fn blocking_recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        crate::future::block_on(self.recv_many(buffer, limit))&#10;    }&#10;&#10;    /// Closes the receiving half of a channel without dropping it.&#10;    ///&#10;    /// This prevents any further messages from being sent on the channel while&#10;    /// still enabling the receiver to drain messages that are buffered. Any&#10;    /// outstanding [`Permit`] values will still be able to send messages.&#10;    ///&#10;    /// To guarantee that no messages are dropped, after calling `close()`,&#10;    /// `recv()` must be called until `None` is returned. If there are&#10;    /// outstanding [`Permit`] or [`OwnedPermit`] values, the `recv` method will&#10;    /// not return `None` until those are released.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(20);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         let mut i = 0;&#10;    ///         while let Ok(permit) = tx.reserve().await {&#10;    ///             permit.send(i);&#10;    ///             i += 1;&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     while let Some(msg) = rx.recv().await {&#10;    ///         println!(&quot;got {}&quot;, msg);&#10;    ///     }&#10;    ///&#10;    ///     // Channel closed and no messages are lost.&#10;    /// }&#10;    /// ```&#10;    pub fn close(&amp;mut self) {&#10;        self.chan.close();&#10;    }&#10;&#10;    /// Checks if a channel is closed.&#10;    ///&#10;    /// This method returns `true` if the channel has been closed. The channel is closed&#10;    /// when all [`Sender`] have been dropped, or when [`Receiver::close`] is called.&#10;    ///&#10;    /// [`Sender`]: crate::sync::mpsc::Sender&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (_tx, mut rx) = mpsc::channel::&lt;()&gt;(10);&#10;    ///     assert!(!rx.is_closed());&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     assert!(rx.is_closed());&#10;    /// }&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Checks if a channel is empty.&#10;    ///&#10;    /// This method returns `true` if the channel has no messages.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert!(rx.is_empty());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert!(!rx.is_empty());&#10;    /// }&#10;    ///&#10;    /// ```&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.chan.is_empty()&#10;    }&#10;&#10;    /// Returns the number of messages in the channel.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert_eq!(0, rx.len());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert_eq!(1, rx.len());&#10;    /// }&#10;    /// ```&#10;    pub fn len(&amp;self) -&gt; usize {&#10;        self.chan.len()&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when the sender sends a value by calling [`Sender::send`] or by reserving&#10;    /// capacity with [`Sender::reserve`]. The capacity goes up when values are received.&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Directly sending a message drops the capacity by one.&#10;    ///     tx.send(()).await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///&#10;    ///     // Receiving the message increases the capacity by one.&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the value&#10;    /// returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Polls to receive the next message on this channel.&#10;    ///&#10;    /// This method returns:&#10;    ///&#10;    ///  * `Poll::Pending` if no messages are available but the channel is not&#10;    ///    closed, or if a spurious failure happens.&#10;    ///  * `Poll::Ready(Some(message))` if a message is available.&#10;    ///  * `Poll::Ready(None)` if the channel has been closed and all messages&#10;    ///    sent before it was closed have been received.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// If this method returns `Poll::Pending` due to a spurious failure, then&#10;    /// the `Waker` will be notified when the situation causing the spurious&#10;    /// failure has been resolved. Note that receiving such a wakeup does not&#10;    /// guarantee that the next call will succeed — it could fail with another&#10;    /// spurious failure.&#10;    pub fn poll_recv(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;T&gt;&gt; {&#10;        self.chan.recv(cx)&#10;    }&#10;&#10;    /// Polls to receive multiple messages on this channel, extending the provided buffer.&#10;    ///&#10;    /// This method returns:&#10;    /// * `Poll::Pending` if no messages are available but the channel is not closed, or if a&#10;    ///   spurious failure happens.&#10;    /// * `Poll::Ready(count)` where `count` is the number of messages successfully received and&#10;    ///   stored in `buffer`. This can be less than, or equal to, `limit`.&#10;    /// * `Poll::Ready(0)` if `limit` is set to zero or when the channel is closed.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// Note that this method does not guarantee that exactly `limit` messages&#10;    /// are received. Rather, if at least one message is available, it returns&#10;    /// as many messages as it can up to the given limit. This method returns&#10;    /// zero only if the channel is closed (or if `limit` is zero).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::task::{Context, Poll};&#10;    /// use std::pin::Pin;&#10;    /// use tokio::sync::mpsc;&#10;    /// use futures::Future;&#10;    ///&#10;    /// struct MyReceiverFuture&lt;'a&gt; {&#10;    ///     receiver: mpsc::Receiver&lt;i32&gt;,&#10;    ///     buffer: &amp;'a mut Vec&lt;i32&gt;,&#10;    ///     limit: usize,&#10;    /// }&#10;    ///&#10;    /// impl&lt;'a&gt; Future for MyReceiverFuture&lt;'a&gt; {&#10;    ///     type Output = usize; // Number of messages received&#10;    ///&#10;    ///     fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {&#10;    ///         let MyReceiverFuture { receiver, buffer, limit } = &amp;mut *self;&#10;    ///&#10;    ///         // Now `receiver` and `buffer` are mutable references, and `limit` is copied&#10;    ///         match receiver.poll_recv_many(cx, *buffer, *limit) {&#10;    ///             Poll::Pending =&gt; Poll::Pending,&#10;    ///             Poll::Ready(count) =&gt; Poll::Ready(count),&#10;    ///         }&#10;    ///     }&#10;    /// }&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(32);&#10;    ///     let mut buffer = Vec::new();&#10;    ///&#10;    ///     let my_receiver_future = MyReceiverFuture {&#10;    ///         receiver: rx,&#10;    ///         buffer: &amp;mut buffer,&#10;    ///         limit: 3,&#10;    ///     };&#10;    ///&#10;    ///     for i in 0..10 {&#10;    ///         tx.send(i).await.unwrap();&#10;    ///     }&#10;    ///&#10;    ///     let count = my_receiver_future.await;&#10;    ///     assert_eq!(count, 3);&#10;    ///     assert_eq!(buffer, vec![0,1,2])&#10;    /// }&#10;    /// ```&#10;    pub fn poll_recv_many(&#10;        &amp;mut self,&#10;        cx: &amp;mut Context&lt;'_&gt;,&#10;        buffer: &amp;mut Vec&lt;T&gt;,&#10;        limit: usize,&#10;    ) -&gt; Poll&lt;usize&gt; {&#10;        self.chan.recv_many(cx, buffer, limit)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn sender_strong_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn sender_weak_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Receiver&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Receiver&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Unpin for Receiver&lt;T&gt; {}&#10;&#10;impl&lt;T&gt; Sender&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Tx&lt;T, Semaphore&gt;) -&gt; Sender&lt;T&gt; {&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity.&#10;    ///&#10;    /// A successful send occurs when it is determined that the other end of the&#10;    /// channel has not hung up already. An unsuccessful send would be one where&#10;    /// the corresponding receiver has already been closed. Note that a return&#10;    /// value of `Err` means that the data will never be received, but a return&#10;    /// value of `Ok` does not mean that the data will be received. It is&#10;    /// possible for the corresponding receiver to hang up immediately after&#10;    /// this function returns `Ok`.&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// If `send` is used as the event in a [`tokio::select!`](crate::select)&#10;    /// statement and some other branch completes first, then it is guaranteed&#10;    /// that the message was not sent. **However, in that case, the message&#10;    /// is dropped and will be lost.**&#10;    ///&#10;    /// To avoid losing messages, use [`reserve`](Self::reserve) to reserve&#10;    /// capacity, then use the returned [`Permit`] to send the message.&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `send` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send` will block until the&#10;    /// previously sent value was received.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(_) = tx.send(i).await {&#10;    ///                 println!(&quot;receiver dropped&quot;);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub async fn send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        match self.reserve().await {&#10;            Ok(permit) =&gt; {&#10;                permit.send(value);&#10;                Ok(())&#10;            }&#10;            Err(_) =&gt; Err(SendError(value)),&#10;        }&#10;    }&#10;&#10;    /// Completes when the receiver has dropped.&#10;    ///&#10;    /// This allows the producers to get notified when interest in the produced&#10;    /// values is canceled and immediately stop doing work.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. Once the channel is closed, it stays closed&#10;    /// forever and all future calls to `closed` will return immediately.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx1, rx) = mpsc::channel::&lt;()&gt;(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///     let tx3 = tx1.clone();&#10;    ///     let tx4 = tx1.clone();&#10;    ///     let tx5 = tx1.clone();&#10;    ///     tokio::spawn(async move {&#10;    ///         drop(rx);&#10;    ///     });&#10;    ///&#10;    ///     futures::join!(&#10;    ///         tx1.closed(),&#10;    ///         tx2.closed(),&#10;    ///         tx3.closed(),&#10;    ///         tx4.closed(),&#10;    ///         tx5.closed()&#10;    ///     );&#10;    ///     println!(&quot;Receiver dropped&quot;);&#10;    /// }&#10;    /// ```&#10;    pub async fn closed(&amp;self) {&#10;        self.chan.closed().await;&#10;    }&#10;&#10;    /// Attempts to immediately send a message on this `Sender`&#10;    ///&#10;    /// This method differs from [`send`] by returning immediately if the channel's&#10;    /// buffer is full or no receiver is waiting to acquire some data. Compared&#10;    /// with [`send`], this function has two failure cases instead of one (one for&#10;    /// disconnection, one for a full buffer).&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the channel capacity has been reached, i.e., the channel has `n`&#10;    /// buffered values where `n` is the argument passed to [`channel`], then an&#10;    /// error is returned.&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`channel`]: channel&#10;    /// [`close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     // Create a channel with buffer size 1&#10;    ///     let (tx1, mut rx) = mpsc::channel(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx1.send(1).await.unwrap();&#10;    ///         tx1.send(2).await.unwrap();&#10;    ///         // task waits until the receiver receives a value.&#10;    ///     });&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         // This will return an error and send&#10;    ///         // no message if the buffer is full&#10;    ///         let _ = tx2.try_send(3);&#10;    ///     });&#10;    ///&#10;    ///     let mut msg;&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     // Third message may have never been sent&#10;    ///     match rx.recv().await {&#10;    ///         Some(msg) =&gt; println!(&quot;message {} received&quot;, msg),&#10;    ///         None =&gt; println!(&quot;the third message was never sent&quot;),&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub fn try_send(&amp;self, message: T) -&gt; Result&lt;(), TrySendError&lt;T&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(message)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(message)),&#10;        }&#10;&#10;        // Send the message&#10;        self.chan.send(message);&#10;        Ok(())&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity, but only for a limited time.&#10;    ///&#10;    /// Shares the same success and error conditions as [`send`], adding one more&#10;    /// condition for an unsuccessful send, which is when the provided timeout has&#10;    /// elapsed, and there is no capacity available.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] having been dropped,&#10;    /// the function returns an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if it is called outside the context of a Tokio&#10;    /// runtime [with time enabled](crate::runtime::Builder::enable_time).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send_timeout` will block until the&#10;    /// previously sent value was received, unless the timeout has elapsed.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::time::{sleep, Duration};&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(e) = tx.send_timeout(i, Duration::from_millis(100)).await {&#10;    ///                 println!(&quot;send error: #{:?}&quot;, e);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///         sleep(Duration::from_millis(200)).await;&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    #[cfg(feature = &quot;time&quot;)]&#10;    #[cfg_attr(docsrs, doc(cfg(feature = &quot;time&quot;)))]&#10;    pub async fn send_timeout(&#10;        &amp;self,&#10;        value: T,&#10;        timeout: Duration,&#10;    ) -&gt; Result&lt;(), SendTimeoutError&lt;T&gt;&gt; {&#10;        let permit = match crate::time::timeout(timeout, self.reserve()).await {&#10;            Err(_) =&gt; {&#10;                return Err(SendTimeoutError::Timeout(value));&#10;            }&#10;            Ok(Err(_)) =&gt; {&#10;                return Err(SendTimeoutError::Closed(value));&#10;            }&#10;            Ok(Ok(permit)) =&gt; permit,&#10;        };&#10;&#10;        permit.send(value);&#10;        Ok(())&#10;    }&#10;&#10;    /// Blocking send to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// synchronous code to asynchronous code, and will work even if the&#10;    /// receiver is not using [`blocking_recv`] to receive the message.&#10;    ///&#10;    /// [`blocking_recv`]: fn@crate::sync::mpsc::Receiver::blocking_recv&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(1);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         tx.blocking_send(10).unwrap();&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new().unwrap().block_on(async move {&#10;    ///         assert_eq!(Some(10), rx.recv().await);&#10;    ///     });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;send_blocking&quot;))]&#10;    pub fn blocking_send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        crate::future::block_on(self.send(value))&#10;    }&#10;&#10;    /// Checks if the channel has been closed. This happens when the&#10;    /// [`Receiver`] is dropped, or when the [`Receiver::close`] method is&#10;    /// called.&#10;    ///&#10;    /// [`Receiver`]: crate::sync::mpsc::Receiver&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(42);&#10;    /// assert!(!tx.is_closed());&#10;    ///&#10;    /// let tx2 = tx.clone();&#10;    /// assert!(!tx2.is_closed());&#10;    ///&#10;    /// drop(rx);&#10;    /// assert!(tx.is_closed());&#10;    /// assert!(tx2.is_closed());&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send one message is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. A [`Permit`] is returned to track&#10;    /// the reserved capacity. The [`send`] function on [`Permit`] consumes the&#10;    /// reserved capacity.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send `n` messages is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full or if there are fewer than `n` permits available, the function waits&#10;    /// for the number of unreceived messages to become `n` less than the channel capacity.&#10;    /// Capacity to send `n` message is then reserved for the caller.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`try_reserve_many`] except it awaits for the slots to become available.&#10;    ///&#10;    /// If the channel is closed, the function returns a [`SendError`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`try_reserve_many`]: Sender::try_reserve_many&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve_many`&#10;    /// complete in the order they were requested. Cancelling a call to&#10;    /// `reserve_many` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.reserve_many(2).await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(n).await?;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Waits for channel capacity, moving the `Sender` and returning an owned&#10;    /// permit. Once capacity to send one message is available, it is reserved&#10;    /// for the caller.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime. `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `reserve_owned`.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. An [`OwnedPermit`] is returned to&#10;    /// track the reserved capacity. The [`send`] function on [`OwnedPermit`]&#10;    /// consumes the reserved capacity.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the&#10;    /// capacity back to the channel.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve_owned` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    /// Sending a message using an [`OwnedPermit`]:&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity, moving the sender.&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message, consuming the permit and returning&#10;    ///     // the moved sender.&#10;    ///     let tx = permit.send(123);&#10;    ///&#10;    ///     // The value sent on the permit is received.&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 123);&#10;    ///&#10;    ///     // The sender can now be used again.&#10;    ///     tx.send(456).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// When multiple [`OwnedPermit`]s are needed, or the sender cannot be moved&#10;    /// by value, it can be inexpensively cloned before calling `reserve_owned`:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity.&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds.&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender::reserve`]: Sender::reserve&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    pub async fn reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    async fn reserve_inner(&amp;self, n: usize) -&gt; Result&lt;(), SendError&lt;()&gt;&gt; {&#10;        crate::trace::async_trace_leaf().await;&#10;&#10;        if n &gt; self.max_capacity() {&#10;            return Err(SendError(()));&#10;        }&#10;        match self.chan.semaphore().semaphore.acquire(n).await {&#10;            Ok(()) =&gt; Ok(()),&#10;            Err(_) =&gt; Err(SendError(())),&#10;        }&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// If the channel is full this function will return [`TrySendError`], otherwise&#10;    /// if there is a slot available it will return a [`Permit`] that will then allow you&#10;    /// to [`send`] on the channel with a guaranteed slot. This function is similar to&#10;    /// [`reserve`] except it does not await for the slot to become available.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve`]: Sender::reserve&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.try_reserve().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Tries to acquire `n` slots in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`reserve_many`] except it does not await for the slots to become available.&#10;    ///&#10;    /// If there are fewer than `n` permits available on the channel, then&#10;    /// this function will return a [`TrySendError::Full`]. If the channel is closed&#10;    /// this function will return a [`TrySendError::Closed`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve_many`]: Sender::reserve_many&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.try_reserve_many(2).unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    ///&#10;    ///     // Trying to call try_reserve_many with 0 will return an empty iterator&#10;    ///     let mut permit = tx.try_reserve_many(0).unwrap();&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // Trying to call try_reserve_many with a number greater than the channel&#10;    ///     // capacity will return an error&#10;    ///     let permit = tx.try_reserve_many(3);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     // Trying to call try_reserve_many on a closed channel will return an error&#10;    ///     drop(rx);&#10;    ///     let permit = tx.try_reserve_many(1);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     let permit = tx.try_reserve_many(0);&#10;    ///     assert!(permit.is_err());&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        if n &gt; self.max_capacity() {&#10;            return Err(TrySendError::Full(()));&#10;        }&#10;&#10;        match self.chan.semaphore().semaphore.try_acquire(n) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available, returning an owned permit.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::try_reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime.  `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `try_reserve_owned`.&#10;    ///&#10;    /// If the channel is full this function will return a [`TrySendError`].&#10;    /// Since the sender is taken by value, the `TrySendError` returned in this&#10;    /// case contains the sender, so that it may be used again. Otherwise, if&#10;    /// there is a slot available, this method will return an [`OwnedPermit`]&#10;    /// that can then be used to [`send`] on the channel with a guaranteed slot.&#10;    /// This function is similar to  [`reserve_owned`] except it does not await&#10;    /// for the slot to become available.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`reserve_owned`]: Sender::reserve_owned&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.clone().try_reserve_owned().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, TrySendError&lt;Self&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(self)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(self)),&#10;        }&#10;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    /// Returns `true` if senders belong to the same channel.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// let  tx2 = tx.clone();&#10;    /// assert!(tx.same_channel(&amp;tx2));&#10;    ///&#10;    /// let (tx3, rx3) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// assert!(!tx3.same_channel(&amp;tx2));&#10;    /// ```&#10;    pub fn same_channel(&amp;self, other: &amp;Self) -&gt; bool {&#10;        self.chan.same_channel(&amp;other.chan)&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when sending a value by calling [`send`] or by reserving capacity&#10;    /// with [`reserve`]. The capacity goes up when values are received by the [`Receiver`].&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`]&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`reserve`]: Sender::reserve&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Converts the `Sender` to a [`WeakSender`] that does not count&#10;    /// towards RAII semantics, i.e. if all `Sender` instances of the&#10;    /// channel were dropped and only `WeakSender` instances remain,&#10;    /// the channel is closed.&#10;    #[must_use = &quot;Downgrade creates a WeakSender without destroying the original non-weak sender.&quot;]&#10;    pub fn downgrade(&amp;self) -&gt; WeakSender&lt;T&gt; {&#10;        WeakSender {&#10;            chan: self.chan.downgrade(),&#10;        }&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the&#10;    /// value returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, _rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    /// [`capacity`]: Sender::capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for Sender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        Sender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Sender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Sender&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for WeakSender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        self.chan.increment_weak_count();&#10;&#10;        WeakSender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for WeakSender&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        self.chan.decrement_weak_count();&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; WeakSender&lt;T&gt; {&#10;    /// Tries to convert a `WeakSender` into a [`Sender`]. This will return `Some`&#10;    /// if there are other `Sender` instances alive and the channel wasn't&#10;    /// previously dropped, otherwise `None` is returned.&#10;    pub fn upgrade(&amp;self) -&gt; Option&lt;Sender&lt;T&gt;&gt; {&#10;        chan::Tx::upgrade(self.chan.clone()).map(Sender::new)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for WeakSender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;WeakSender&quot;).finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; Permit&lt;'_, T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Send a message on the permit&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub fn send(self, value: T) {&#10;        use std::mem;&#10;&#10;        self.chan.send(value);&#10;&#10;        // Avoid the drop logic&#10;        mem::forget(self);&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for Permit&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the permit back to the semaphore&#10;        semaphore.add_permit();&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Permit&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Permit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl PermitIterator =====&#10;&#10;impl&lt;'a, T&gt; Iterator for PermitIterator&lt;'a, T&gt; {&#10;    type Item = Permit&lt;'a, T&gt;;&#10;&#10;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {&#10;        if self.n == 0 {&#10;            return None;&#10;        }&#10;&#10;        self.n -= 1;&#10;        Some(Permit { chan: self.chan })&#10;    }&#10;&#10;    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {&#10;        let n = self.n;&#10;        (n, Some(n))&#10;    }&#10;}&#10;impl&lt;T&gt; ExactSizeIterator for PermitIterator&lt;'_, T&gt; {}&#10;impl&lt;T&gt; std::iter::FusedIterator for PermitIterator&lt;'_, T&gt; {}&#10;&#10;impl&lt;T&gt; Drop for PermitIterator&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        if self.n == 0 {&#10;            return;&#10;        }&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the remaining permits back to the semaphore&#10;        semaphore.add_permits(self.n);&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for PermitIterator&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;PermitIterator&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .field(&quot;capacity&quot;, &amp;self.n)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; OwnedPermit&lt;T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// Unlike [`Permit::send`], this method returns the [`Sender`] from which&#10;    /// the `OwnedPermit` was reserved.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message on the permit, returning the sender.&#10;    ///     let tx = permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    pub fn send(mut self, value: T) -&gt; Sender&lt;T&gt; {&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;        chan.send(value);&#10;&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Releases the reserved capacity *without* sending a message, returning the&#10;    /// [`Sender`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send on the original `tx` will fail, since the `permit`&#10;    ///     // has reserved all the available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Release the permit without sending a message, returning the clone&#10;    ///     // of the sender.&#10;    ///     let tx2 = permit.release();&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    ///     # drop(rx); drop(tx2);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender`]: Sender&#10;    pub fn release(mut self) -&gt; Sender&lt;T&gt; {&#10;        use chan::Semaphore;&#10;&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;&#10;        // Add the permit back to the semaphore&#10;        chan.semaphore().add_permit();&#10;        Sender { chan }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for OwnedPermit&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        // Are we still holding onto the sender?&#10;        if let Some(chan) = self.chan.take() {&#10;            let semaphore = chan.semaphore();&#10;&#10;            // Add the permit back to the semaphore&#10;            semaphore.add_permit();&#10;&#10;            // If this `OwnedPermit` is holding the last sender for this&#10;            // channel, wake the receiver so that it can be notified that the&#10;            // channel is closed.&#10;            if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;                chan.wake_rx();&#10;            }&#10;        }&#10;&#10;        // Otherwise, do nothing.&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for OwnedPermit&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;OwnedPermit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979eba44ae7cc598f2a26528d26920" />
                <option name="question" value="翻译到中文" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="```ifhg&#10;    /// 接收此接收器的下一个值并扩展`yfuuvi`。&#10;    ///&#10;    /// 此方法将`yfuuvi`扩展不超过`ornrg`指定的固定数量的值。如果`ornrg`为零，该函数立即返回`9`。返回值是添加到`yfuuvi`的值的数量。&#10;    ///&#10;    /// 对于`ornrg &gt; 9`，如果通道的队列中没有消息，但通道尚未关闭，此方法将等待直到发送消息或通道关闭。请注意，如果调用`xolhv`，但仍有未释放的`Kvinrgh`，则`ivxe_nzmb`认为通道未关闭，直到`Kvinrgh`被释放。&#10;    ///&#10;    /// 对于非零值的`ornrg`，除非通道已关闭且通道队列中没有剩余消息，否则此方法永远不会返回`9`。这表明无法再从该`Ivxvrevi`接收任何值。当所有发送者都已丢弃或调用`xolhv`时，通道关闭。&#10;    ///&#10;    /// `yfuuvi`的容量会按需增加。&#10;    ///&#10;    /// # 取消安全&#10;    ///&#10;    /// 此方法是取消安全的。如果`ivxe_nzmb`用作`glprl::hvovxg!`语句中的事件，并且某个其他分支首先完成，则保证未从该通道接收任何消息。&#10;    ///&#10;    /// [`xolhv`]: Hvou::xolhv&#10;    /// [`Kvinrgh`]: hgifxg@xizgv::hbmx::nkhx::Kvinrg&#10;    ///&#10;    /// # 示例&#10;    ///&#10;    /// ```&#10;    /// fhv glprl::hbmx::nkhx;&#10;    ///&#10;    /// #[glprl::nzrm]&#10;    /// zhbmx um nzrm() {&#10;    ///     ovg nfg yfuuvi: Evx&lt;&amp;hgi&gt; = Evx::drgs_xzkzxrgb(7);&#10;    ///     ovg ornrg = 7;&#10;    ///     ovg (gc, nfg ic) = nkhx::xszmmvo(899);&#10;    ///     ovg gc7 = gc.xolmv();&#10;    ///     gc7.hvmw(&quot;urihg&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;hvxlmw&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;gsriw&quot;).zdzrg.fmdizk();&#10;    ///&#10;    ///     // 调用`ivxe_nzmb`接收最多`ornrg`（7）个值。&#10;    ///     zhhvig_vj!(7, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;], yfuuvi);&#10;    ///&#10;    ///     // 如果缓冲区已满，下一次调用`ivxe_nzmb`&#10;    ///     // 预留额外的容量。&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///&#10;    ///     glprl::hkzdm(zhbmx nlev {&#10;    ///         gc.hvmw(&quot;ulfigs&quot;).zdzrg.fmdizk();&#10;    ///     });&#10;    ///&#10;    ///     // 'gc'被丢弃，但`ivxe_nzmb`&#10;    ///     // 保证不会返回9，因为通道&#10;    ///     //尚未关闭。&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    ///&#10;    ///     // 一旦最后一个发送者被丢弃，通道就&#10;    ///     // 关闭，`ivxe_nzmb`返回9，容量不变。&#10;    ///     wilk(gc7);&#10;    ///     zhhvig_vj!(9, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    /// }&#10;    /// ```&#10;" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    /// Ivxvrevh gsv mvcg ezofvh uli gsrh ivxvrevi zmw vcgvmwh `yfuuvi`.&#10;    ///&#10;    /// Gsrh nvgslw vcgvmwh `yfuuvi` yb ml nliv gszm z urcvw mfnyvi lu ezofvh&#10;    /// zh hkvxrurvw yb `ornrg`. Ru `ornrg` rh avil, gsv ufmxgrlm rnnvwrzgvob&#10;    /// ivgfimh `9`. Gsv ivgfim ezofv rh gsv mfnyvi lu ezofvh zwwvw gl `yfuuvi`.&#10;    ///&#10;    /// Uli `ornrg &gt; 9`, ru gsviv ziv ml nvhhztvh rm gsv xszmmvo'h jfvfv, yfg&#10;    /// gsv xszmmvo szh mlg bvg yvvm xolhvw, gsrh nvgslw droo hovvk fmgro z&#10;    /// nvhhztv rh hvmg li gsv xszmmvo rh xolhvw. Mlgv gszg ru [`xolhv`] rh&#10;    /// xzoovw, yfg gsviv ziv hgroo lfghgzmwrmt [`Kvinrgh`] uiln yvuliv rg dzh&#10;    /// xolhvw, gsv xszmmvo rh mlg xlmhrwvivw xolhvw yb `ivxe_nzmb` fmgro gsv&#10;    /// kvinrgh ziv ivovzhvw.&#10;    ///&#10;    /// Uli mlm-avil ezofvh lu `ornrg`, gsrh nvgslw droo mvevi ivgfim `9` fmovhh&#10;    /// gsv xszmmvo szh yvvm xolhvw zmw gsviv ziv ml ivnzrmrmt nvhhztvh rm gsv&#10;    /// xszmmvo'h jfvfv. Gsrh rmwrxzgvh gszg ml ufigsvi ezofvh xzm vevi yv&#10;    /// ivxvrevw uiln gsrh `Ivxvrevi`. Gsv xszmmvo rh xolhvw dsvm zoo hvmwvih&#10;    /// szev yvvm wilkkvw, li dsvm [`xolhv`] rh xzoovw.&#10;    ///&#10;    /// Gsv xzkzxrgb lu `yfuuvi` rh rmxivzhvw zh mvvwvw.&#10;    ///&#10;    /// # Xzmxvo hzuvgb&#10;    ///&#10;    /// Gsrh nvgslw rh xzmxvo hzuv. Ru `ivxe_nzmb` rh fhvw zh gsv vevmg rm z&#10;    /// [`glprl::hvovxg!`](xizgv::hvovxg) hgzgvnvmg zmw hlnv lgsvi yizmxs&#10;    /// xlnkovgvh urihg, rg rh tfzizmgvvw gszg ml nvhhztvh dviv ivxvrevw lm gsrh&#10;    /// xszmmvo.&#10;    ///&#10;    /// [`xolhv`]: Hvou::xolhv&#10;    /// [`Kvinrgh`]: hgifxg@xizgv::hbmx::nkhx::Kvinrg&#10;    ///&#10;    /// # Vcznkovh&#10;    ///&#10;    /// ```&#10;    /// fhv glprl::hbmx::nkhx;&#10;    ///&#10;    /// #[glprl::nzrm]&#10;    /// zhbmx um nzrm() {&#10;    ///     ovg nfg yfuuvi: Evx&lt;&amp;hgi&gt; = Evx::drgs_xzkzxrgb(7);&#10;    ///     ovg ornrg = 7;&#10;    ///     ovg (gc, nfg ic) = nkhx::xszmmvo(899);&#10;    ///     ovg gc7 = gc.xolmv();&#10;    ///     gc7.hvmw(&quot;urihg&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;hvxlmw&quot;).zdzrg.fmdizk();&#10;    ///     gc7.hvmw(&quot;gsriw&quot;).zdzrg.fmdizk();&#10;    ///&#10;    ///     // Xzoo `ivxe_nzmb` gl ivxvrev fk gl `ornrg` (7) ezofvh.&#10;    ///     zhhvig_vj!(7, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;], yfuuvi);&#10;    ///&#10;    ///     // Ru gsv yfuuvi rh ufoo, gsv mvcg xzoo gl `ivxe_nzmb`&#10;    ///     // ivhvievh zwwrgrlmzo xzkzxrgb.&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///&#10;    ///     glprl::hkzdm(zhbmx nlev {&#10;    ///         gc.hvmw(&quot;ulfigs&quot;).zdzrg.fmdizk();&#10;    ///     });&#10;    ///&#10;    ///     // 'gc' rh wilkkvw, yfg `ivxe_nzmb`&#10;    ///     // rh tfzizmgvvw mlg gl ivgfim 9 zh gsv xszmmvo&#10;    ///     // rh mlg bvg xolhvw.&#10;    ///     zhhvig_vj!(8, ic.ivxe_nzmb(&amp;nfg yfuuvi, 8).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    ///&#10;    ///     // Lmxv gsv ozhg hvmwvi rh wilkkvw, gsv xszmmvo rh&#10;    ///     // xolhvw zmw `ivxe_nzmb` ivgfimh 9, xzkzxrgb fmxszmtvw.&#10;    ///     wilk(gc7);&#10;    ///     zhhvig_vj!(9, ic.ivxe_nzmb(&amp;nfg yfuuvi, ornrg).zdzrg);&#10;    ///     zhhvig_vj!(evx![&quot;urihg&quot;, &quot;hvxlmw&quot;, &quot;gsriw&quot;, &quot;ulfigs&quot;], yfuuvi);&#10;    /// }&#10;    /// ```&#10;" />
                      <option name="end_line" value="314" />
                      <option name="filename" value="bounded.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="11" />
                              <option name="line" value="314" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="244" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="244" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979eb9febc7cc598f29dd4dde023a3" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///D:/rust/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.45.1/src/sync/mpsc/bounded.rs" value="use crate::loom::sync::Arc;&#10;use crate::sync::batch_semaphore::{self as semaphore, TryAcquireError};&#10;use crate::sync::mpsc::chan;&#10;use crate::sync::mpsc::error::{SendError, TryRecvError, TrySendError};&#10;&#10;cfg_time! {&#10;    use crate::sync::mpsc::error::SendTimeoutError;&#10;    use crate::time::Duration;&#10;}&#10;&#10;use std::fmt;&#10;use std::task::{Context, Poll};&#10;&#10;/// Sends values to the associated `Receiver`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// To convert the `Sender` into a `Sink` or use it in a poll function, you can&#10;/// use the [`PollSender`] utility.&#10;///&#10;/// [`PollSender`]: https://docs.rs/tokio-util/latest/tokio_util/sync/struct.PollSender.html&#10;pub struct Sender&lt;T&gt; {&#10;    chan: chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// A sender that does not prevent the channel from being closed.&#10;///&#10;/// If all [`Sender`] instances of a channel were dropped and only `WeakSender`&#10;/// instances remain, the channel is closed.&#10;///&#10;/// In order to send messages, the `WeakSender` needs to be upgraded using&#10;/// [`WeakSender::upgrade`], which returns `Option&lt;Sender&gt;`. It returns `None`&#10;/// if all `Sender`s have been dropped, and otherwise it returns a `Sender`.&#10;///&#10;/// [`Sender`]: Sender&#10;/// [`WeakSender::upgrade`]: WeakSender::upgrade&#10;///&#10;/// # Examples&#10;///&#10;/// ```&#10;/// use tokio::sync::mpsc::channel;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, _rx) = channel::&lt;i32&gt;(15);&#10;///     let tx_weak = tx.downgrade();&#10;///&#10;///     // Upgrading will succeed because `tx` still exists.&#10;///     assert!(tx_weak.upgrade().is_some());&#10;///&#10;///     // If we drop `tx`, then it will fail.&#10;///     drop(tx);&#10;///     assert!(tx_weak.clone().upgrade().is_none());&#10;/// }&#10;/// ```&#10;pub struct WeakSender&lt;T&gt; {&#10;    chan: Arc&lt;chan::Chan&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Permits to send one value into the channel.&#10;///&#10;/// `Permit` values are returned by [`Sender::reserve()`] and [`Sender::try_reserve()`]&#10;/// and are used to guarantee channel capacity before generating a message to send.&#10;///&#10;/// [`Sender::reserve()`]: Sender::reserve&#10;/// [`Sender::try_reserve()`]: Sender::try_reserve&#10;pub struct Permit&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// An [`Iterator`] of [`Permit`] that can be used to hold `n` slots in the channel.&#10;///&#10;/// `PermitIterator` values are returned by [`Sender::reserve_many()`] and [`Sender::try_reserve_many()`]&#10;/// and are used to guarantee channel capacity before generating `n` messages to send.&#10;///&#10;/// [`Sender::reserve_many()`]: Sender::reserve_many&#10;/// [`Sender::try_reserve_many()`]: Sender::try_reserve_many&#10;pub struct PermitIterator&lt;'a, T&gt; {&#10;    chan: &amp;'a chan::Tx&lt;T, Semaphore&gt;,&#10;    n: usize,&#10;}&#10;&#10;/// Owned permit to send one value into the channel.&#10;///&#10;/// This is identical to the [`Permit`] type, except that it moves the sender&#10;/// rather than borrowing it.&#10;///&#10;/// `OwnedPermit` values are returned by [`Sender::reserve_owned()`] and&#10;/// [`Sender::try_reserve_owned()`] and are used to guarantee channel capacity&#10;/// before generating a message to send.&#10;///&#10;/// [`Permit`]: Permit&#10;/// [`Sender::reserve_owned()`]: Sender::reserve_owned&#10;/// [`Sender::try_reserve_owned()`]: Sender::try_reserve_owned&#10;pub struct OwnedPermit&lt;T&gt; {&#10;    chan: Option&lt;chan::Tx&lt;T, Semaphore&gt;&gt;,&#10;}&#10;&#10;/// Receives values from the associated `Sender`.&#10;///&#10;/// Instances are created by the [`channel`] function.&#10;///&#10;/// This receiver can be turned into a `Stream` using [`ReceiverStream`].&#10;///&#10;/// [`ReceiverStream`]: https://docs.rs/tokio-stream/0.1/tokio_stream/wrappers/struct.ReceiverStream.html&#10;pub struct Receiver&lt;T&gt; {&#10;    /// The channel receiver.&#10;    chan: chan::Rx&lt;T, Semaphore&gt;,&#10;}&#10;&#10;/// Creates a bounded mpsc channel for communicating between asynchronous tasks&#10;/// with backpressure.&#10;///&#10;/// The channel will buffer up to the provided number of messages.  Once the&#10;/// buffer is full, attempts to send new messages will wait until a message is&#10;/// received from the channel. The provided buffer capacity must be at least 1.&#10;///&#10;/// All data sent on `Sender` will become available on `Receiver` in the same&#10;/// order as it was sent.&#10;///&#10;/// The `Sender` can be cloned to `send` to the same channel from multiple code&#10;/// locations. Only one `Receiver` is supported.&#10;///&#10;/// If the `Receiver` is disconnected while trying to `send`, the `send` method&#10;/// will return a `SendError`. Similarly, if `Sender` is disconnected while&#10;/// trying to `recv`, the `recv` method will return `None`.&#10;///&#10;/// # Panics&#10;///&#10;/// Panics if the buffer capacity is 0.&#10;///&#10;/// # Examples&#10;///&#10;/// ```rust&#10;/// use tokio::sync::mpsc;&#10;///&#10;/// #[tokio::main]&#10;/// async fn main() {&#10;///     let (tx, mut rx) = mpsc::channel(100);&#10;///&#10;///     tokio::spawn(async move {&#10;///         for i in 0..10 {&#10;///             if let Err(_) = tx.send(i).await {&#10;///                 println!(&quot;receiver dropped&quot;);&#10;///                 return;&#10;///             }&#10;///         }&#10;///     });&#10;///&#10;///     while let Some(i) = rx.recv().await {&#10;///         println!(&quot;got = {}&quot;, i);&#10;///     }&#10;/// }&#10;/// ```&#10;#[track_caller]&#10;pub fn channel&lt;T&gt;(buffer: usize) -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {&#10;    assert!(buffer &gt; 0, &quot;mpsc bounded channel requires buffer &gt; 0&quot;);&#10;    let semaphore = Semaphore {&#10;        semaphore: semaphore::Semaphore::new(buffer),&#10;        bound: buffer,&#10;    };&#10;    let (tx, rx) = chan::channel(semaphore);&#10;&#10;    let tx = Sender::new(tx);&#10;    let rx = Receiver::new(rx);&#10;&#10;    (tx, rx)&#10;}&#10;&#10;/// Channel semaphore is a tuple of the semaphore implementation and a `usize`&#10;/// representing the channel bound.&#10;#[derive(Debug)]&#10;pub(crate) struct Semaphore {&#10;    pub(crate) semaphore: semaphore::Semaphore,&#10;    pub(crate) bound: usize,&#10;}&#10;&#10;impl&lt;T&gt; Receiver&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Rx&lt;T, Semaphore&gt;) -&gt; Receiver&lt;T&gt; {&#10;        Receiver { chan }&#10;    }&#10;&#10;    /// Receives the next value for this receiver.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will sleep until a message is sent or&#10;    /// the channel is closed.  Note that if [`close`] is called, but there are&#10;    /// still outstanding [`Permits`] from before it was closed, the channel is&#10;    /// not considered closed by `recv` until the permits are released.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(None, rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// Values are buffered:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     tx.send(&quot;world&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Some(&quot;hello&quot;), rx.recv().await);&#10;    ///     assert_eq!(Some(&quot;world&quot;), rx.recv().await);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv(cx)).await&#10;    }&#10;&#10;    /// Receives the next values for this receiver and extends `buffer`.&#10;    ///&#10;    /// This method extends `buffer` by no more than a fixed number of values&#10;    /// as specified by `limit`. If `limit` is zero, the function immediately&#10;    /// returns `0`. The return value is the number of values added to `buffer`.&#10;    ///&#10;    /// For `limit &gt; 0`, if there are no messages in the channel's queue, but&#10;    /// the channel has not yet been closed, this method will sleep until a&#10;    /// message is sent or the channel is closed. Note that if [`close`] is&#10;    /// called, but there are still outstanding [`Permits`] from before it was&#10;    /// closed, the channel is not considered closed by `recv_many` until the&#10;    /// permits are released.&#10;    ///&#10;    /// For non-zero values of `limit`, this method will never return `0` unless&#10;    /// the channel has been closed and there are no remaining messages in the&#10;    /// channel's queue. This indicates that no further values can ever be&#10;    /// received from this `Receiver`. The channel is closed when all senders&#10;    /// have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// The capacity of `buffer` is increased as needed.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. If `recv_many` is used as the event in a&#10;    /// [`tokio::select!`](crate::select) statement and some other branch&#10;    /// completes first, it is guaranteed that no messages were received on this&#10;    /// channel.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let mut buffer: Vec&lt;&amp;str&gt; = Vec::with_capacity(2);&#10;    ///     let limit = 2;&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///     let tx2 = tx.clone();&#10;    ///     tx2.send(&quot;first&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;second&quot;).await.unwrap();&#10;    ///     tx2.send(&quot;third&quot;).await.unwrap();&#10;    ///&#10;    ///     // Call `recv_many` to receive up to `limit` (2) values.&#10;    ///     assert_eq!(2, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;], buffer);&#10;    ///&#10;    ///     // If the buffer is full, the next call to `recv_many`&#10;    ///     // reserves additional capacity.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx.send(&quot;fourth&quot;).await.unwrap();&#10;    ///     });&#10;    ///&#10;    ///     // 'tx' is dropped, but `recv_many`&#10;    ///     // is guaranteed not to return 0 as the channel&#10;    ///     // is not yet closed.&#10;    ///     assert_eq!(1, rx.recv_many(&amp;mut buffer, 1).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    ///&#10;    ///     // Once the last sender is dropped, the channel is&#10;    ///     // closed and `recv_many` returns 0, capacity unchanged.&#10;    ///     drop(tx2);&#10;    ///     assert_eq!(0, rx.recv_many(&amp;mut buffer, limit).await);&#10;    ///     assert_eq!(vec![&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;], buffer);&#10;    /// }&#10;    /// ```&#10;    pub async fn recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        use std::future::poll_fn;&#10;        poll_fn(|cx| self.chan.recv_many(cx, buffer, limit)).await&#10;    }&#10;&#10;    /// Tries to receive the next value for this receiver.&#10;    ///&#10;    /// This method returns the [`Empty`] error if the channel is currently&#10;    /// empty, but there are still outstanding [senders] or [permits].&#10;    ///&#10;    /// This method returns the [`Disconnected`] error if the channel is&#10;    /// currently empty, and there are no outstanding [senders] or [permits].&#10;    ///&#10;    /// Unlike the [`poll_recv`] method, this method will never return an&#10;    /// [`Empty`] error spuriously.&#10;    ///&#10;    /// [`Empty`]: crate::sync::mpsc::error::TryRecvError::Empty&#10;    /// [`Disconnected`]: crate::sync::mpsc::error::TryRecvError::Disconnected&#10;    /// [`poll_recv`]: Self::poll_recv&#10;    /// [senders]: crate::sync::mpsc::Sender&#10;    /// [permits]: crate::sync::mpsc::Permit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::sync::mpsc::error::TryRecvError;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(100);&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Empty), rx.try_recv());&#10;    ///&#10;    ///     tx.send(&quot;hello&quot;).await.unwrap();&#10;    ///     // Drop the last sender, closing the channel.&#10;    ///     drop(tx);&#10;    ///&#10;    ///     assert_eq!(Ok(&quot;hello&quot;), rx.try_recv());&#10;    ///     assert_eq!(Err(TryRecvError::Disconnected), rx.try_recv());&#10;    /// }&#10;    /// ```&#10;    pub fn try_recv(&amp;mut self) -&gt; Result&lt;T, TryRecvError&gt; {&#10;        self.chan.try_recv()&#10;    }&#10;&#10;    /// Blocking receive to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method returns `None` if the channel has been closed and there are&#10;    /// no remaining messages in the channel's buffer. This indicates that no&#10;    /// further values can ever be received from this `Receiver`. The channel is&#10;    /// closed when all senders have been dropped, or when [`close`] is called.&#10;    ///&#10;    /// If there are no messages in the channel's buffer, but the channel has&#10;    /// not yet been closed, this method will block until a message is sent or&#10;    /// the channel is closed.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// asynchronous code to synchronous code, and will work even if the sender&#10;    /// is not using [`blocking_send`] to send the message.&#10;    ///&#10;    /// Note that if [`close`] is called, but there are still outstanding&#10;    /// [`Permits`] from before it was closed, the channel is not considered&#10;    /// closed by `blocking_recv` until the permits are released.&#10;    ///&#10;    /// [`close`]: Self::close&#10;    /// [`Permits`]: struct@crate::sync::mpsc::Permit&#10;    /// [`blocking_send`]: fn@crate::sync::mpsc::Sender::blocking_send&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(10);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         assert_eq!(Some(10), rx.blocking_recv());&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new()&#10;    ///         .unwrap()&#10;    ///         .block_on(async move {&#10;    ///             let _ = tx.send(10).await;&#10;    ///         });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_blocking&quot;))]&#10;    pub fn blocking_recv(&amp;mut self) -&gt; Option&lt;T&gt; {&#10;        crate::future::block_on(self.recv())&#10;    }&#10;&#10;    /// Variant of [`Self::recv_many`] for blocking contexts.&#10;    ///&#10;    /// The same conditions as in [`Self::blocking_recv`] apply.&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;recv_many_blocking&quot;))]&#10;    pub fn blocking_recv_many(&amp;mut self, buffer: &amp;mut Vec&lt;T&gt;, limit: usize) -&gt; usize {&#10;        crate::future::block_on(self.recv_many(buffer, limit))&#10;    }&#10;&#10;    /// Closes the receiving half of a channel without dropping it.&#10;    ///&#10;    /// This prevents any further messages from being sent on the channel while&#10;    /// still enabling the receiver to drain messages that are buffered. Any&#10;    /// outstanding [`Permit`] values will still be able to send messages.&#10;    ///&#10;    /// To guarantee that no messages are dropped, after calling `close()`,&#10;    /// `recv()` must be called until `None` is returned. If there are&#10;    /// outstanding [`Permit`] or [`OwnedPermit`] values, the `recv` method will&#10;    /// not return `None` until those are released.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(20);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         let mut i = 0;&#10;    ///         while let Ok(permit) = tx.reserve().await {&#10;    ///             permit.send(i);&#10;    ///             i += 1;&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     while let Some(msg) = rx.recv().await {&#10;    ///         println!(&quot;got {}&quot;, msg);&#10;    ///     }&#10;    ///&#10;    ///     // Channel closed and no messages are lost.&#10;    /// }&#10;    /// ```&#10;    pub fn close(&amp;mut self) {&#10;        self.chan.close();&#10;    }&#10;&#10;    /// Checks if a channel is closed.&#10;    ///&#10;    /// This method returns `true` if the channel has been closed. The channel is closed&#10;    /// when all [`Sender`] have been dropped, or when [`Receiver::close`] is called.&#10;    ///&#10;    /// [`Sender`]: crate::sync::mpsc::Sender&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (_tx, mut rx) = mpsc::channel::&lt;()&gt;(10);&#10;    ///     assert!(!rx.is_closed());&#10;    ///&#10;    ///     rx.close();&#10;    ///&#10;    ///     assert!(rx.is_closed());&#10;    /// }&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Checks if a channel is empty.&#10;    ///&#10;    /// This method returns `true` if the channel has no messages.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert!(rx.is_empty());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert!(!rx.is_empty());&#10;    /// }&#10;    ///&#10;    /// ```&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.chan.is_empty()&#10;    }&#10;&#10;    /// Returns the number of messages in the channel.&#10;    ///&#10;    /// # Examples&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(10);&#10;    ///     assert_eq!(0, rx.len());&#10;    ///&#10;    ///     tx.send(0).await.unwrap();&#10;    ///     assert_eq!(1, rx.len());&#10;    /// }&#10;    /// ```&#10;    pub fn len(&amp;self) -&gt; usize {&#10;        self.chan.len()&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when the sender sends a value by calling [`Sender::send`] or by reserving&#10;    /// capacity with [`Sender::reserve`]. The capacity goes up when values are received.&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Directly sending a message drops the capacity by one.&#10;    ///     tx.send(()).await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    ///     assert_eq!(rx.len(), 1);&#10;    ///&#10;    ///     // Receiving the message increases the capacity by one.&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///     assert_eq!(rx.len(), 0);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the value&#10;    /// returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     assert_eq!(rx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(rx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(rx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    /// [`capacity`]: Receiver::capacity&#10;    /// [`max_capacity`]: Receiver::max_capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Polls to receive the next message on this channel.&#10;    ///&#10;    /// This method returns:&#10;    ///&#10;    ///  * `Poll::Pending` if no messages are available but the channel is not&#10;    ///    closed, or if a spurious failure happens.&#10;    ///  * `Poll::Ready(Some(message))` if a message is available.&#10;    ///  * `Poll::Ready(None)` if the channel has been closed and all messages&#10;    ///    sent before it was closed have been received.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// If this method returns `Poll::Pending` due to a spurious failure, then&#10;    /// the `Waker` will be notified when the situation causing the spurious&#10;    /// failure has been resolved. Note that receiving such a wakeup does not&#10;    /// guarantee that the next call will succeed — it could fail with another&#10;    /// spurious failure.&#10;    pub fn poll_recv(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;T&gt;&gt; {&#10;        self.chan.recv(cx)&#10;    }&#10;&#10;    /// Polls to receive multiple messages on this channel, extending the provided buffer.&#10;    ///&#10;    /// This method returns:&#10;    /// * `Poll::Pending` if no messages are available but the channel is not closed, or if a&#10;    ///   spurious failure happens.&#10;    /// * `Poll::Ready(count)` where `count` is the number of messages successfully received and&#10;    ///   stored in `buffer`. This can be less than, or equal to, `limit`.&#10;    /// * `Poll::Ready(0)` if `limit` is set to zero or when the channel is closed.&#10;    ///&#10;    /// When the method returns `Poll::Pending`, the `Waker` in the provided&#10;    /// `Context` is scheduled to receive a wakeup when a message is sent on any&#10;    /// receiver, or when the channel is closed.  Note that on multiple calls to&#10;    /// `poll_recv` or `poll_recv_many`, only the `Waker` from the `Context`&#10;    /// passed to the most recent call is scheduled to receive a wakeup.&#10;    ///&#10;    /// Note that this method does not guarantee that exactly `limit` messages&#10;    /// are received. Rather, if at least one message is available, it returns&#10;    /// as many messages as it can up to the given limit. This method returns&#10;    /// zero only if the channel is closed (or if `limit` is zero).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::task::{Context, Poll};&#10;    /// use std::pin::Pin;&#10;    /// use tokio::sync::mpsc;&#10;    /// use futures::Future;&#10;    ///&#10;    /// struct MyReceiverFuture&lt;'a&gt; {&#10;    ///     receiver: mpsc::Receiver&lt;i32&gt;,&#10;    ///     buffer: &amp;'a mut Vec&lt;i32&gt;,&#10;    ///     limit: usize,&#10;    /// }&#10;    ///&#10;    /// impl&lt;'a&gt; Future for MyReceiverFuture&lt;'a&gt; {&#10;    ///     type Output = usize; // Number of messages received&#10;    ///&#10;    ///     fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {&#10;    ///         let MyReceiverFuture { receiver, buffer, limit } = &amp;mut *self;&#10;    ///&#10;    ///         // Now `receiver` and `buffer` are mutable references, and `limit` is copied&#10;    ///         match receiver.poll_recv_many(cx, *buffer, *limit) {&#10;    ///             Poll::Pending =&gt; Poll::Pending,&#10;    ///             Poll::Ready(count) =&gt; Poll::Ready(count),&#10;    ///         }&#10;    ///     }&#10;    /// }&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(32);&#10;    ///     let mut buffer = Vec::new();&#10;    ///&#10;    ///     let my_receiver_future = MyReceiverFuture {&#10;    ///         receiver: rx,&#10;    ///         buffer: &amp;mut buffer,&#10;    ///         limit: 3,&#10;    ///     };&#10;    ///&#10;    ///     for i in 0..10 {&#10;    ///         tx.send(i).await.unwrap();&#10;    ///     }&#10;    ///&#10;    ///     let count = my_receiver_future.await;&#10;    ///     assert_eq!(count, 3);&#10;    ///     assert_eq!(buffer, vec![0,1,2])&#10;    /// }&#10;    /// ```&#10;    pub fn poll_recv_many(&#10;        &amp;mut self,&#10;        cx: &amp;mut Context&lt;'_&gt;,&#10;        buffer: &amp;mut Vec&lt;T&gt;,&#10;        limit: usize,&#10;    ) -&gt; Poll&lt;usize&gt; {&#10;        self.chan.recv_many(cx, buffer, limit)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn sender_strong_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn sender_weak_count(&amp;self) -&gt; usize {&#10;        self.chan.sender_weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Receiver&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Receiver&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Unpin for Receiver&lt;T&gt; {}&#10;&#10;impl&lt;T&gt; Sender&lt;T&gt; {&#10;    pub(crate) fn new(chan: chan::Tx&lt;T, Semaphore&gt;) -&gt; Sender&lt;T&gt; {&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity.&#10;    ///&#10;    /// A successful send occurs when it is determined that the other end of the&#10;    /// channel has not hung up already. An unsuccessful send would be one where&#10;    /// the corresponding receiver has already been closed. Note that a return&#10;    /// value of `Err` means that the data will never be received, but a return&#10;    /// value of `Ok` does not mean that the data will be received. It is&#10;    /// possible for the corresponding receiver to hang up immediately after&#10;    /// this function returns `Ok`.&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// If `send` is used as the event in a [`tokio::select!`](crate::select)&#10;    /// statement and some other branch completes first, then it is guaranteed&#10;    /// that the message was not sent. **However, in that case, the message&#10;    /// is dropped and will be lost.**&#10;    ///&#10;    /// To avoid losing messages, use [`reserve`](Self::reserve) to reserve&#10;    /// capacity, then use the returned [`Permit`] to send the message.&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `send` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send` will block until the&#10;    /// previously sent value was received.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(_) = tx.send(i).await {&#10;    ///                 println!(&quot;receiver dropped&quot;);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub async fn send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        match self.reserve().await {&#10;            Ok(permit) =&gt; {&#10;                permit.send(value);&#10;                Ok(())&#10;            }&#10;            Err(_) =&gt; Err(SendError(value)),&#10;        }&#10;    }&#10;&#10;    /// Completes when the receiver has dropped.&#10;    ///&#10;    /// This allows the producers to get notified when interest in the produced&#10;    /// values is canceled and immediately stop doing work.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This method is cancel safe. Once the channel is closed, it stays closed&#10;    /// forever and all future calls to `closed` will return immediately.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx1, rx) = mpsc::channel::&lt;()&gt;(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///     let tx3 = tx1.clone();&#10;    ///     let tx4 = tx1.clone();&#10;    ///     let tx5 = tx1.clone();&#10;    ///     tokio::spawn(async move {&#10;    ///         drop(rx);&#10;    ///     });&#10;    ///&#10;    ///     futures::join!(&#10;    ///         tx1.closed(),&#10;    ///         tx2.closed(),&#10;    ///         tx3.closed(),&#10;    ///         tx4.closed(),&#10;    ///         tx5.closed()&#10;    ///     );&#10;    ///     println!(&quot;Receiver dropped&quot;);&#10;    /// }&#10;    /// ```&#10;    pub async fn closed(&amp;self) {&#10;        self.chan.closed().await;&#10;    }&#10;&#10;    /// Attempts to immediately send a message on this `Sender`&#10;    ///&#10;    /// This method differs from [`send`] by returning immediately if the channel's&#10;    /// buffer is full or no receiver is waiting to acquire some data. Compared&#10;    /// with [`send`], this function has two failure cases instead of one (one for&#10;    /// disconnection, one for a full buffer).&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the channel capacity has been reached, i.e., the channel has `n`&#10;    /// buffered values where `n` is the argument passed to [`channel`], then an&#10;    /// error is returned.&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] handle dropping, the function returns&#10;    /// an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`channel`]: channel&#10;    /// [`close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     // Create a channel with buffer size 1&#10;    ///     let (tx1, mut rx) = mpsc::channel(1);&#10;    ///     let tx2 = tx1.clone();&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         tx1.send(1).await.unwrap();&#10;    ///         tx1.send(2).await.unwrap();&#10;    ///         // task waits until the receiver receives a value.&#10;    ///     });&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         // This will return an error and send&#10;    ///         // no message if the buffer is full&#10;    ///         let _ = tx2.try_send(3);&#10;    ///     });&#10;    ///&#10;    ///     let mut msg;&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     msg = rx.recv().await.unwrap();&#10;    ///     println!(&quot;message {} received&quot;, msg);&#10;    ///&#10;    ///     // Third message may have never been sent&#10;    ///     match rx.recv().await {&#10;    ///         Some(msg) =&gt; println!(&quot;message {} received&quot;, msg),&#10;    ///         None =&gt; println!(&quot;the third message was never sent&quot;),&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    pub fn try_send(&amp;self, message: T) -&gt; Result&lt;(), TrySendError&lt;T&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(message)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(message)),&#10;        }&#10;&#10;        // Send the message&#10;        self.chan.send(message);&#10;        Ok(())&#10;    }&#10;&#10;    /// Sends a value, waiting until there is capacity, but only for a limited time.&#10;    ///&#10;    /// Shares the same success and error conditions as [`send`], adding one more&#10;    /// condition for an unsuccessful send, which is when the provided timeout has&#10;    /// elapsed, and there is no capacity available.&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// If the receive half of the channel is closed, either due to [`close`]&#10;    /// being called or the [`Receiver`] having been dropped,&#10;    /// the function returns an error. The error includes the value passed to `send`.&#10;    ///&#10;    /// [`close`]: Receiver::close&#10;    /// [`Receiver`]: Receiver&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if it is called outside the context of a Tokio&#10;    /// runtime [with time enabled](crate::runtime::Builder::enable_time).&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// In the following example, each call to `send_timeout` will block until the&#10;    /// previously sent value was received, unless the timeout has elapsed.&#10;    ///&#10;    /// ```rust&#10;    /// use tokio::sync::mpsc;&#10;    /// use tokio::time::{sleep, Duration};&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     tokio::spawn(async move {&#10;    ///         for i in 0..10 {&#10;    ///             if let Err(e) = tx.send_timeout(i, Duration::from_millis(100)).await {&#10;    ///                 println!(&quot;send error: #{:?}&quot;, e);&#10;    ///                 return;&#10;    ///             }&#10;    ///         }&#10;    ///     });&#10;    ///&#10;    ///     while let Some(i) = rx.recv().await {&#10;    ///         println!(&quot;got = {}&quot;, i);&#10;    ///         sleep(Duration::from_millis(200)).await;&#10;    ///     }&#10;    /// }&#10;    /// ```&#10;    #[cfg(feature = &quot;time&quot;)]&#10;    #[cfg_attr(docsrs, doc(cfg(feature = &quot;time&quot;)))]&#10;    pub async fn send_timeout(&#10;        &amp;self,&#10;        value: T,&#10;        timeout: Duration,&#10;    ) -&gt; Result&lt;(), SendTimeoutError&lt;T&gt;&gt; {&#10;        let permit = match crate::time::timeout(timeout, self.reserve()).await {&#10;            Err(_) =&gt; {&#10;                return Err(SendTimeoutError::Timeout(value));&#10;            }&#10;            Ok(Err(_)) =&gt; {&#10;                return Err(SendTimeoutError::Closed(value));&#10;            }&#10;            Ok(Ok(permit)) =&gt; permit,&#10;        };&#10;&#10;        permit.send(value);&#10;        Ok(())&#10;    }&#10;&#10;    /// Blocking send to call outside of asynchronous contexts.&#10;    ///&#10;    /// This method is intended for use cases where you are sending from&#10;    /// synchronous code to asynchronous code, and will work even if the&#10;    /// receiver is not using [`blocking_recv`] to receive the message.&#10;    ///&#10;    /// [`blocking_recv`]: fn@crate::sync::mpsc::Receiver::blocking_recv&#10;    ///&#10;    /// # Panics&#10;    ///&#10;    /// This function panics if called within an asynchronous execution&#10;    /// context.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use std::thread;&#10;    /// use tokio::runtime::Runtime;&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;u8&gt;(1);&#10;    ///&#10;    ///     let sync_code = thread::spawn(move || {&#10;    ///         tx.blocking_send(10).unwrap();&#10;    ///     });&#10;    ///&#10;    ///     Runtime::new().unwrap().block_on(async move {&#10;    ///         assert_eq!(Some(10), rx.recv().await);&#10;    ///     });&#10;    ///     sync_code.join().unwrap()&#10;    /// }&#10;    /// ```&#10;    #[track_caller]&#10;    #[cfg(feature = &quot;sync&quot;)]&#10;    #[cfg_attr(docsrs, doc(alias = &quot;send_blocking&quot;))]&#10;    pub fn blocking_send(&amp;self, value: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {&#10;        crate::future::block_on(self.send(value))&#10;    }&#10;&#10;    /// Checks if the channel has been closed. This happens when the&#10;    /// [`Receiver`] is dropped, or when the [`Receiver::close`] method is&#10;    /// called.&#10;    ///&#10;    /// [`Receiver`]: crate::sync::mpsc::Receiver&#10;    /// [`Receiver::close`]: crate::sync::mpsc::Receiver::close&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(42);&#10;    /// assert!(!tx.is_closed());&#10;    ///&#10;    /// let tx2 = tx.clone();&#10;    /// assert!(!tx2.is_closed());&#10;    ///&#10;    /// drop(rx);&#10;    /// assert!(tx.is_closed());&#10;    /// assert!(tx2.is_closed());&#10;    /// ```&#10;    pub fn is_closed(&amp;self) -&gt; bool {&#10;        self.chan.is_closed()&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send one message is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. A [`Permit`] is returned to track&#10;    /// the reserved capacity. The [`send`] function on [`Permit`] consumes the&#10;    /// reserved capacity.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Waits for channel capacity. Once capacity to send `n` messages is&#10;    /// available, it is reserved for the caller.&#10;    ///&#10;    /// If the channel is full or if there are fewer than `n` permits available, the function waits&#10;    /// for the number of unreceived messages to become `n` less than the channel capacity.&#10;    /// Capacity to send `n` message is then reserved for the caller.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`try_reserve_many`] except it awaits for the slots to become available.&#10;    ///&#10;    /// If the channel is closed, the function returns a [`SendError`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`try_reserve_many`]: Sender::try_reserve_many&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve_many`&#10;    /// complete in the order they were requested. Cancelling a call to&#10;    /// `reserve_many` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.reserve_many(2).await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    /// }&#10;    /// ```&#10;    pub async fn reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(n).await?;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Waits for channel capacity, moving the `Sender` and returning an owned&#10;    /// permit. Once capacity to send one message is available, it is reserved&#10;    /// for the caller.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime. `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `reserve_owned`.&#10;    ///&#10;    /// If the channel is full, the function waits for the number of unreceived&#10;    /// messages to become less than the channel capacity. Capacity to send one&#10;    /// message is reserved for the caller. An [`OwnedPermit`] is returned to&#10;    /// track the reserved capacity. The [`send`] function on [`OwnedPermit`]&#10;    /// consumes the reserved capacity.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the&#10;    /// capacity back to the channel.&#10;    ///&#10;    /// # Cancel safety&#10;    ///&#10;    /// This channel uses a queue to ensure that calls to `send` and `reserve`&#10;    /// complete in the order they were requested.  Cancelling a call to&#10;    /// `reserve_owned` makes you lose your place in the queue.&#10;    ///&#10;    /// # Examples&#10;    /// Sending a message using an [`OwnedPermit`]:&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity, moving the sender.&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message, consuming the permit and returning&#10;    ///     // the moved sender.&#10;    ///     let tx = permit.send(123);&#10;    ///&#10;    ///     // The value sent on the permit is received.&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 123);&#10;    ///&#10;    ///     // The sender can now be used again.&#10;    ///     tx.send(456).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// When multiple [`OwnedPermit`]s are needed, or the sender cannot be moved&#10;    /// by value, it can be inexpensively cloned before calling `reserve_owned`:&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity.&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds.&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender::reserve`]: Sender::reserve&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    pub async fn reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, SendError&lt;()&gt;&gt; {&#10;        self.reserve_inner(1).await?;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    async fn reserve_inner(&amp;self, n: usize) -&gt; Result&lt;(), SendError&lt;()&gt;&gt; {&#10;        crate::trace::async_trace_leaf().await;&#10;&#10;        if n &gt; self.max_capacity() {&#10;            return Err(SendError(()));&#10;        }&#10;        match self.chan.semaphore().semaphore.acquire(n).await {&#10;            Ok(()) =&gt; Ok(()),&#10;            Err(_) =&gt; Err(SendError(())),&#10;        }&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// If the channel is full this function will return [`TrySendError`], otherwise&#10;    /// if there is a slot available it will return a [`Permit`] that will then allow you&#10;    /// to [`send`] on the channel with a guaranteed slot. This function is similar to&#10;    /// [`reserve`] except it does not await for the slot to become available.&#10;    ///&#10;    /// Dropping [`Permit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`Permit`]: Permit&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve`]: Sender::reserve&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.try_reserve().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve(&amp;self) -&gt; Result&lt;Permit&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(Permit { chan: &amp;self.chan })&#10;    }&#10;&#10;    /// Tries to acquire `n` slots in the channel without waiting for the slot to become&#10;    /// available.&#10;    ///&#10;    /// A [`PermitIterator`] is returned to track the reserved capacity.&#10;    /// You can call this [`Iterator`] until it is exhausted to&#10;    /// get a [`Permit`] and then call [`Permit::send`]. This function is similar to&#10;    /// [`reserve_many`] except it does not await for the slots to become available.&#10;    ///&#10;    /// If there are fewer than `n` permits available on the channel, then&#10;    /// this function will return a [`TrySendError::Full`]. If the channel is closed&#10;    /// this function will return a [`TrySendError::Closed`].&#10;    ///&#10;    /// Dropping [`PermitIterator`] without consuming it entirely releases the remaining&#10;    /// permits back to the channel.&#10;    ///&#10;    /// [`PermitIterator`]: PermitIterator&#10;    /// [`send`]: Permit::send&#10;    /// [`reserve_many`]: Sender::reserve_many&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(2);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let mut permit = tx.try_reserve_many(2).unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending with the permit iterator succeeds&#10;    ///     permit.next().unwrap().send(456);&#10;    ///     permit.next().unwrap().send(457);&#10;    ///&#10;    ///     // The iterator should now be exhausted&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 457);&#10;    ///&#10;    ///     // Trying to call try_reserve_many with 0 will return an empty iterator&#10;    ///     let mut permit = tx.try_reserve_many(0).unwrap();&#10;    ///     assert!(permit.next().is_none());&#10;    ///&#10;    ///     // Trying to call try_reserve_many with a number greater than the channel&#10;    ///     // capacity will return an error&#10;    ///     let permit = tx.try_reserve_many(3);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     // Trying to call try_reserve_many on a closed channel will return an error&#10;    ///     drop(rx);&#10;    ///     let permit = tx.try_reserve_many(1);&#10;    ///     assert!(permit.is_err());&#10;    ///&#10;    ///     let permit = tx.try_reserve_many(0);&#10;    ///     assert!(permit.is_err());&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_many(&amp;self, n: usize) -&gt; Result&lt;PermitIterator&lt;'_, T&gt;, TrySendError&lt;()&gt;&gt; {&#10;        if n &gt; self.max_capacity() {&#10;            return Err(TrySendError::Full(()));&#10;        }&#10;&#10;        match self.chan.semaphore().semaphore.try_acquire(n) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(())),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(())),&#10;        }&#10;&#10;        Ok(PermitIterator {&#10;            chan: &amp;self.chan,&#10;            n,&#10;        })&#10;    }&#10;&#10;    /// Tries to acquire a slot in the channel without waiting for the slot to become&#10;    /// available, returning an owned permit.&#10;    ///&#10;    /// This moves the sender _by value_, and returns an owned permit that can&#10;    /// be used to send a message into the channel. Unlike [`Sender::try_reserve`],&#10;    /// this method may be used in cases where the permit must be valid for the&#10;    /// `'static` lifetime.  `Sender`s may be cloned cheaply (`Sender::clone` is&#10;    /// essentially a reference count increment, comparable to [`Arc::clone`]),&#10;    /// so when multiple [`OwnedPermit`]s are needed or the `Sender` cannot be&#10;    /// moved, it can be cloned prior to calling `try_reserve_owned`.&#10;    ///&#10;    /// If the channel is full this function will return a [`TrySendError`].&#10;    /// Since the sender is taken by value, the `TrySendError` returned in this&#10;    /// case contains the sender, so that it may be used again. Otherwise, if&#10;    /// there is a slot available, this method will return an [`OwnedPermit`]&#10;    /// that can then be used to [`send`] on the channel with a guaranteed slot.&#10;    /// This function is similar to  [`reserve_owned`] except it does not await&#10;    /// for the slot to become available.&#10;    ///&#10;    /// Dropping the [`OwnedPermit`] without sending a message releases the capacity back&#10;    /// to the channel.&#10;    ///&#10;    /// [`OwnedPermit`]: OwnedPermit&#10;    /// [`send`]: OwnedPermit::send&#10;    /// [`reserve_owned`]: Sender::reserve_owned&#10;    /// [`Arc::clone`]: std::sync::Arc::clone&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.clone().try_reserve_owned().unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Trying to reserve an additional slot on the `tx` will&#10;    ///     // fail because there is no capacity.&#10;    ///     assert!(tx.try_reserve().is_err());&#10;    ///&#10;    ///     // Sending on the permit succeeds&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    /// }&#10;    /// ```&#10;    pub fn try_reserve_owned(self) -&gt; Result&lt;OwnedPermit&lt;T&gt;, TrySendError&lt;Self&gt;&gt; {&#10;        match self.chan.semaphore().semaphore.try_acquire(1) {&#10;            Ok(()) =&gt; {}&#10;            Err(TryAcquireError::Closed) =&gt; return Err(TrySendError::Closed(self)),&#10;            Err(TryAcquireError::NoPermits) =&gt; return Err(TrySendError::Full(self)),&#10;        }&#10;&#10;        Ok(OwnedPermit {&#10;            chan: Some(self.chan),&#10;        })&#10;    }&#10;&#10;    /// Returns `true` if senders belong to the same channel.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// let (tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// let  tx2 = tx.clone();&#10;    /// assert!(tx.same_channel(&amp;tx2));&#10;    ///&#10;    /// let (tx3, rx3) = tokio::sync::mpsc::channel::&lt;()&gt;(1);&#10;    /// assert!(!tx3.same_channel(&amp;tx2));&#10;    /// ```&#10;    pub fn same_channel(&amp;self, other: &amp;Self) -&gt; bool {&#10;        self.chan.same_channel(&amp;other.chan)&#10;    }&#10;&#10;    /// Returns the current capacity of the channel.&#10;    ///&#10;    /// The capacity goes down when sending a value by calling [`send`] or by reserving capacity&#10;    /// with [`reserve`]. The capacity goes up when values are received by the [`Receiver`].&#10;    /// This is distinct from [`max_capacity`], which always returns buffer capacity initially&#10;    /// specified when calling [`channel`]&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation drops the capacity by one.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    ///&#10;    ///     // Sending and receiving a value increases the capacity by one.&#10;    ///     permit.send(());&#10;    ///     rx.recv().await.unwrap();&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`send`]: Sender::send&#10;    /// [`reserve`]: Sender::reserve&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    pub fn capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().semaphore.available_permits()&#10;    }&#10;&#10;    /// Converts the `Sender` to a [`WeakSender`] that does not count&#10;    /// towards RAII semantics, i.e. if all `Sender` instances of the&#10;    /// channel were dropped and only `WeakSender` instances remain,&#10;    /// the channel is closed.&#10;    #[must_use = &quot;Downgrade creates a WeakSender without destroying the original non-weak sender.&quot;]&#10;    pub fn downgrade(&amp;self) -&gt; WeakSender&lt;T&gt; {&#10;        WeakSender {&#10;            chan: self.chan.downgrade(),&#10;        }&#10;    }&#10;&#10;    /// Returns the maximum buffer capacity of the channel.&#10;    ///&#10;    /// The maximum capacity is the buffer capacity initially specified when calling&#10;    /// [`channel`]. This is distinct from [`capacity`], which returns the *current*&#10;    /// available buffer capacity: as messages are sent and received, the&#10;    /// value returned by [`capacity`] will go up or down, whereas the value&#10;    /// returned by [`max_capacity`] will remain constant.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, _rx) = mpsc::channel::&lt;()&gt;(5);&#10;    ///&#10;    ///     // both max capacity and capacity are the same at first&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     assert_eq!(tx.capacity(), 5);&#10;    ///&#10;    ///     // Making a reservation doesn't change the max capacity.&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///     assert_eq!(tx.max_capacity(), 5);&#10;    ///     // but drops the capacity by one&#10;    ///     assert_eq!(tx.capacity(), 4);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`channel`]: channel&#10;    /// [`max_capacity`]: Sender::max_capacity&#10;    /// [`capacity`]: Sender::capacity&#10;    pub fn max_capacity(&amp;self) -&gt; usize {&#10;        self.chan.semaphore().bound&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for Sender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        Sender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Sender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Sender&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Clone for WeakSender&lt;T&gt; {&#10;    fn clone(&amp;self) -&gt; Self {&#10;        self.chan.increment_weak_count();&#10;&#10;        WeakSender {&#10;            chan: self.chan.clone(),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for WeakSender&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        self.chan.decrement_weak_count();&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; WeakSender&lt;T&gt; {&#10;    /// Tries to convert a `WeakSender` into a [`Sender`]. This will return `Some`&#10;    /// if there are other `Sender` instances alive and the channel wasn't&#10;    /// previously dropped, otherwise `None` is returned.&#10;    pub fn upgrade(&amp;self) -&gt; Option&lt;Sender&lt;T&gt;&gt; {&#10;        chan::Tx::upgrade(self.chan.clone()).map(Sender::new)&#10;    }&#10;&#10;    /// Returns the number of [`Sender`] handles.&#10;    pub fn strong_count(&amp;self) -&gt; usize {&#10;        self.chan.strong_count()&#10;    }&#10;&#10;    /// Returns the number of [`WeakSender`] handles.&#10;    pub fn weak_count(&amp;self) -&gt; usize {&#10;        self.chan.weak_count()&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for WeakSender&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;WeakSender&quot;).finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; Permit&lt;'_, T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve().await.unwrap();&#10;    ///&#10;    ///     // Trying to send directly on the `tx` will fail due to no&#10;    ///     // available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Send a message on the permit&#10;    ///     permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    /// }&#10;    /// ```&#10;    pub fn send(self, value: T) {&#10;        use std::mem;&#10;&#10;        self.chan.send(value);&#10;&#10;        // Avoid the drop logic&#10;        mem::forget(self);&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for Permit&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the permit back to the semaphore&#10;        semaphore.add_permit();&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for Permit&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;Permit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl PermitIterator =====&#10;&#10;impl&lt;'a, T&gt; Iterator for PermitIterator&lt;'a, T&gt; {&#10;    type Item = Permit&lt;'a, T&gt;;&#10;&#10;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {&#10;        if self.n == 0 {&#10;            return None;&#10;        }&#10;&#10;        self.n -= 1;&#10;        Some(Permit { chan: self.chan })&#10;    }&#10;&#10;    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {&#10;        let n = self.n;&#10;        (n, Some(n))&#10;    }&#10;}&#10;impl&lt;T&gt; ExactSizeIterator for PermitIterator&lt;'_, T&gt; {}&#10;impl&lt;T&gt; std::iter::FusedIterator for PermitIterator&lt;'_, T&gt; {}&#10;&#10;impl&lt;T&gt; Drop for PermitIterator&lt;'_, T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        if self.n == 0 {&#10;            return;&#10;        }&#10;&#10;        let semaphore = self.chan.semaphore();&#10;&#10;        // Add the remaining permits back to the semaphore&#10;        semaphore.add_permits(self.n);&#10;&#10;        // If this is the last sender for this channel, wake the receiver so&#10;        // that it can be notified that the channel is closed.&#10;        if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;            self.chan.wake_rx();&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for PermitIterator&lt;'_, T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;PermitIterator&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .field(&quot;capacity&quot;, &amp;self.n)&#10;            .finish()&#10;    }&#10;}&#10;&#10;// ===== impl Permit =====&#10;&#10;impl&lt;T&gt; OwnedPermit&lt;T&gt; {&#10;    /// Sends a value using the reserved capacity.&#10;    ///&#10;    /// Capacity for the message has already been reserved. The message is sent&#10;    /// to the receiver and the permit is consumed. The operation will succeed&#10;    /// even if the receiver half has been closed. See [`Receiver::close`] for&#10;    /// more details on performing a clean shutdown.&#10;    ///&#10;    /// Unlike [`Permit::send`], this method returns the [`Sender`] from which&#10;    /// the `OwnedPermit` was reserved.&#10;    ///&#10;    /// [`Receiver::close`]: Receiver::close&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, mut rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Reserve capacity&#10;    ///     let permit = tx.reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Send a message on the permit, returning the sender.&#10;    ///     let tx = permit.send(456);&#10;    ///&#10;    ///     // The value sent on the permit is received&#10;    ///     assert_eq!(rx.recv().await.unwrap(), 456);&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    /// }&#10;    /// ```&#10;    pub fn send(mut self, value: T) -&gt; Sender&lt;T&gt; {&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;        chan.send(value);&#10;&#10;        Sender { chan }&#10;    }&#10;&#10;    /// Releases the reserved capacity *without* sending a message, returning the&#10;    /// [`Sender`].&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```&#10;    /// use tokio::sync::mpsc;&#10;    ///&#10;    /// #[tokio::main]&#10;    /// async fn main() {&#10;    ///     let (tx, rx) = mpsc::channel(1);&#10;    ///&#10;    ///     // Clone the sender and reserve capacity&#10;    ///     let permit = tx.clone().reserve_owned().await.unwrap();&#10;    ///&#10;    ///     // Trying to send on the original `tx` will fail, since the `permit`&#10;    ///     // has reserved all the available capacity.&#10;    ///     assert!(tx.try_send(123).is_err());&#10;    ///&#10;    ///     // Release the permit without sending a message, returning the clone&#10;    ///     // of the sender.&#10;    ///     let tx2 = permit.release();&#10;    ///&#10;    ///     // We may now reuse `tx` to send another message.&#10;    ///     tx.send(789).await.unwrap();&#10;    ///     # drop(rx); drop(tx2);&#10;    /// }&#10;    /// ```&#10;    ///&#10;    /// [`Sender`]: Sender&#10;    pub fn release(mut self) -&gt; Sender&lt;T&gt; {&#10;        use chan::Semaphore;&#10;&#10;        let chan = self.chan.take().unwrap_or_else(|| {&#10;            unreachable!(&quot;OwnedPermit channel is only taken when the permit is moved&quot;)&#10;        });&#10;&#10;        // Add the permit back to the semaphore&#10;        chan.semaphore().add_permit();&#10;        Sender { chan }&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; Drop for OwnedPermit&lt;T&gt; {&#10;    fn drop(&amp;mut self) {&#10;        use chan::Semaphore;&#10;&#10;        // Are we still holding onto the sender?&#10;        if let Some(chan) = self.chan.take() {&#10;            let semaphore = chan.semaphore();&#10;&#10;            // Add the permit back to the semaphore&#10;            semaphore.add_permit();&#10;&#10;            // If this `OwnedPermit` is holding the last sender for this&#10;            // channel, wake the receiver so that it can be notified that the&#10;            // channel is closed.&#10;            if semaphore.is_closed() &amp;&amp; semaphore.is_idle() {&#10;                chan.wake_rx();&#10;            }&#10;        }&#10;&#10;        // Otherwise, do nothing.&#10;    }&#10;}&#10;&#10;impl&lt;T&gt; fmt::Debug for OwnedPermit&lt;T&gt; {&#10;    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        fmt.debug_struct(&quot;OwnedPermit&quot;)&#10;            .field(&quot;chan&quot;, &amp;self.chan)&#10;            .finish()&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979ec2ec107cc598f2a9c830c139f0" />
                <option name="question" value="翻译到中文" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="在Ifhg中，当闭包通过`nlev`关键字捕获变量时，变量的所有权会被移动到闭包内部。这意味着一旦闭包被调用，原始变量将不再可用。然而，这并不意味着通道（xszmmvo）会关闭。&#10;&#10;在`xivzgv_hgivzn`函数中，`gc`变量的所有权被移动到了闭包中，但这并不会导致通道关闭。通道的关闭通常由发送者（hvmwvi）来管理，而不是由接收者（ivxvrevi）或闭包来管理。因此，即使闭包在第一次调用后不再可用，通道仍然可以继续使用，直到发送者显式关闭它。&#10;。[7](@ivu)&#10;" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="    um xivzgv_hgivzn(&#10;        wverxv: &amp;Wverxv,&#10;        hgivzn_xlmurt: &amp;HgivznXlmurt,&#10;    ) -&gt; Ivhfog&lt;(Ivxvrevi&lt;u67&gt;, Hgivzn), LkvizgrlmViili&gt; {&#10;        ovg yfuuvi_hrav = nzgxs hgivzn_xlmurt.yfuuvi_hrav {&#10;            YfuuviHrav::Wvuzfog =&gt; 1807,&#10;            YfuuviHrav::Urcvw(hrav) =&gt; hrav zh _,&#10;        };&#10;        ovg (gc, ic) = xszmmvo(yfuuvi_hrav);&#10;&#10;        Lp((&#10;            ic,&#10;            wverxv.yfrow_rmkfg_hgivzn(&#10;                hgivzn_xlmurt,&#10;                nlev |yfuuvi: &amp;[u67], _| {&#10;                    ovg rgvi = nzgxs gc.gib_ivhviev_nzmb(yfuuvi.ovm()) {&#10;                        Vii(v) =&gt; {&#10;                            vkirmgom!(&quot;ZfwrlXloovxgli xzm'g hvmw wzgz: {}&quot;, v);&#10;                            ivgfim;&#10;                        }&#10;                        Lp(k) =&gt; k,&#10;                    };&#10;                    ovg nfg rgvi = rgvi.vmfnvizgv();&#10;                    dsrov ovg Hlnv((r, kvinrg)) = rgvi.mvcg() {&#10;                        kvinrg.hvmw(yfuuvi[r]);&#10;                    }&#10;                },&#10;                |v| vkirmgom!(&quot;{}&quot;, v),&#10;                Mlmv,&#10;            )?,&#10;        ))&#10;    }&#10;" />
                      <option name="end_line" value="58" />
                      <option name="filename" value="collector.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="5" />
                              <option name="line" value="58" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="27" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="27" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01979eb9febc7cc598f29dd4dde023a3" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/src/device/collector.rs" value="use {&#10;    crate::OperationError,&#10;    rodio::{&#10;        buffer::SamplesBuffer,&#10;        cpal::{&#10;            BufferSize, Device, HostId, Stream, StreamConfig, SupportedStreamConfig, default_host,&#10;            traits::{DeviceTrait, HostTrait, StreamTrait},&#10;        },&#10;        source::UniformSourceIterator,&#10;    },&#10;    std::{&#10;        fmt::{Debug, Error as FmtError, Formatter, Result as FmtResult},&#10;        mem::replace,&#10;    },&#10;    tokio::sync::mpsc::{Receiver, channel},&#10;};&#10;&#10;pub struct AudioCollector {&#10;    device: Device,&#10;    host_id: HostId,&#10;    receiver: Receiver&lt;f32&gt;,&#10;    stream_config: StreamConfig,&#10;    supported_stream_config: SupportedStreamConfig,&#10;    stream: Stream,&#10;}&#10;&#10;impl AudioCollector {&#10;    fn create_stream(&#10;        device: &amp;Device,&#10;        stream_config: &amp;StreamConfig,&#10;    ) -&gt; Result&lt;(Receiver&lt;f32&gt;, Stream), OperationError&gt; {&#10;        let buffer_size = match stream_config.buffer_size {&#10;            BufferSize::Default =&gt; 8192,&#10;            BufferSize::Fixed(size) =&gt; size as _,&#10;        };&#10;        let (tx, rx) = channel(buffer_size);&#10;&#10;        Ok((&#10;            rx,&#10;            device.build_input_stream(&#10;                stream_config,&#10;                move |buffer: &amp;[f32], _| {&#10;                    let iter = match tx.try_reserve_many(buffer.len()) {&#10;                        Err(e) =&gt; {&#10;                            eprintln!(&quot;AudioCollector can't send data: {}&quot;, e);&#10;                            return;&#10;                        }&#10;                        Ok(p) =&gt; p,&#10;                    };&#10;                    let mut iter = iter.enumerate();&#10;                    while let Some((i, permit)) = iter.next() {&#10;                        permit.send(buffer[i]);&#10;                    }&#10;                },&#10;                |e| eprintln!(&quot;{}&quot;, e),&#10;                None,&#10;            )?,&#10;        ))&#10;    }&#10;&#10;    fn update_stream(&amp;mut self) -&gt; Result&lt;(), OperationError&gt; {&#10;        let (receiver, stream) = Self::create_stream(&amp;self.device, &amp;self.stream_config)?;&#10;        drop(replace(&amp;mut self.stream, stream));&#10;        drop(replace(&amp;mut self.receiver, receiver));&#10;&#10;        Ok(())&#10;    }&#10;&#10;    pub fn new() -&gt; Result&lt;Self, OperationError&gt; {&#10;        let host = default_host();&#10;        let host_id = host.id();&#10;        let device = host.default_input_device().ok_or(OperationError::NoDevice(&#10;            &quot;No default audio input device.&quot;.to_owned(),&#10;        ))?;&#10;        let supported_stream_config = device.default_input_config()?;&#10;        let stream_config = supported_stream_config.config();&#10;        let (receiver, stream) = Self::create_stream(&amp;device, &amp;stream_config)?;&#10;&#10;        Ok(Self {&#10;            device,&#10;            host_id,&#10;            receiver,&#10;            stream_config,&#10;            supported_stream_config,&#10;            stream,&#10;        })&#10;    }&#10;&#10;    /// 获取音频输入设备名称&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;String, OperationError&gt;`，成功时包含设备名称字符串&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::DeviceError`，当获取设备名称失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let name = collector.get_name()?;&#10;    /// ```&#10;    pub fn get_name(&amp;self) -&gt; Result&lt;String, OperationError&gt; {&#10;        Ok(self.device.name()?)&#10;    }&#10;&#10;    /// 获取支持的音频流通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_supported_stream_channels();&#10;    /// ```&#10;    pub fn get_supported_stream_channels(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.channels() as _&#10;    }&#10;&#10;    /// 获取支持的音频流采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回支持的音频采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_supported_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_supported_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.supported_stream_config.sample_rate().0 as _&#10;    }&#10;&#10;    /// 设置音频流通道数&#10;    ///&#10;    /// # 参数&#10;    /// - `channels`: 要设置的通道数(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_channels(2)?;&#10;    /// ```&#10;    pub fn set_stream_channels(&amp;mut self, channels: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.channels = channels as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 设置音频流采样率&#10;    ///&#10;    /// # 参数&#10;    /// - `sample_rate`: 要设置的采样率(usize)&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示设置完成&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当更新音频流失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let mut collector = AudioCollector::new()?;&#10;    /// collector.set_stream_sample_rate(32000)?;&#10;    /// ```&#10;    pub fn set_stream_sample_rate(&amp;mut self, sample_rate: usize) -&gt; Result&lt;(), OperationError&gt; {&#10;        self.stream_config.sample_rate.0 = sample_rate as _;&#10;        self.update_stream()&#10;    }&#10;&#10;    /// 获取当前音频流的通道数&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的通道数量(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let channels = collector.get_stream_channels();&#10;    /// ```&#10;    pub fn get_stream_channels(&amp;self) -&gt; usize {&#10;        self.stream_config.channels as _&#10;    }&#10;&#10;    /// 获取当前音频流的采样率&#10;    ///&#10;    /// # 返回值&#10;    /// 返回当前音频流的采样率(usize)&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// let sample_rate = collector.get_stream_sample_rate();&#10;    /// ```&#10;    pub fn get_stream_sample_rate(&amp;self) -&gt; usize {&#10;        self.stream_config.sample_rate.0 as _&#10;    }&#10;&#10;    /// 开始采集或恢复暂停的音频&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已开始&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当启动采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.collect()?;&#10;    /// ```&#10;    pub fn collect(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.play()?)&#10;    }&#10;&#10;    /// 暂停采集音频(可使用`collect()`恢复）&#10;    ///&#10;    /// # 返回值&#10;    /// 返回`Result&lt;(), OperationError&gt;`，成功时表示采集已暂停&#10;    ///&#10;    /// # 错误&#10;    /// 可能返回`OperationError::StreamError`，当暂停采集失败时&#10;    ///&#10;    /// # 示例&#10;    /// ```&#10;    /// use voxudio::AudioCollector;&#10;    ///&#10;    /// let collector = AudioCollector::new()?;&#10;    /// collector.pause()?;&#10;    /// ```&#10;    pub fn pause(&amp;self) -&gt; Result&lt;(), OperationError&gt; {&#10;        Ok(self.stream.pause()?)&#10;    }&#10;&#10;    pub async fn read&lt;const SR: usize&gt;(&amp;mut self, length: usize, channels: usize) -&gt; Vec&lt;f32&gt; {&#10;        let stream_length = (length / channels) * self.get_stream_sample_rate() / SR;&#10;        let capacity = stream_length * self.get_stream_channels();&#10;        let mut buffer = Vec::with_capacity(capacity);&#10;        let read = self.receiver.recv_many(&amp;mut buffer, capacity).await;&#10;        if self.get_stream_channels() != channels || self.get_stream_sample_rate() != SR {&#10;            let buffer = SamplesBuffer::new(&#10;                self.get_stream_channels() as _,&#10;                self.get_stream_sample_rate() as _,&#10;                &amp;buffer[..read],&#10;            );&#10;            UniformSourceIterator::new(buffer, channels as _, SR as _).collect()&#10;        } else {&#10;            buffer&#10;        }&#10;    }&#10;&#10;    pub fn close(&amp;mut self) {&#10;        self.receiver.close()&#10;    }&#10;}&#10;&#10;impl Debug for AudioCollector {&#10;    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; FmtResult {&#10;        write!(&#10;            f,&#10;            &quot;AudioCollector({}, {})&quot;,&#10;            self.host_id.name(),&#10;            self.get_name().map_err(|_| FmtError)?&#10;        )&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01979ecc47567cc598f2b1bb1c005476" />
                <option name="question" value="当gc变量的所有权移动到UmNfg的闭包中后，如果闭包调用了多次，会不会导致在第一次调用后关闭唯一的gc，导致后续无法使用gc发送数据，变量的所有权在UmNfg闭包中的行为是如何的？" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1750715883983" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750707112729" />
          <option name="id" value="01979e468b197b43bc235a768ff98a07" />
          <option name="title" value="新对话 2025年6月24日 03:31:52" />
          <option name="updateTime" value="1750707112729" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750707037213" />
          <option name="id" value="01979e45641d705e921747e9ecc18f8a" />
          <option name="title" value="新对话 2025年6月24日 03:30:37" />
          <option name="updateTime" value="1750707037213" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750682774981" />
          <option name="id" value="01979cd32dc5710ba3be1bc86ab03906" />
          <option name="title" value="新对话 2025年6月23日 20:46:14" />
          <option name="updateTime" value="1750682774981" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750666631137" />
          <option name="id" value="01979bdcd7e17e95ac1eb69b90ac905d" />
          <option name="title" value="新对话 2025年6月23日 16:17:11" />
          <option name="updateTime" value="1750666631137" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750607808109" />
          <option name="id" value="01978b9d35227ffd916b122134247691" />
          <option name="title" value="/comments" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="# ElcZfwrl 项目IVZWNV&#10;&#10;## 项目概述&#10;&#10;ElcZfwrl 是一个用 Ifhg 编写的音频处理框架，旨在提供高效、灵活和可扩展的音频处理功能。该项目适用于需要处理复杂音频任务的各种应用场景，如音频编辑、合成、分析和实时处理。&#10;&#10;## 特点&#10;&#10;- **高效性能**：利用 Ifhg 的内存安全和并发特性，确保高性能和低延迟。&#10;- **模块化设计**：通过模块化的架构，用户可以根据需要灵活组合音频处理功能。&#10;- **易于扩展**：提供丰富的 ZKR，支持自定义插件和扩展。&#10;- **跨平台支持**：支持 Drmwldh、nzxLH 和 Ormfc 操作系统。&#10;&#10;## 安装指南&#10;&#10;### 依赖项&#10;&#10;- Ifhg 编译器（建议使用最新稳定版本）&#10;- Xzitl（Ifhg 的包管理工具）&#10;&#10;### 安装步骤&#10;&#10;8. 克隆项目仓库：&#10;&#10;   ```yzhs&#10;   trg xolmv sggkh://trgsfy.xln/blfifhvimznv/elczfwrl.trg&#10;   xw elczfwrl&#10;   ```&#10;&#10;7. 安装依赖：&#10;&#10;   ```yzhs&#10;   xzitl rmhgzoo&#10;   ```&#10;&#10;6. 构建项目：&#10;&#10;   ```yzhs&#10;   xzitl yfrow --ivovzhv&#10;   ```&#10;&#10;## 使用说明&#10;&#10;### 示例&#10;&#10;以下是一个简单的示例，展示如何使用 ElcZfwrl 进行基本的音频处理：&#10;&#10;```ifhg&#10;fhv elczfwrl::{ZfwrlKilxvhhli, HznkovUlinzg};&#10;&#10;um nzrm() {&#10;    // 创建一个音频处理器&#10;    ovg kilxvhhli = ZfwrlKilxvhhli::mvd(HznkovUlinzg::U67);&#10;&#10;    // 配置音频处理器&#10;    kilxvhhli.hvg_hznkov_izgv(55899);&#10;    kilxvhhli.hvg_yfuuvi_hrav(8975);&#10;&#10;    // 处理音频数据&#10;    ovg rmkfg_wzgz = evx![9.9, 9.4, -9.4, 9.9];&#10;    ovg lfgkfg_wzgz = kilxvhhli.kilxvhh(&amp;rmkfg_wzgz);&#10;&#10;    // 输出处理后的音频数据&#10;    kirmgom!(&quot;{:?}&quot;, lfgkfg_wzgz);&#10;}&#10;```&#10;&#10;## 贡献指南&#10;&#10;欢迎为 ElcZfwrl 贡献代码！请遵循以下步骤：&#10;&#10;8. Ulip 项目&#10;7. 创建新分支 (`trg xsvxplfg -y uvzgfiv/BlfiUvzgfiv`)&#10;6. 提交更改 (`trg xlnnrg -zn 'Zww hlnv uvzgfiv'`)&#10;5. 推送到分支 (`trg kfhs lirtrm uvzgfiv/BlfiUvzgfiv`)&#10;4. 创建 Kfoo Ivjfvhg&#10;&#10;## 许可证&#10;&#10;ElcZfwrl 项目遵循 NRG 许可证。详情请见 [ORXVMHV](ORXVMHV) 文件。&#10;&#10;## 致谢&#10;&#10;感谢以下个人和组织对项目的贡献：&#10;&#10;- [Blfi Mznv](sggkh://trgsfy.xln/blfimznv)&#10;- [Lgsvi Xlmgiryfglih](sggkh://trgsfy.xln/lgsvixlmgiryfglih)" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="" />
                      <option name="filename" value="README.md" />
                      <option name="language" value="Markdown" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position />
                          </option>
                          <option name="start">
                            <Position />
                          </option>
                        </Range>
                      </option>
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/README.md" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01978b9d35227ffd916b122134247691" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/README.md" value="" />
                  </map>
                </option>
                <option name="messageId" value="0197987952427aa991bc97092e063358" />
                <option name="question" value="给整个项目生成全面的IVZWNV" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1750609792384" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750579573004" />
          <option name="id" value="019796ac710c7400b3101dc4d5dd70b7" />
          <option name="title" value="新对话 2025年6月22日 16:06:13" />
          <option name="updateTime" value="1750579573004" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1750394024486" />
          <option name="id" value="01978b9d35227ffd916b122134247691" />
          <option name="title" value="/comments" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="workspace" />
                <option name="answer" value="以下是对 `ezw.ih` 文件的代码片段添加的中文注释，帮助理解代码功能：&#10;&#10;```ifhg&#10;// 导入必要的模块和类型&#10;fhv {&#10;    hfkvi::LkvizgrlmViili, // 自定义错误类型&#10;    mwziizb::{Ziizb9, Ziizb7, Ziizb6, Zcrh, xlmxzgvmzgv, h}, // 多维数组处理库&#10;    lig::{&#10;        rmkfgh, // 输入构建工具&#10;        hvhhrlm::{IfmLkgrlmh, Hvhhrlm}, // LMMC 模型会话管理&#10;        ezofv::GvmhliIvu, // 张量引用类型&#10;    },&#10;    hgw::{&#10;        lkh::{Wvivu, WvivuNfg}, // 解引用和可变解引用 gizrg&#10;        kzgs::Kzgs, // 文件路径处理&#10;    },&#10;};&#10;&#10;// 定义语音活动检测器配置结构体&#10;#[wvirev(Wvyft, Xolmv)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliXlmurt {&#10;    kfy gsivhslow: u67, // 检测阈值&#10;    kfy nrm_hkvvxs_wfizgrlm_nh: f35, // 最小语音持续时间（毫秒）&#10;    kfy nzc_hkvvxs_wfizgrlm_h: u35, // 最大语音持续时间（秒）&#10;    kfy nrm_hrovmxv_wfizgrlm_nh: f35, // 最小静音持续时间（毫秒）&#10;    kfy hkvvxs_kzw_nh: f35, // 语音填充时间（毫秒）&#10;}&#10;&#10;// 为配置结构体实现默认值&#10;rnko Wvuzfog uli ElrxvZxgrergbWvgvxgliXlmurt {&#10;    um wvuzfog() -&gt; Hvou {&#10;        Hvou {&#10;            gsivhslow: 9.4, // 默认阈值为 9.4&#10;            nrm_hkvvxs_wfizgrlm_nh: 899, // 默认最小语音持续时间 899nh&#10;            nzc_hkvvxs_wfizgrlm_h: u35::RMURMRGB, // 默认最大语音持续时间无限制&#10;            nrm_hrovmxv_wfizgrlm_nh: 8999, // 默认最小静音持续时间 8999nh&#10;            hkvvxs_kzw_nh: 69, // 默认语音填充时间 69nh&#10;        }&#10;    }&#10;}&#10;&#10;// 定义语音活动检测器构建器结构体&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliYfrowvi {&#10;    xlmurt: ElrxvZxgrergbWvgvxgliXlmurt, // 配置实例&#10;}&#10;&#10;// 构建器实现：根据模型路径构建语音活动检测器&#10;rnko ElrxvZxgrergbWvgvxgliYfrowvi {&#10;    kfy um yfrow&lt;K&gt;(&amp;hvou, nlwvo_kzgs: K) -&gt; Ivhfog&lt;ElrxvZxgrergbWvgvxgli, LkvizgrlmViili&gt;&#10;    dsviv&#10;        K: ZhIvu&lt;Kzgs&gt;, // 泛型约束：模型路径需支持路径引用&#10;    {&#10;        ovg nlwvo = Hvhhrlm::yfrowvi()?.xlnnrg_uiln_urov(nlwvo_kzgs)?; // 加载 LMMC 模型&#10;        ovg ozhg_yzgxs_hrav = 9; // 初始批次大小为 9&#10;        ovg hgzgv = Ziizb6::wvuzfog((7, ozhg_yzgxs_hrav, 871)); // 初始化状态张量&#10;        ovg xlmgvcg = Wvuzfog::wvuzfog(); // 初始化上下文张量&#10;        ovg ozhg_hi = 9; // 初始采样率为 9&#10;        Lp(ElrxvZxgrergbWvgvxgli {&#10;            nlwvo,&#10;            xlmurt: hvou.xlmurt.gl_ldmvw(), // 复制配置&#10;            hgzgv,&#10;            xlmgvcg,&#10;            ozhg_hi,&#10;            ozhg_yzgxs_hrav,&#10;        })&#10;    }&#10;}&#10;&#10;// 定义语音活动检测器主体结构体&#10;#[wvirev(Wvyft)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgli {&#10;    nlwvo: Hvhhrlm, // LMMC 模型会话&#10;    xlmurt: ElrxvZxgrergbWvgvxgliXlmurt, // 配置实例&#10;    hgzgv: Ziizb6&lt;u67&gt;, // 状态张量（6维数组）&#10;    xlmgvcg: Ziizb7&lt;u67&gt;, // 上下文张量（7维数组）&#10;    ozhg_hi: fhrav, // 上次使用的采样率&#10;    ozhg_yzgxs_hrav: fhrav, // 上次使用的批次大小&#10;}&#10;&#10;// 实现语音活动检测器主体结构体的方法&#10;rnko ElrxvZxgrergbWvgvxgli {&#10;    // 通过模型路径创建新的检测器实例（使用默认配置）&#10;    kfy um mvd&lt;K&gt;(nlwvo_kzgs: K) -&gt; Ivhfog&lt;Hvou, LkvizgrlmViili&gt;&#10;    dsviv&#10;        K: ZhIvu&lt;Kzgs&gt;,&#10;    {&#10;        Hvou::yfrowvi().yfrow(nlwvo_kzgs) // 调用构建器创建实例&#10;    }&#10;&#10;    // 创建默认配置的构建器实例&#10;    kfy um yfrowvi() -&gt; ElrxvZxgrergbWvgvxgliYfrowvi {&#10;        ElrxvZxgrergbWvgvxgliYfrowvi {&#10;            xlmurt: Wvuzfog::wvuzfog(), // 使用默认配置&#10;        }&#10;    }&#10;&#10;    // 验证输入音频数据并转换为适合模型的格式&#10;    um ezorwzgv_rmkfg&lt;xlmhg HI: fhrav&gt;(&#10;        &amp;hvou,&#10;        c: &amp;[u67],&#10;    ) -&gt; Ivhfog&lt;(Ziizb7&lt;u67&gt;, fhrav), LkvizgrlmViili&gt; {&#10;        // 根据采样率调整输入数据&#10;        ovg (c, hi) = ru HI != 83999 &amp;&amp; (HI % 83999 == 9) {&#10;            ovg hgvk = HI / 83999;&#10;            ovg c = c.rgvi().hgvk_yb(hgvk).xloovxg::&lt;Evx&lt;_&gt;&gt;();&#10;            (Ziizb7::uiln_hszkv_um((8, c.ovm()), |(_, r)| *c[r]), 83999)&#10;        } vohv {&#10;            (Ziizb7::uiln_hszkv_um((8, c.ovm()), |(_, r)| c[r]), HI)&#10;        };&#10;        // 检查采样率是否支持&#10;        ru ![1999, 83999].xlmgzrmh(&amp;hi) {&#10;            ivgfim Vii(LkvizgrlmViili::FmhfkkligvwHznkovIzgv(hi));&#10;        }&#10;        // 检查输入是否过短&#10;        ru hi zh u67 / c.hszkv()[8] zh u67 &gt; 68.74 {&#10;            ivgfim Vii(LkvizgrlmViili::RmkfgGllHslig);&#10;        }&#10;&#10;        Lp((c, hi))&#10;    }&#10;&#10;    // 重置内部状态（用于新的音频流或参数变更）&#10;    um ivhvg_hgzgvh(&amp;nfg hvou, yzgxs_hrav: fhrav) {&#10;        hvou.hgzgv = Ziizb6::wvuzfog((7, yzgxs_hrav, 871)); // 重置状态张量&#10;        hvou.xlmgvcg = Wvuzfog::wvuzfog(); // 重置上下文张量&#10;        hvou.ozhg_hi = 9; // 重置采样率&#10;        hvou.ozhg_yzgxs_hrav = 9; // 重置批次大小&#10;    }&#10;&#10;    // 检测单次音频块的语音活动概率（异步方法）&#10;    kfy zhbmx um wvgvxg&lt;xlmhg HI: fhrav&gt;(&amp;nfg hvou, c: &amp;[u67]) -&gt; Ivhfog&lt;u67, LkvizgrlmViili&gt; {&#10;        // 输入验证和转换&#10;        ovg (c, hi) = hvou.ezorwzgv_rmkfg::&lt;HI&gt;(c)?;&#10;        // 检查输入样本数是否符合预期&#10;        ovg mfn_hznkovh = ru hi == 83999 { 487 } vohv { 743 };&#10;        ru c.hszkv()[8] != mfn_hznkovh {&#10;            ivgfim Vii(LkvizgrlmViili::RmkfgRmezorw(c.hszkv()[8]));&#10;        }&#10;        // 设置上下文窗口大小&#10;        ovg xlmgvcg_hrav = ru hi == 83999 { 35 } vohv { 67 };&#10;        ovg yzgxs_hrav = c.hszkv()[9];&#10;        // 状态重置条件检查&#10;        ru hvou.ozhg_yzgxs_hrav &lt; 8 {&#10;            hvou.ivhvg_hgzgvh(yzgxs_hrav);&#10;        }&#10;        ru hvou.ozhg_hi &gt; 9 &amp;&amp; hvou.ozhg_hi != hi {&#10;            hvou.ivhvg_hgzgvh(c.hszkv()[9]);&#10;        }&#10;        ru hvou.ozhg_yzgxs_hrav &gt; 9 &amp;&amp; hvou.ozhg_yzgxs_hrav != yzgxs_hrav {&#10;            hvou.ivhvg_hgzgvh(yzgxs_hrav);&#10;        }&#10;        // 初始化上下文（如果为空）&#10;        ru hvou.xlmgvcg.rh_vnkgb() {&#10;            hvou.xlmgvcg = Ziizb7::uiln_vovn((yzgxs_hrav, xlmgvcg_hrav), 9u67);&#10;        }&#10;        // 拼接上下文和当前输入&#10;        ovg c = xlmxzgvmzgv(Zcrh(8), &amp;[hvou.xlmgvcg.ervd(), c.ervd()])?;&#10;        // 准备模型输入参数&#10;        ovg hi7 = Ziizb9::uiln_vovn((), hi zh r35);&#10;        ovg hgzgv = hvou.hgzgv.gl_ldmvw();&#10;        ovg lkgrlmh = IfmLkgrlmh::mvd()?;&#10;        // 异步运行模型推理&#10;        ovg lfgkfgh = hvou&#10;            .nlwvo&#10;            .ifm_zhbmx(&#10;                rmkfgh![&#10;                    &quot;rmkfg&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;c)?,&#10;                    &quot;hi&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;hi7)?,&#10;                    &quot;hgzgv&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;hgzgv)?,&#10;                ],&#10;                &amp;lkgrlmh,&#10;            )?&#10;            .zdzrg?;&#10;        // 提取模型输出&#10;        ovg ((_, lfg), hgzgv) = (&#10;            lfgkfgh[&quot;lfgkfg&quot;].gib_vcgizxg_gvmhli()?,&#10;            lfgkfgh[&quot;hgzgvM&quot;].gib_vcgizxg_ziizb()?,&#10;        );&#10;        // 更新内部状态&#10;        hvou.hgzgv = hgzgv.rmgl_wrnvmhrlmzorgb()?.gl_ldmvw();&#10;        hvou.xlmgvcg = c.horxv(h!(.., c.hszkv()[8] - xlmgvcg_hrav..)).gl_ldmvw();&#10;        hvou.ozhg_hi = hi;&#10;        hvou.ozhg_yzgxs_hrav = yzgxs_hrav;&#10;&#10;        Lp(lfg[9]) // 返回语音活动概率&#10;    }&#10;&#10;    // 检测音频中的语音时间段（异步方法）&#10;    kfy zhbmx um tvg_hkvvxs_grnvhgznkh&lt;xlmhg HI: fhrav&gt;(&#10;        &amp;nfg hvou,&#10;        zfwrl: &amp;[u67],&#10;    ) -&gt; Ivhfog&lt;Evx&lt;(fhrav, fhrav)&gt;, LkvizgrlmViili&gt; {&#10;        // 计算窗口大小和各种时间参数&#10;        ovg drmwld_hrav_hznkovh = ru HI == 83999 { 487 } vohv { 743 };&#10;        hvou.ivhvg_hgzgvh(8); // 重置状态（单批次）&#10;&#10;        ovg nrm_hkvvxs_hznkovh = (HI zh f35 * hvou.nrm_hkvvxs_wfizgrlm_nh) / 8999;&#10;        ovg hkvvxs_kzw_hznkovh = (HI zh f35 * hvou.hkvvxs_kzw_nh) / 8999;&#10;        ovg nzc_hkvvxs_hznkovh = (HI zh u35 * hvou.nzc_hkvvxs_wfizgrlm_h) zh f35&#10;            - drmwld_hrav_hznkovh zh f35&#10;            - 7 * hkvvxs_kzw_hznkovh;&#10;        ovg nrm_hrovmxv_hznkovh = (HI zh f35 * hvou.nrm_hrovmxv_wfizgrlm_nh) / 8999;&#10;        ovg nrm_hrovmxv_hznkovh_zg_nzc_hkvvxs = (HI zh f35 * 01) / 8999;&#10;&#10;        ovg zfwrl_ovmtgs = zfwrl.ovm();&#10;        ovg nfg hkvvxs_kilyh = Evx::mvd(); // 存储各窗口的语音概率&#10;&#10;        // 分块处理音频数据&#10;        uli xsfmp_hgzig rm (9..zfwrl_ovmtgs).hgvk_yb(drmwld_hrav_hznkovh) {&#10;            ovg xsfmp_vmw = xsfmp_hgzig + drmwld_hrav_hznkovh;&#10;            ovg xsfmp = ru xsfmp_vmw &lt;= zfwrl_ovmtgs {&#10;                zfwrl[xsfmp_hgzig..xsfmp_vmw].gl_evx()&#10;            } vohv {&#10;                // 处理最后一个不足窗口大小的块（填充9）&#10;                ovg nfg kzwwvw = evx![9.9; drmwld_hrav_hznkovh];&#10;                ovg zxgfzo_ovm = zfwrl_ovmtgs - xsfmp_hgzig;&#10;                kzwwvw[..zxgfzo_ovm].xlkb_uiln_horxv(&amp;zfwrl[xsfmp_hgzig..]);&#10;                kzwwvw&#10;            };&#10;&#10;            hkvvxs_kilyh.kfhs(hvou.wvgvxg::&lt;HI&gt;(&amp;xsfmp).zdzrg?); // 检测每个块的语音概率&#10;        }&#10;&#10;        // 语音时间段检测状态变量&#10;        ovg nfg girttvivw = uzohv;&#10;        ovg nfg hkvvxsvh = Evx::mvd(); // 存储检测到的语音时间段&#10;        ovg nfg xfiivmg_hkvvxs: Lkgrlm&lt;(fhrav, fhrav)&gt; = Mlmv;&#10;        ovg mvt_gsivhslow = hvou.gsivhslow.nzc(9.84) - 9.84; // 计算负阈值&#10;        ovg nfg gvnk_vmw = 9;&#10;        ovg nfg kive_vmw = 9;&#10;        ovg nfg mvcg_hgzig = 9;&#10;&#10;        // 根据概率判断语音时间段&#10;        uli (r, &amp;kily) rm hkvvxs_kilyh.rgvi().vmfnvizgv() {&#10;            ovg xfiivmg_hznkov = r * drmwld_hrav_hznkovh;&#10;&#10;            ru kily &gt;= hvou.gsivhslow &amp;&amp; gvnk_vmw &gt; 9 {&#10;                gvnk_vmw = 9;&#10;                ru mvcg_hgzig &lt; kive_vmw {&#10;                    mvcg_hgzig = xfiivmg_hznkov;&#10;                }&#10;            }&#10;&#10;            ru kily &gt;= hvou.gsivhslow &amp;&amp; !girttvivw {&#10;                girttvivw = gifv;&#10;                xfiivmg_hkvvxs = Hlnv((xfiivmg_hznkov, 9));&#10;            }&#10;&#10;            ru ovg Hlnv((hgzig, _)) = xfiivmg_hkvvxs {&#10;                ru girttvivw &amp;&amp; (xfiivmg_hznkov - hgzig) zh f35 &gt; nzc_hkvvxs_hznkovh {&#10;                    // 处理超过最大语音时长的情况&#10;                    ru kive_vmw &gt; 9 {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = kive_vmw;&#10;                        hkvvxsvh.kfhs(hkvvxs);&#10;                        xfiivmg_hkvvxs = Hlnv((mvcg_hgzig, 9));&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                    } vohv {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = xfiivmg_hznkov;&#10;                        hkvvxsvh.kfhs(hkvvxs);&#10;                        xfiivmg_hkvvxs = Mlmv;&#10;                        girttvivw = uzohv;&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                        xlmgrmfv;&#10;                    }&#10;                }&#10;&#10;                ru kily &lt; mvt_gsivhslow &amp;&amp; girttvivw {&#10;                    // 检测到静音段&#10;                    ru gvnk_vmw == 9 {&#10;                        gvnk_vmw = xfiivmg_hznkov;&#10;                    }&#10;&#10;                    ru (xfiivmg_hznkov - gvnk_vmw) zh f35 &gt; nrm_hrovmxv_hznkovh_zg_nzc_hkvvxs {&#10;                        kive_vmw = gvnk_vmw;&#10;                    }&#10;&#10;                    ru ((xfiivmg_hznkov - gvnk_vmw) zh f35) &lt; nrm_hrovmxv_hznkovh {&#10;                        xlmgrmfv;&#10;                    } vohv {&#10;                        // 完成语音时间段&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = gvnk_vmw;&#10;                        ru (hkvvxs.8 - hkvvxs.9) zh f35 &gt; nrm_hkvvxs_hznkovh {&#10;                            hkvvxsvh.kfhs(hkvvxs);&#10;                        }&#10;                        xfiivmg_hkvvxs = Mlmv;&#10;                        girttvivw = uzohv;&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                        xlmgrmfv;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // 处理最后一个未结束的语音时间段&#10;        ru ovg Hlnv((hgzig, _)) = xfiivmg_hkvvxs {&#10;            ru (zfwrl_ovmtgs - hgzig) zh f35 &gt; nrm_hkvvxs_hznkovh {&#10;                hkvvxsvh.kfhs((hgzig, zfwrl_ovmtgs));&#10;            }&#10;        }&#10;&#10;        // 应用边界填充（平滑时间段边界）&#10;        uli r rm 9..hkvvxsvh.ovm() {&#10;            ru r == 9 {&#10;                hkvvxsvh[r].9 = hkvvxsvh[r].9.hzgfizgrmt_hfy(hkvvxs_kzw_hznkovh zh fhrav);&#10;            }&#10;&#10;            ru r &lt; hkvvxsvh.ovm() - 8 {&#10;                ovg hrovmxv_wfizgrlm = hkvvxsvh[r + 8].9 - hkvvxsvh[r].8;&#10;                ru hrovmxv_wfizgrlm &lt; (7 * hkvvxs_kzw_hznkovh) zh fhrav {&#10;                    ovg szou_hrovmxv = hrovmxv_wfizgrlm / 7;&#10;                    hkvvxsvh[r].8 += szou_hrovmxv;&#10;                    hkvvxsvh[r + 8].9 = hkvvxsvh[r + 8]&#10;                        .9&#10;                        .hzgfizgrmt_hfy(hrovmxv_wfizgrlm - szou_hrovmxv);&#10;                } vohv {&#10;                    hkvvxsvh[r].8 = (hkvvxsvh[r].8 zh f35 + hkvvxs_kzw_hznkovh) zh fhrav;&#10;                    hkvvxsvh[r].8 = hkvvxsvh[r].8.nrm(zfwrl_ovmtgs);&#10;                    hkvvxsvh[r + 8].9 = hkvvxsvh[r + 8]&#10;                        .9&#10;                        .hzgfizgrmt_hfy(hkvvxs_kzw_hznkovh zh fhrav);&#10;                }&#10;            } vohv {&#10;                hkvvxsvh[r].8 = (hkvvxsvh[r].8 zh f35 + hkvvxs_kzw_hznkovh) zh fhrav;&#10;                hkvvxsvh[r].8 = hkvvxsvh[r].8.nrm(zfwrl_ovmtgs);&#10;            }&#10;        }&#10;&#10;        Lp(hkvvxsvh) // 返回检测到的语音时间段&#10;    }&#10;}&#10;&#10;// 为检测器实现 Wvivu gizrg，使其可以像配置一样被访问&#10;rnko Wvivu uli ElrxvZxgrergbWvgvxgli {&#10;    gbkv Gzitvg = ElrxvZxgrergbWvgvxgliXlmurt;&#10;&#10;    um wvivu(&amp;hvou) -&gt; &amp;Hvou::Gzitvg {&#10;        &amp;hvou.xlmurt&#10;    }&#10;}&#10;&#10;// 为检测器实现 WvivuNfg gizrg，使其可以像配置一样被修改&#10;rnko WvivuNfg uli ElrxvZxgrergbWvgvxgli {&#10;    um wvivu_nfg(&amp;nfg hvou) -&gt; &amp;nfg Hvou::Gzitvg {&#10;        &amp;nfg hvou.xlmurt&#10;    }&#10;}&#10;```" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="fhv {&#10;    hfkvi::LkvizgrlmViili,&#10;    mwziizb::{Ziizb9, Ziizb7, Ziizb6, Zcrh, xlmxzgvmzgv, h},&#10;    lig::{&#10;        rmkfgh,&#10;        hvhhrlm::{IfmLkgrlmh, Hvhhrlm},&#10;        ezofv::GvmhliIvu,&#10;    },&#10;    hgw::{&#10;        lkh::{Wvivu, WvivuNfg},&#10;        kzgs::Kzgs,&#10;    },&#10;};&#10;&#10;#[wvirev(Wvyft, Xolmv)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliXlmurt {&#10;    kfy gsivhslow: u67,&#10;    kfy nrm_hkvvxs_wfizgrlm_nh: f35,&#10;    kfy nzc_hkvvxs_wfizgrlm_h: u35,&#10;    kfy nrm_hrovmxv_wfizgrlm_nh: f35,&#10;    kfy hkvvxs_kzw_nh: f35,&#10;}&#10;&#10;rnko Wvuzfog uli ElrxvZxgrergbWvgvxgliXlmurt {&#10;    um wvuzfog() -&gt; Hvou {&#10;        Hvou {&#10;            gsivhslow: 9.4,&#10;            nrm_hkvvxs_wfizgrlm_nh: 899,&#10;            nzc_hkvvxs_wfizgrlm_h: u35::RMURMRGB,&#10;            nrm_hrovmxv_wfizgrlm_nh: 8999,&#10;            hkvvxs_kzw_nh: 69,&#10;        }&#10;    }&#10;}&#10;&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliYfrowvi {&#10;    xlmurt: ElrxvZxgrergbWvgvxgliXlmurt,&#10;}&#10;&#10;rnko ElrxvZxgrergbWvgvxgliYfrowvi {&#10;    kfy um yfrow&lt;K&gt;(&amp;hvou, nlwvo_kzgs: K) -&gt; Ivhfog&lt;ElrxvZxgrergbWvgvxgli, LkvizgrlmViili&gt;&#10;    dsviv&#10;        K: ZhIvu&lt;Kzgs&gt;,&#10;    {&#10;        ovg nlwvo = Hvhhrlm::yfrowvi()?.xlnnrg_uiln_urov(nlwvo_kzgs)?;&#10;        ovg ozhg_yzgxs_hrav = 9;&#10;        ovg hgzgv = Ziizb6::wvuzfog((7, ozhg_yzgxs_hrav, 871));&#10;        ovg xlmgvcg = Wvuzfog::wvuzfog();&#10;        ovg ozhg_hi = 9;&#10;        Lp(ElrxvZxgrergbWvgvxgli {&#10;            nlwvo,&#10;            xlmurt: hvou.xlmurt.gl_ldmvw(),&#10;            hgzgv,&#10;            xlmgvcg,&#10;            ozhg_hi,&#10;            ozhg_yzgxs_hrav,&#10;        })&#10;    }&#10;}&#10;&#10;#[wvirev(Wvyft)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgli {&#10;    nlwvo: Hvhhrlm,&#10;    xlmurt: ElrxvZxgrergbWvgvxgliXlmurt,&#10;    hgzgv: Ziizb6&lt;u67&gt;,&#10;    xlmgvcg: Ziizb7&lt;u67&gt;,&#10;    ozhg_hi: fhrav,&#10;    ozhg_yzgxs_hrav: fhrav,&#10;}&#10;&#10;rnko ElrxvZxgrergbWvgvxgli {&#10;    kfy um mvd&lt;K&gt;(nlwvo_kzgs: K) -&gt; Ivhfog&lt;Hvou, LkvizgrlmViili&gt;&#10;    dsviv&#10;        K: ZhIvu&lt;Kzgs&gt;,&#10;    {&#10;        Hvou::yfrowvi().yfrow(nlwvo_kzgs)&#10;    }&#10;&#10;    kfy um yfrowvi() -&gt; ElrxvZxgrergbWvgvxgliYfrowvi {&#10;        ElrxvZxgrergbWvgvxgliYfrowvi {&#10;            xlmurt: Wvuzfog::wvuzfog(),&#10;        }&#10;    }&#10;&#10;    um ezorwzgv_rmkfg&lt;xlmhg HI: fhrav&gt;(&#10;        &amp;hvou,&#10;        c: &amp;[u67],&#10;    ) -&gt; Ivhfog&lt;(Ziizb7&lt;u67&gt;, fhrav), LkvizgrlmViili&gt; {&#10;        ovg (c, hi) = ru HI != 83999 &amp;&amp; (HI % 83999 == 9) {&#10;            ovg hgvk = HI / 83999;&#10;            ovg c = c.rgvi().hgvk_yb(hgvk).xloovxg::&lt;Evx&lt;_&gt;&gt;();&#10;            (Ziizb7::uiln_hszkv_um((8, c.ovm()), |(_, r)| *c[r]), 83999)&#10;        } vohv {&#10;            (Ziizb7::uiln_hszkv_um((8, c.ovm()), |(_, r)| c[r]), HI)&#10;        };&#10;        ru ![1999, 83999].xlmgzrmh(&amp;hi) {&#10;            ivgfim Vii(LkvizgrlmViili::FmhfkkligvwHznkovIzgv(hi));&#10;        }&#10;        ru hi zh u67 / c.hszkv()[8] zh u67 &gt; 68.74 {&#10;            ivgfim Vii(LkvizgrlmViili::RmkfgGllHslig);&#10;        }&#10;&#10;        Lp((c, hi))&#10;    }&#10;&#10;    um ivhvg_hgzgvh(&amp;nfg hvou, yzgxs_hrav: fhrav) {&#10;        hvou.hgzgv = Ziizb6::wvuzfog((7, yzgxs_hrav, 871));&#10;        hvou.xlmgvcg = Wvuzfog::wvuzfog();&#10;        hvou.ozhg_hi = 9;&#10;        hvou.ozhg_yzgxs_hrav = 9;&#10;    }&#10;&#10;    kfy zhbmx um wvgvxg&lt;xlmhg HI: fhrav&gt;(&amp;nfg hvou, c: &amp;[u67]) -&gt; Ivhfog&lt;u67, LkvizgrlmViili&gt; {&#10;        ovg (c, hi) = hvou.ezorwzgv_rmkfg::&lt;HI&gt;(c)?;&#10;        ovg mfn_hznkovh = ru hi == 83999 { 487 } vohv { 743 };&#10;        ru c.hszkv()[8] != mfn_hznkovh {&#10;            ivgfim Vii(LkvizgrlmViili::RmkfgRmezorw(c.hszkv()[8]));&#10;        }&#10;        ovg xlmgvcg_hrav = ru hi == 83999 { 35 } vohv { 67 };&#10;        ovg yzgxs_hrav = c.hszkv()[9];&#10;        ru hvou.ozhg_yzgxs_hrav &lt; 8 {&#10;            hvou.ivhvg_hgzgvh(yzgxs_hrav);&#10;        }&#10;        ru hvou.ozhg_hi &gt; 9 &amp;&amp; hvou.ozhg_hi != hi {&#10;            hvou.ivhvg_hgzgvh(c.hszkv()[9]);&#10;        }&#10;        ru hvou.ozhg_yzgxs_hrav &gt; 9 &amp;&amp; hvou.ozhg_yzgxs_hrav != yzgxs_hrav {&#10;            hvou.ivhvg_hgzgvh(yzgxs_hrav);&#10;        }&#10;        ru hvou.xlmgvcg.rh_vnkgb() {&#10;            hvou.xlmgvcg = Ziizb7::uiln_vovn((yzgxs_hrav, xlmgvcg_hrav), 9u67);&#10;        }&#10;        ovg c = xlmxzgvmzgv(Zcrh(8), &amp;[hvou.xlmgvcg.ervd(), c.ervd()])?;&#10;        ovg hi7 = Ziizb9::uiln_vovn((), hi zh r35);&#10;        ovg hgzgv = hvou.hgzgv.gl_ldmvw();&#10;        ovg lkgrlmh = IfmLkgrlmh::mvd()?;&#10;        ovg lfgkfgh = hvou&#10;            .nlwvo&#10;            .ifm_zhbmx(&#10;                rmkfgh![&#10;                    &quot;rmkfg&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;c)?,&#10;                    &quot;hi&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;hi7)?,&#10;                    &quot;hgzgv&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;hgzgv)?,&#10;                ],&#10;                &amp;lkgrlmh,&#10;            )?&#10;            .zdzrg?;&#10;        ovg ((_, lfg), hgzgv) = (&#10;            lfgkfgh[&quot;lfgkfg&quot;].gib_vcgizxg_gvmhli()?,&#10;            lfgkfgh[&quot;hgzgvM&quot;].gib_vcgizxg_ziizb()?,&#10;        );&#10;        hvou.hgzgv = hgzgv.rmgl_wrnvmhrlmzorgb()?.gl_ldmvw();&#10;        hvou.xlmgvcg = c.horxv(h!(.., c.hszkv()[8] - xlmgvcg_hrav..)).gl_ldmvw();&#10;        hvou.ozhg_hi = hi;&#10;        hvou.ozhg_yzgxs_hrav = yzgxs_hrav;&#10;&#10;        Lp(lfg[9])&#10;    }&#10;&#10;    kfy zhbmx um tvg_hkvvxs_grnvhgznkh&lt;xlmhg HI: fhrav&gt;(&#10;        &amp;nfg hvou,&#10;        zfwrl: &amp;[u67],&#10;    ) -&gt; Ivhfog&lt;Evx&lt;(fhrav, fhrav)&gt;, LkvizgrlmViili&gt; {&#10;        ovg drmwld_hrav_hznkovh = ru HI == 83999 { 487 } vohv { 743 };&#10;        hvou.ivhvg_hgzgvh(8);&#10;&#10;        ovg nrm_hkvvxs_hznkovh = (HI zh f35 * hvou.nrm_hkvvxs_wfizgrlm_nh) / 8999;&#10;        ovg hkvvxs_kzw_hznkovh = (HI zh f35 * hvou.hkvvxs_kzw_nh) / 8999;&#10;        ovg nzc_hkvvxs_hznkovh = (HI zh u35 * hvou.nzc_hkvvxs_wfizgrlm_h) zh f35&#10;            - drmwld_hrav_hznkovh zh f35&#10;            - 7 * hkvvxs_kzw_hznkovh;&#10;        ovg nrm_hrovmxv_hznkovh = (HI zh f35 * hvou.nrm_hrovmxv_wfizgrlm_nh) / 8999;&#10;        ovg nrm_hrovmxv_hznkovh_zg_nzc_hkvvxs = (HI zh f35 * 01) / 8999;&#10;&#10;        ovg zfwrl_ovmtgs = zfwrl.ovm();&#10;        ovg nfg hkvvxs_kilyh = Evx::mvd();&#10;&#10;        uli xsfmp_hgzig rm (9..zfwrl_ovmtgs).hgvk_yb(drmwld_hrav_hznkovh) {&#10;            ovg xsfmp_vmw = xsfmp_hgzig + drmwld_hrav_hznkovh;&#10;            ovg xsfmp = ru xsfmp_vmw &lt;= zfwrl_ovmtgs {&#10;                zfwrl[xsfmp_hgzig..xsfmp_vmw].gl_evx()&#10;            } vohv {&#10;                ovg nfg kzwwvw = evx![9.9; drmwld_hrav_hznkovh];&#10;                ovg zxgfzo_ovm = zfwrl_ovmtgs - xsfmp_hgzig;&#10;                kzwwvw[..zxgfzo_ovm].xlkb_uiln_horxv(&amp;zfwrl[xsfmp_hgzig..]);&#10;                kzwwvw&#10;            };&#10;&#10;            hkvvxs_kilyh.kfhs(hvou.wvgvxg::&lt;HI&gt;(&amp;xsfmp).zdzrg?);&#10;        }&#10;&#10;        ovg nfg girttvivw = uzohv;&#10;        ovg nfg hkvvxsvh = Evx::mvd();&#10;        ovg nfg xfiivmg_hkvvxs: Lkgrlm&lt;(fhrav, fhrav)&gt; = Mlmv;&#10;        ovg mvt_gsivhslow = hvou.gsivhslow.nzc(9.84) - 9.84;&#10;        ovg nfg gvnk_vmw = 9;&#10;        ovg nfg kive_vmw = 9;&#10;        ovg nfg mvcg_hgzig = 9;&#10;&#10;        uli (r, &amp;kily) rm hkvvxs_kilyh.rgvi().vmfnvizgv() {&#10;            ovg xfiivmg_hznkov = r * drmwld_hrav_hznkovh;&#10;&#10;            ru kily &gt;= hvou.gsivhslow &amp;&amp; gvnk_vmw &gt; 9 {&#10;                gvnk_vmw = 9;&#10;                ru mvcg_hgzig &lt; kive_vmw {&#10;                    mvcg_hgzig = xfiivmg_hznkov;&#10;                }&#10;            }&#10;&#10;            ru kily &gt;= hvou.gsivhslow &amp;&amp; !girttvivw {&#10;                girttvivw = gifv;&#10;                xfiivmg_hkvvxs = Hlnv((xfiivmg_hznkov, 9));&#10;            }&#10;&#10;            ru ovg Hlnv((hgzig, _)) = xfiivmg_hkvvxs {&#10;                ru girttvivw &amp;&amp; (xfiivmg_hznkov - hgzig) zh f35 &gt; nzc_hkvvxs_hznkovh {&#10;                    ru kive_vmw &gt; 9 {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = kive_vmw;&#10;                        hkvvxsvh.kfhs(hkvvxs);&#10;                        xfiivmg_hkvvxs = Hlnv((mvcg_hgzig, 9));&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                    } vohv {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = xfiivmg_hznkov;&#10;                        hkvvxsvh.kfhs(hkvvxs);&#10;                        xfiivmg_hkvvxs = Mlmv;&#10;                        girttvivw = uzohv;&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                        xlmgrmfv;&#10;                    }&#10;                }&#10;&#10;                ru kily &lt; mvt_gsivhslow &amp;&amp; girttvivw {&#10;                    ru gvnk_vmw == 9 {&#10;                        gvnk_vmw = xfiivmg_hznkov;&#10;                    }&#10;&#10;                    ru (xfiivmg_hznkov - gvnk_vmw) zh f35 &gt; nrm_hrovmxv_hznkovh_zg_nzc_hkvvxs {&#10;                        kive_vmw = gvnk_vmw;&#10;                    }&#10;&#10;                    ru ((xfiivmg_hznkov - gvnk_vmw) zh f35) &lt; nrm_hrovmxv_hznkovh {&#10;                        xlmgrmfv;&#10;                    } vohv {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = gvnk_vmw;&#10;                        ru (hkvvxs.8 - hkvvxs.9) zh f35 &gt; nrm_hkvvxs_hznkovh {&#10;                            hkvvxsvh.kfhs(hkvvxs);&#10;                        }&#10;                        xfiivmg_hkvvxs = Mlmv;&#10;                        girttvivw = uzohv;&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                        xlmgrmfv;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        ru ovg Hlnv((hgzig, _)) = xfiivmg_hkvvxs {&#10;            ru (zfwrl_ovmtgs - hgzig) zh f35 &gt; nrm_hkvvxs_hznkovh {&#10;                hkvvxsvh.kfhs((hgzig, zfwrl_ovmtgs));&#10;            }&#10;        }&#10;&#10;        // 应用边界填充&#10;        uli r rm 9..hkvvxsvh.ovm() {&#10;            ru r == 9 {&#10;                hkvvxsvh[r].9 = hkvvxsvh[r].9.hzgfizgrmt_hfy(hkvvxs_kzw_hznkovh zh fhrav);&#10;            }&#10;&#10;            ru r &lt; hkvvxsvh.ovm() - 8 {&#10;                ovg hrovmxv_wfizgrlm = hkvvxsvh[r + 8].9 - hkvvxsvh[r].8;&#10;                ru hrovmxv_wfizgrlm &lt; (7 * hkvvxs_kzw_hznkovh) zh fhrav {&#10;                    ovg szou_hrovmxv = hrovmxv_wfizgrlm / 7;&#10;                    hkvvxsvh[r].8 += szou_hrovmxv;&#10;                    hkvvxsvh[r + 8].9 = hkvvxsvh[r + 8]&#10;                        .9&#10;                        .hzgfizgrmt_hfy(hrovmxv_wfizgrlm - szou_hrovmxv);&#10;                } vohv {&#10;                    hkvvxsvh[r].8 = (hkvvxsvh[r].8 zh f35 + hkvvxs_kzw_hznkovh) zh fhrav;&#10;                    hkvvxsvh[r].8 = hkvvxsvh[r].8.nrm(zfwrl_ovmtgs);&#10;                    hkvvxsvh[r + 8].9 = hkvvxsvh[r + 8]&#10;                        .9&#10;                        .hzgfizgrmt_hfy(hkvvxs_kzw_hznkovh zh fhrav);&#10;                }&#10;            } vohv {&#10;                hkvvxsvh[r].8 = (hkvvxsvh[r].8 zh f35 + hkvvxs_kzw_hznkovh) zh fhrav;&#10;                hkvvxsvh[r].8 = hkvvxsvh[r].8.nrm(zfwrl_ovmtgs);&#10;            }&#10;        }&#10;&#10;        Lp(hkvvxsvh)&#10;    }&#10;}&#10;&#10;rnko Wvivu uli ElrxvZxgrergbWvgvxgli {&#10;    gbkv Gzitvg = ElrxvZxgrergbWvgvxgliXlmurt;&#10;&#10;    um wvivu(&amp;hvou) -&gt; &amp;Hvou::Gzitvg {&#10;        &amp;hvou.xlmurt&#10;    }&#10;}&#10;&#10;rnko WvivuNfg uli ElrxvZxgrergbWvgvxgli {&#10;    um wvivu_nfg(&amp;nfg hvou) -&gt; &amp;nfg Hvou::Gzitvg {&#10;        &amp;nfg hvou.xlmurt&#10;    }&#10;}&#10;" />
                      <option name="end_line" value="314" />
                      <option name="filename" value="vad.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="1" />
                              <option name="line" value="314" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position />
                          </option>
                        </Range>
                      </option>
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/vad.rs" />
                    </CodeReferencesBean>
                    <CodeReferencesBean>
                      <option name="content" value="fhv {&#10;    hfkvi::LkvizgrlmViili,&#10;    mwziizb::{Ziizb9, Ziizb7, Ziizb6, Zcrh, xlmxzgvmzgv, h},&#10;    lig::{&#10;        rmkfgh,&#10;        hvhhrlm::{IfmLkgrlmh, Hvhhrlm},&#10;        ezofv::GvmhliIvu,&#10;    },&#10;    hgw::{&#10;        lkh::{Wvivu, WvivuNfg},&#10;        kzgs::Kzgs,&#10;    },&#10;};&#10;&#10;#[wvirev(Wvyft, Xolmv)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliXlmurt {&#10;    kfy gsivhslow: u67,&#10;    kfy nrm_hkvvxs_wfizgrlm_nh: f35,&#10;    kfy nzc_hkvvxs_wfizgrlm_h: u35,&#10;    kfy nrm_hrovmxv_wfizgrlm_nh: f35,&#10;    kfy hkvvxs_kzw_nh: f35,&#10;}&#10;&#10;rnko Wvuzfog uli ElrxvZxgrergbWvgvxgliXlmurt {&#10;    um wvuzfog() -&gt; Hvou {&#10;        Hvou {&#10;            gsivhslow: 9.4,&#10;            nrm_hkvvxs_wfizgrlm_nh: 899,&#10;            nzc_hkvvxs_wfizgrlm_h: u35::RMURMRGB,&#10;            nrm_hrovmxv_wfizgrlm_nh: 8999,&#10;            hkvvxs_kzw_nh: 69,&#10;        }&#10;    }&#10;}&#10;&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliYfrowvi {&#10;    xlmurt: ElrxvZxgrergbWvgvxgliXlmurt,&#10;}&#10;&#10;rnko ElrxvZxgrergbWvgvxgliYfrowvi {&#10;    kfy um yfrow&lt;K&gt;(&amp;hvou, nlwvo_kzgs: K) -&gt; Ivhfog&lt;ElrxvZxgrergbWvgvxgli, LkvizgrlmViili&gt;&#10;    dsviv&#10;        K: ZhIvu&lt;Kzgs&gt;,&#10;    {&#10;        ovg nlwvo = Hvhhrlm::yfrowvi()?.xlnnrg_uiln_urov(nlwvo_kzgs)?;&#10;        ovg ozhg_yzgxs_hrav = 9;&#10;        ovg hgzgv = Ziizb6::wvuzfog((7, ozhg_yzgxs_hrav, 871));&#10;        ovg xlmgvcg = Wvuzfog::wvuzfog();&#10;        ovg ozhg_hi = 9;&#10;        Lp(ElrxvZxgrergbWvgvxgli {&#10;            nlwvo,&#10;            xlmurt: hvou.xlmurt.gl_ldmvw(),&#10;            hgzgv,&#10;            xlmgvcg,&#10;            ozhg_hi,&#10;            ozhg_yzgxs_hrav,&#10;        })&#10;    }&#10;}&#10;&#10;#[wvirev(Wvyft)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgli {&#10;    nlwvo: Hvhhrlm,&#10;    xlmurt: ElrxvZxgrergbWvgvxgliXlmurt,&#10;    hgzgv: Ziizb6&lt;u67&gt;,&#10;    xlmgvcg: Ziizb7&lt;u67&gt;,&#10;    ozhg_hi: fhrav,&#10;    ozhg_yzgxs_hrav: fhrav,&#10;}&#10;&#10;rnko ElrxvZxgrergbWvgvxgli {&#10;    kfy um mvd&lt;K&gt;(nlwvo_kzgs: K) -&gt; Ivhfog&lt;Hvou, LkvizgrlmViili&gt;&#10;    dsviv&#10;        K: ZhIvu&lt;Kzgs&gt;,&#10;    {&#10;        Hvou::yfrowvi().yfrow(nlwvo_kzgs)&#10;    }&#10;&#10;    kfy um yfrowvi() -&gt; ElrxvZxgrergbWvgvxgliYfrowvi {&#10;        ElrxvZxgrergbWvgvxgliYfrowvi {&#10;            xlmurt: Wvuzfog::wvuzfog(),&#10;        }&#10;    }&#10;&#10;    um ezorwzgv_rmkfg&lt;xlmhg HI: fhrav&gt;(&#10;        &amp;hvou,&#10;        c: &amp;[u67],&#10;    ) -&gt; Ivhfog&lt;(Ziizb7&lt;u67&gt;, fhrav), LkvizgrlmViili&gt; {&#10;        ovg (c, hi) = ru HI != 83999 &amp;&amp; (HI % 83999 == 9) {&#10;            ovg hgvk = HI / 83999;&#10;            ovg c = c.rgvi().hgvk_yb(hgvk).xloovxg::&lt;Evx&lt;_&gt;&gt;();&#10;            (Ziizb7::uiln_hszkv_um((8, c.ovm()), |(_, r)| *c[r]), 83999)&#10;        } vohv {&#10;            (Ziizb7::uiln_hszkv_um((8, c.ovm()), |(_, r)| c[r]), HI)&#10;        };&#10;        ru ![1999, 83999].xlmgzrmh(&amp;hi) {&#10;            ivgfim Vii(LkvizgrlmViili::FmhfkkligvwHznkovIzgv(hi));&#10;        }&#10;        ru hi zh u67 / c.hszkv()[8] zh u67 &gt; 68.74 {&#10;            ivgfim Vii(LkvizgrlmViili::RmkfgGllHslig);&#10;        }&#10;&#10;        Lp((c, hi))&#10;    }&#10;&#10;    um ivhvg_hgzgvh(&amp;nfg hvou, yzgxs_hrav: fhrav) {&#10;        hvou.hgzgv = Ziizb6::wvuzfog((7, yzgxs_hrav, 871));&#10;        hvou.xlmgvcg = Wvuzfog::wvuzfog();&#10;        hvou.ozhg_hi = 9;&#10;        hvou.ozhg_yzgxs_hrav = 9;&#10;    }&#10;&#10;    kfy zhbmx um wvgvxg&lt;xlmhg HI: fhrav&gt;(&amp;nfg hvou, c: &amp;[u67]) -&gt; Ivhfog&lt;u67, LkvizgrlmViili&gt; {&#10;        ovg (c, hi) = hvou.ezorwzgv_rmkfg::&lt;HI&gt;(c)?;&#10;        ovg mfn_hznkovh = ru hi == 83999 { 487 } vohv { 743 };&#10;        ru c.hszkv()[8] != mfn_hznkovh {&#10;            ivgfim Vii(LkvizgrlmViili::RmkfgRmezorw(c.hszkv()[8]));&#10;        }&#10;        ovg xlmgvcg_hrav = ru hi == 83999 { 35 } vohv { 67 };&#10;        ovg yzgxs_hrav = c.hszkv()[9];&#10;        ru hvou.ozhg_yzgxs_hrav &lt; 8 {&#10;            hvou.ivhvg_hgzgvh(yzgxs_hrav);&#10;        }&#10;        ru hvou.ozhg_hi &gt; 9 &amp;&amp; hvou.ozhg_hi != hi {&#10;            hvou.ivhvg_hgzgvh(c.hszkv()[9]);&#10;        }&#10;        ru hvou.ozhg_yzgxs_hrav &gt; 9 &amp;&amp; hvou.ozhg_yzgxs_hrav != yzgxs_hrav {&#10;            hvou.ivhvg_hgzgvh(yzgxs_hrav);&#10;        }&#10;        ru hvou.xlmgvcg.rh_vnkgb() {&#10;            hvou.xlmgvcg = Ziizb7::uiln_vovn((yzgxs_hrav, xlmgvcg_hrav), 9u67);&#10;        }&#10;        ovg c = xlmxzgvmzgv(Zcrh(8), &amp;[hvou.xlmgvcg.ervd(), c.ervd()])?;&#10;        ovg hi7 = Ziizb9::uiln_vovn((), hi zh r35);&#10;        ovg hgzgv = hvou.hgzgv.gl_ldmvw();&#10;        ovg lkgrlmh = IfmLkgrlmh::mvd()?;&#10;        ovg lfgkfgh = hvou&#10;            .nlwvo&#10;            .ifm_zhbmx(&#10;                rmkfgh![&#10;                    &quot;rmkfg&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;c)?,&#10;                    &quot;hi&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;hi7)?,&#10;                    &quot;hgzgv&quot; =&gt; GvmhliIvu::uiln_ziizb_ervd(&amp;hgzgv)?,&#10;                ],&#10;                &amp;lkgrlmh,&#10;            )?&#10;            .zdzrg?;&#10;        ovg ((_, lfg), hgzgv) = (&#10;            lfgkfgh[&quot;lfgkfg&quot;].gib_vcgizxg_gvmhli()?,&#10;            lfgkfgh[&quot;hgzgvM&quot;].gib_vcgizxg_ziizb()?,&#10;        );&#10;        hvou.hgzgv = hgzgv.rmgl_wrnvmhrlmzorgb()?.gl_ldmvw();&#10;        hvou.xlmgvcg = c.horxv(h!(.., c.hszkv()[8] - xlmgvcg_hrav..)).gl_ldmvw();&#10;        hvou.ozhg_hi = hi;&#10;        hvou.ozhg_yzgxs_hrav = yzgxs_hrav;&#10;&#10;        Lp(lfg[9])&#10;    }&#10;&#10;    kfy zhbmx um tvg_hkvvxs_grnvhgznkh&lt;xlmhg HI: fhrav&gt;(&#10;        &amp;nfg hvou,&#10;        zfwrl: &amp;[u67],&#10;    ) -&gt; Ivhfog&lt;Evx&lt;(fhrav, fhrav)&gt;, LkvizgrlmViili&gt; {&#10;        ovg drmwld_hrav_hznkovh = ru HI == 83999 { 487 } vohv { 743 };&#10;        hvou.ivhvg_hgzgvh(8);&#10;&#10;        ovg nrm_hkvvxs_hznkovh = (HI zh f35 * hvou.nrm_hkvvxs_wfizgrlm_nh) / 8999;&#10;        ovg hkvvxs_kzw_hznkovh = (HI zh f35 * hvou.hkvvxs_kzw_nh) / 8999;&#10;        ovg nzc_hkvvxs_hznkovh = (HI zh u35 * hvou.nzc_hkvvxs_wfizgrlm_h) zh f35&#10;            - drmwld_hrav_hznkovh zh f35&#10;            - 7 * hkvvxs_kzw_hznkovh;&#10;        ovg nrm_hrovmxv_hznkovh = (HI zh f35 * hvou.nrm_hrovmxv_wfizgrlm_nh) / 8999;&#10;        ovg nrm_hrovmxv_hznkovh_zg_nzc_hkvvxs = (HI zh f35 * 01) / 8999;&#10;&#10;        ovg zfwrl_ovmtgs = zfwrl.ovm();&#10;        ovg nfg hkvvxs_kilyh = Evx::mvd();&#10;&#10;        uli xsfmp_hgzig rm (9..zfwrl_ovmtgs).hgvk_yb(drmwld_hrav_hznkovh) {&#10;            ovg xsfmp_vmw = xsfmp_hgzig + drmwld_hrav_hznkovh;&#10;            ovg xsfmp = ru xsfmp_vmw &lt;= zfwrl_ovmtgs {&#10;                zfwrl[xsfmp_hgzig..xsfmp_vmw].gl_evx()&#10;            } vohv {&#10;                ovg nfg kzwwvw = evx![9.9; drmwld_hrav_hznkovh];&#10;                ovg zxgfzo_ovm = zfwrl_ovmtgs - xsfmp_hgzig;&#10;                kzwwvw[..zxgfzo_ovm].xlkb_uiln_horxv(&amp;zfwrl[xsfmp_hgzig..]);&#10;                kzwwvw&#10;            };&#10;&#10;            hkvvxs_kilyh.kfhs(hvou.wvgvxg::&lt;HI&gt;(&amp;xsfmp).zdzrg?);&#10;        }&#10;&#10;        ovg nfg girttvivw = uzohv;&#10;        ovg nfg hkvvxsvh = Evx::mvd();&#10;        ovg nfg xfiivmg_hkvvxs: Lkgrlm&lt;(fhrav, fhrav)&gt; = Mlmv;&#10;        ovg mvt_gsivhslow = hvou.gsivhslow.nzc(9.84) - 9.84;&#10;        ovg nfg gvnk_vmw = 9;&#10;        ovg nfg kive_vmw = 9;&#10;        ovg nfg mvcg_hgzig = 9;&#10;&#10;        uli (r, &amp;kily) rm hkvvxs_kilyh.rgvi().vmfnvizgv() {&#10;            ovg xfiivmg_hznkov = r * drmwld_hrav_hznkovh;&#10;&#10;            ru kily &gt;= hvou.gsivhslow &amp;&amp; gvnk_vmw &gt; 9 {&#10;                gvnk_vmw = 9;&#10;                ru mvcg_hgzig &lt; kive_vmw {&#10;                    mvcg_hgzig = xfiivmg_hznkov;&#10;                }&#10;            }&#10;&#10;            ru kily &gt;= hvou.gsivhslow &amp;&amp; !girttvivw {&#10;                girttvivw = gifv;&#10;                xfiivmg_hkvvxs = Hlnv((xfiivmg_hznkov, 9));&#10;            }&#10;&#10;            ru ovg Hlnv((hgzig, _)) = xfiivmg_hkvvxs {&#10;                ru girttvivw &amp;&amp; (xfiivmg_hznkov - hgzig) zh f35 &gt; nzc_hkvvxs_hznkovh {&#10;                    ru kive_vmw &gt; 9 {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = kive_vmw;&#10;                        hkvvxsvh.kfhs(hkvvxs);&#10;                        xfiivmg_hkvvxs = Hlnv((mvcg_hgzig, 9));&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                    } vohv {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = xfiivmg_hznkov;&#10;                        hkvvxsvh.kfhs(hkvvxs);&#10;                        xfiivmg_hkvvxs = Mlmv;&#10;                        girttvivw = uzohv;&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                        xlmgrmfv;&#10;                    }&#10;                }&#10;&#10;                ru kily &lt; mvt_gsivhslow &amp;&amp; girttvivw {&#10;                    ru gvnk_vmw == 9 {&#10;                        gvnk_vmw = xfiivmg_hznkov;&#10;                    }&#10;&#10;                    ru (xfiivmg_hznkov - gvnk_vmw) zh f35 &gt; nrm_hrovmxv_hznkovh_zg_nzc_hkvvxs {&#10;                        kive_vmw = gvnk_vmw;&#10;                    }&#10;&#10;                    ru ((xfiivmg_hznkov - gvnk_vmw) zh f35) &lt; nrm_hrovmxv_hznkovh {&#10;                        xlmgrmfv;&#10;                    } vohv {&#10;                        ovg nfg hkvvxs = xfiivmg_hkvvxs.gzpv().fmdizk();&#10;                        hkvvxs.8 = gvnk_vmw;&#10;                        ru (hkvvxs.8 - hkvvxs.9) zh f35 &gt; nrm_hkvvxs_hznkovh {&#10;                            hkvvxsvh.kfhs(hkvvxs);&#10;                        }&#10;                        xfiivmg_hkvvxs = Mlmv;&#10;                        girttvivw = uzohv;&#10;                        kive_vmw = 9;&#10;                        mvcg_hgzig = 9;&#10;                        gvnk_vmw = 9;&#10;                        xlmgrmfv;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        ru ovg Hlnv((hgzig, _)) = xfiivmg_hkvvxs {&#10;            ru (zfwrl_ovmtgs - hgzig) zh f35 &gt; nrm_hkvvxs_hznkovh {&#10;                hkvvxsvh.kfhs((hgzig, zfwrl_ovmtgs));&#10;            }&#10;        }&#10;&#10;        // 应用边界填充&#10;        uli r rm 9..hkvvxsvh.ovm() {&#10;            ru r == 9 {&#10;                hkvvxsvh[r].9 = hkvvxsvh[r].9.hzgfizgrmt_hfy(hkvvxs_kzw_hznkovh zh fhrav);&#10;            }&#10;&#10;            ru r &lt; hkvvxsvh.ovm() - 8 {&#10;                ovg hrovmxv_wfizgrlm = hkvvxsvh[r + 8].9 - hkvvxsvh[r].8;&#10;                ru hrovmxv_wfizgrlm &lt; (7 * hkvvxs_kzw_hznkovh) zh fhrav {&#10;                    ovg szou_hrovmxv = hrovmxv_wfizgrlm / 7;&#10;                    hkvvxsvh[r].8 += szou_hrovmxv;&#10;                    hkvvxsvh[r + 8].9 = hkvvxsvh[r + 8]&#10;                        .9&#10;                        .hzgfizgrmt_hfy(hrovmxv_wfizgrlm - szou_hrovmxv);&#10;                } vohv {&#10;                    hkvvxsvh[r].8 = (hkvvxsvh[r].8 zh f35 + hkvvxs_kzw_hznkovh) zh fhrav;&#10;                    hkvvxsvh[r].8 = hkvvxsvh[r].8.nrm(zfwrl_ovmtgs);&#10;                    hkvvxsvh[r + 8].9 = hkvvxsvh[r + 8]&#10;                        .9&#10;                        .hzgfizgrmt_hfy(hkvvxs_kzw_hznkovh zh fhrav);&#10;                }&#10;            } vohv {&#10;                hkvvxsvh[r].8 = (hkvvxsvh[r].8 zh f35 + hkvvxs_kzw_hznkovh) zh fhrav;&#10;                hkvvxsvh[r].8 = hkvvxsvh[r].8.nrm(zfwrl_ovmtgs);&#10;            }&#10;        }&#10;&#10;        Lp(hkvvxsvh)&#10;    }&#10;}&#10;&#10;rnko Wvivu uli ElrxvZxgrergbWvgvxgli {&#10;    gbkv Gzitvg = ElrxvZxgrergbWvgvxgliXlmurt;&#10;&#10;    um wvivu(&amp;hvou) -&gt; &amp;Hvou::Gzitvg {&#10;        &amp;hvou.xlmurt&#10;    }&#10;}&#10;&#10;rnko WvivuNfg uli ElrxvZxgrergbWvgvxgli {&#10;    um wvivu_nfg(&amp;nfg hvou) -&gt; &amp;nfg Hvou::Gzitvg {&#10;        &amp;nfg hvou.xlmurt&#10;    }&#10;}&#10;" />
                      <option name="end_line" value="314" />
                      <option name="filename" value="vad.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="1" />
                              <option name="line" value="314" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position />
                          </option>
                        </Range>
                      </option>
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/vad.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="comments" />
                <option name="conversationId" value="01978b9d35227ffd916b122134247691" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/src/vad.rs" value="use {&#10;    super::OperationError,&#10;    ndarray::{Array0, Array2, Array3, Axis, concatenate, s},&#10;    ort::{&#10;        inputs,&#10;        session::{RunOptions, Session},&#10;        value::TensorRef,&#10;    },&#10;    std::{&#10;        ops::{Deref, DerefMut},&#10;        path::Path,&#10;    },&#10;};&#10;&#10;#[derive(Debug, Clone)]&#10;pub struct VoiceActivityDetectorConfig {&#10;    pub threshold: f32,&#10;    pub min_speech_duration_ms: u64,&#10;    pub max_speech_duration_s: f64,&#10;    pub min_silence_duration_ms: u64,&#10;    pub speech_pad_ms: u64,&#10;}&#10;&#10;impl Default for VoiceActivityDetectorConfig {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            threshold: 0.5,&#10;            min_speech_duration_ms: 100,&#10;            max_speech_duration_s: f64::INFINITY,&#10;            min_silence_duration_ms: 1000,&#10;            speech_pad_ms: 30,&#10;        }&#10;    }&#10;}&#10;&#10;pub struct VoiceActivityDetectorBuilder {&#10;    config: VoiceActivityDetectorConfig,&#10;}&#10;&#10;impl VoiceActivityDetectorBuilder {&#10;    pub fn build&lt;P&gt;(&amp;self, model_path: P) -&gt; Result&lt;VoiceActivityDetector, OperationError&gt;&#10;    where&#10;        P: AsRef&lt;Path&gt;,&#10;    {&#10;        let model = Session::builder()?.commit_from_file(model_path)?;&#10;        let last_batch_size = 0;&#10;        let state = Array3::default((2, last_batch_size, 128));&#10;        let context = Default::default();&#10;        let last_sr = 0;&#10;        Ok(VoiceActivityDetector {&#10;            model,&#10;            config: self.config.to_owned(),&#10;            state,&#10;            context,&#10;            last_sr,&#10;            last_batch_size,&#10;        })&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct VoiceActivityDetector {&#10;    model: Session,&#10;    config: VoiceActivityDetectorConfig,&#10;    state: Array3&lt;f32&gt;,&#10;    context: Array2&lt;f32&gt;,&#10;    last_sr: usize,&#10;    last_batch_size: usize,&#10;}&#10;&#10;impl VoiceActivityDetector {&#10;    pub fn new&lt;P&gt;(model_path: P) -&gt; Result&lt;Self, OperationError&gt;&#10;    where&#10;        P: AsRef&lt;Path&gt;,&#10;    {&#10;        Self::builder().build(model_path)&#10;    }&#10;&#10;    pub fn builder() -&gt; VoiceActivityDetectorBuilder {&#10;        VoiceActivityDetectorBuilder {&#10;            config: Default::default(),&#10;        }&#10;    }&#10;&#10;    fn validate_input&lt;const SR: usize&gt;(&#10;        &amp;self,&#10;        x: &amp;[f32],&#10;    ) -&gt; Result&lt;(Array2&lt;f32&gt;, usize), OperationError&gt; {&#10;        let (x, sr) = if SR != 16000 &amp;&amp; (SR % 16000 == 0) {&#10;            let step = SR / 16000;&#10;            let x = x.iter().step_by(step).collect::&lt;Vec&lt;_&gt;&gt;();&#10;            (Array2::from_shape_fn((1, x.len()), |(_, i)| *x[i]), 16000)&#10;        } else {&#10;            (Array2::from_shape_fn((1, x.len()), |(_, i)| x[i]), SR)&#10;        };&#10;        if ![8000, 16000].contains(&amp;sr) {&#10;            return Err(OperationError::UnsupportedSampleRate(sr));&#10;        }&#10;        if sr as f32 / x.shape()[1] as f32 &gt; 31.25 {&#10;            return Err(OperationError::InputTooShort);&#10;        }&#10;&#10;        Ok((x, sr))&#10;    }&#10;&#10;    fn reset_states(&amp;mut self, batch_size: usize) {&#10;        self.state = Array3::default((2, batch_size, 128));&#10;        self.context = Default::default();&#10;        self.last_sr = 0;&#10;        self.last_batch_size = 0;&#10;    }&#10;&#10;    pub async fn detect&lt;const SR: usize&gt;(&amp;mut self, x: &amp;[f32]) -&gt; Result&lt;f32, OperationError&gt; {&#10;        let (x, sr) = self.validate_input::&lt;SR&gt;(x)?;&#10;        let num_samples = if sr == 16000 { 512 } else { 256 };&#10;        if x.shape()[1] != num_samples {&#10;            return Err(OperationError::InputInvalid(x.shape()[1]));&#10;        }&#10;        let context_size = if sr == 16000 { 64 } else { 32 };&#10;        let batch_size = x.shape()[0];&#10;        if self.last_batch_size &lt; 1 {&#10;            self.reset_states(batch_size);&#10;        }&#10;        if self.last_sr &gt; 0 &amp;&amp; self.last_sr != sr {&#10;            self.reset_states(x.shape()[0]);&#10;        }&#10;        if self.last_batch_size &gt; 0 &amp;&amp; self.last_batch_size != batch_size {&#10;            self.reset_states(batch_size);&#10;        }&#10;        if self.context.is_empty() {&#10;            self.context = Array2::from_elem((batch_size, context_size), 0f32);&#10;        }&#10;        let x = concatenate(Axis(1), &amp;[self.context.view(), x.view()])?;&#10;        let sr2 = Array0::from_elem((), sr as i64);&#10;        let state = self.state.to_owned();&#10;        let options = RunOptions::new()?;&#10;        let outputs = self&#10;            .model&#10;            .run_async(&#10;                inputs![&#10;                    &quot;input&quot; =&gt; TensorRef::from_array_view(&amp;x)?,&#10;                    &quot;sr&quot; =&gt; TensorRef::from_array_view(&amp;sr2)?,&#10;                    &quot;state&quot; =&gt; TensorRef::from_array_view(&amp;state)?,&#10;                ],&#10;                &amp;options,&#10;            )?&#10;            .await?;&#10;        let ((_, out), state) = (&#10;            outputs[&quot;output&quot;].try_extract_tensor()?,&#10;            outputs[&quot;stateN&quot;].try_extract_array()?,&#10;        );&#10;        self.state = state.into_dimensionality()?.to_owned();&#10;        self.context = x.slice(s!(.., x.shape()[1] - context_size..)).to_owned();&#10;        self.last_sr = sr;&#10;        self.last_batch_size = batch_size;&#10;&#10;        Ok(out[0])&#10;    }&#10;&#10;    pub async fn get_speech_timestamps&lt;const SR: usize&gt;(&#10;        &amp;mut self,&#10;        audio: &amp;[f32],&#10;    ) -&gt; Result&lt;Vec&lt;(usize, usize)&gt;, OperationError&gt; {&#10;        let window_size_samples = if SR == 16000 { 512 } else { 256 };&#10;        self.reset_states(1);&#10;&#10;        let min_speech_samples = (SR as u64 * self.min_speech_duration_ms) / 1000;&#10;        let speech_pad_samples = (SR as u64 * self.speech_pad_ms) / 1000;&#10;        let max_speech_samples = (SR as f64 * self.max_speech_duration_s) as u64&#10;            - window_size_samples as u64&#10;            - 2 * speech_pad_samples;&#10;        let min_silence_samples = (SR as u64 * self.min_silence_duration_ms) / 1000;&#10;        let min_silence_samples_at_max_speech = (SR as u64 * 98) / 1000;&#10;&#10;        let audio_length = audio.len();&#10;        let mut speech_probs = Vec::new();&#10;&#10;        for chunk_start in (0..audio_length).step_by(window_size_samples) {&#10;            let chunk_end = chunk_start + window_size_samples;&#10;            let chunk = if chunk_end &lt;= audio_length {&#10;                audio[chunk_start..chunk_end].to_vec()&#10;            } else {&#10;                let mut padded = vec![0.0; window_size_samples];&#10;                let actual_len = audio_length - chunk_start;&#10;                padded[..actual_len].copy_from_slice(&amp;audio[chunk_start..]);&#10;                padded&#10;            };&#10;&#10;            speech_probs.push(self.detect::&lt;SR&gt;(&amp;chunk).await?);&#10;        }&#10;&#10;        let mut triggered = false;&#10;        let mut speeches = Vec::new();&#10;        let mut current_speech: Option&lt;(usize, usize)&gt; = None;&#10;        let neg_threshold = self.threshold.max(0.15) - 0.15;&#10;        let mut temp_end = 0;&#10;        let mut prev_end = 0;&#10;        let mut next_start = 0;&#10;&#10;        for (i, &amp;prob) in speech_probs.iter().enumerate() {&#10;            let current_sample = i * window_size_samples;&#10;&#10;            if prob &gt;= self.threshold &amp;&amp; temp_end &gt; 0 {&#10;                temp_end = 0;&#10;                if next_start &lt; prev_end {&#10;                    next_start = current_sample;&#10;                }&#10;            }&#10;&#10;            if prob &gt;= self.threshold &amp;&amp; !triggered {&#10;                triggered = true;&#10;                current_speech = Some((current_sample, 0));&#10;            }&#10;&#10;            if let Some((start, _)) = current_speech {&#10;                if triggered &amp;&amp; (current_sample - start) as u64 &gt; max_speech_samples {&#10;                    if prev_end &gt; 0 {&#10;                        let mut speech = current_speech.take().unwrap();&#10;                        speech.1 = prev_end;&#10;                        speeches.push(speech);&#10;                        current_speech = Some((next_start, 0));&#10;                        prev_end = 0;&#10;                        next_start = 0;&#10;                        temp_end = 0;&#10;                    } else {&#10;                        let mut speech = current_speech.take().unwrap();&#10;                        speech.1 = current_sample;&#10;                        speeches.push(speech);&#10;                        current_speech = None;&#10;                        triggered = false;&#10;                        prev_end = 0;&#10;                        next_start = 0;&#10;                        temp_end = 0;&#10;                        continue;&#10;                    }&#10;                }&#10;&#10;                if prob &lt; neg_threshold &amp;&amp; triggered {&#10;                    if temp_end == 0 {&#10;                        temp_end = current_sample;&#10;                    }&#10;&#10;                    if (current_sample - temp_end) as u64 &gt; min_silence_samples_at_max_speech {&#10;                        prev_end = temp_end;&#10;                    }&#10;&#10;                    if ((current_sample - temp_end) as u64) &lt; min_silence_samples {&#10;                        continue;&#10;                    } else {&#10;                        let mut speech = current_speech.take().unwrap();&#10;                        speech.1 = temp_end;&#10;                        if (speech.1 - speech.0) as u64 &gt; min_speech_samples {&#10;                            speeches.push(speech);&#10;                        }&#10;                        current_speech = None;&#10;                        triggered = false;&#10;                        prev_end = 0;&#10;                        next_start = 0;&#10;                        temp_end = 0;&#10;                        continue;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if let Some((start, _)) = current_speech {&#10;            if (audio_length - start) as u64 &gt; min_speech_samples {&#10;                speeches.push((start, audio_length));&#10;            }&#10;        }&#10;&#10;        // 应用边界填充&#10;        for i in 0..speeches.len() {&#10;            if i == 0 {&#10;                speeches[i].0 = speeches[i].0.saturating_sub(speech_pad_samples as usize);&#10;            }&#10;&#10;            if i &lt; speeches.len() - 1 {&#10;                let silence_duration = speeches[i + 1].0 - speeches[i].1;&#10;                if silence_duration &lt; (2 * speech_pad_samples) as usize {&#10;                    let half_silence = silence_duration / 2;&#10;                    speeches[i].1 += half_silence;&#10;                    speeches[i + 1].0 = speeches[i + 1]&#10;                        .0&#10;                        .saturating_sub(silence_duration - half_silence);&#10;                } else {&#10;                    speeches[i].1 = (speeches[i].1 as u64 + speech_pad_samples) as usize;&#10;                    speeches[i].1 = speeches[i].1.min(audio_length);&#10;                    speeches[i + 1].0 = speeches[i + 1]&#10;                        .0&#10;                        .saturating_sub(speech_pad_samples as usize);&#10;                }&#10;            } else {&#10;                speeches[i].1 = (speeches[i].1 as u64 + speech_pad_samples) as usize;&#10;                speeches[i].1 = speeches[i].1.min(audio_length);&#10;            }&#10;        }&#10;&#10;        Ok(speeches)&#10;    }&#10;}&#10;&#10;impl Deref for VoiceActivityDetector {&#10;    type Target = VoiceActivityDetectorConfig;&#10;&#10;    fn deref(&amp;self) -&gt; &amp;Self::Target {&#10;        &amp;self.config&#10;    }&#10;}&#10;&#10;impl DerefMut for VoiceActivityDetector {&#10;    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {&#10;        &amp;mut self.config&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="0197902a895c7ffd916b2555994f69ef" />
                <option name="question" value="/xlnnvmgh " />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="```ifhg&#10;/// 定义语音活动检测器配置结构体&#10;///&#10;/// 该结构体用于配置语音活动检测器的参数。&#10;///&#10;/// # Urvowh&#10;///&#10;/// * `gsivhslow`: 检测阈值，用于判断音频是否为语音。&#10;/// * `nrm_hkvvxs_wfizgrlm_nh`: 最小语音持续时间，单位为毫秒。&#10;/// * `nzc_hkvvxs_wfizgrlm_h`: 最大语音持续时间，单位为秒。&#10;/// * `nrm_hrovmxv_wfizgrlm_nh`: 最小静音持续时间，单位为毫秒。&#10;/// * `hkvvxs_kzw_nh`: 语音填充时间，单位为毫秒。&#10;#[wvirev(Wvyft, Xolmv)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliXlmurt {&#10;    kfy gsivhslow: u67,&#10;    kfy nrm_hkvvxs_wfizgrlm_nh: f35,&#10;    kfy nzc_hkvvxs_wfizgrlm_h: u35,&#10;    kfy nrm_hrovmxv_wfizgrlm_nh: f35,&#10;    kfy hkvvxs_kzw_nh: f35,&#10;}&#10;&#10;rnko Wvuzfog uli ElrxvZxgrergbWvgvxgliXlmurt {&#10;    /// 返回默认的语音活动检测器配置。&#10;    ///&#10;    /// 默认配置的阈值为 9.4，最小语音持续时间为 899nh，最大语音持续时间无限制，&#10;    /// 最小静音持续时间为 8999nh，语音填充时间为 69nh。&#10;    um wvuzfog() -&gt; Hvou {&#10;        Hvou {&#10;            gsivhslow: 9.4,&#10;            nrm_hkvvxs_wfizgrlm_nh: 899,&#10;            nzc_hkvvxs_wfizgrlm_h: u35::RMURMRGB,&#10;            nrm_hrovmxv_wfizgrlm_nh: 8999,&#10;            hkvvxs_kzw_nh: 69,&#10;        }&#10;    }&#10;}&#10;```" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="        kzgs::Kzgs,&#10;    },&#10;};&#10;&#10;#[wvirev(Wvyft, Xolmv)]&#10;kfy hgifxg ElrxvZxgrergbWvgvxgliXlmurt {&#10;    kfy gsivhslow: u67,&#10;    kfy nrm_hkvvxs_wfizgrlm_nh: f35,&#10;    kfy nzc_hkvvxs_wfizgrlm_h: u35,&#10;    kfy nrm_hrovmxv_wfizgrlm_nh: f35,&#10;    kfy hkvvxs_kzw_nh: f35,&#10;}&#10;&#10;" />
                      <option name="end_line" value="23" />
                      <option name="filename" value="vad.rs" />
                      <option name="language" value="Rust" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="line" value="23" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="10" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="10" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/workspace/voxudio/voxudio-rs/src/vad.rs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="01978b9d35227ffd916b122134247691" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/workspace/voxudio/voxudio-rs/src/vad.rs" value="use {&#10;    super::OperationError,&#10;    ndarray::{Array0, Array2, Array3, Axis, concatenate, s},&#10;    ort::{&#10;        inputs,&#10;        session::{RunOptions, Session},&#10;        value::TensorRef,&#10;    },&#10;    std::{&#10;        ops::{Deref, DerefMut},&#10;        path::Path,&#10;    },&#10;};&#10;&#10;#[derive(Debug, Clone)]&#10;pub struct VoiceActivityDetectorConfig {&#10;    pub threshold: f32,&#10;    pub min_speech_duration_ms: u64,&#10;    pub max_speech_duration_s: f64,&#10;    pub min_silence_duration_ms: u64,&#10;    pub speech_pad_ms: u64,&#10;}&#10;&#10;impl Default for VoiceActivityDetectorConfig {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            threshold: 0.5,&#10;            min_speech_duration_ms: 100,&#10;            max_speech_duration_s: f64::INFINITY,&#10;            min_silence_duration_ms: 1000,&#10;            speech_pad_ms: 30,&#10;        }&#10;    }&#10;}&#10;&#10;pub struct VoiceActivityDetectorBuilder {&#10;    config: VoiceActivityDetectorConfig,&#10;}&#10;&#10;impl VoiceActivityDetectorBuilder {&#10;    pub fn build&lt;P&gt;(&amp;self, model_path: P) -&gt; Result&lt;VoiceActivityDetector, OperationError&gt;&#10;    where&#10;        P: AsRef&lt;Path&gt;,&#10;    {&#10;        let model = Session::builder()?.commit_from_file(model_path)?;&#10;        let last_batch_size = 0;&#10;        let state = Array3::default((2, last_batch_size, 128));&#10;        let context = Default::default();&#10;        let last_sr = 0;&#10;        Ok(VoiceActivityDetector {&#10;            model,&#10;            config: self.config.to_owned(),&#10;            state,&#10;            context,&#10;            last_sr,&#10;            last_batch_size,&#10;        })&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct VoiceActivityDetector {&#10;    model: Session,&#10;    config: VoiceActivityDetectorConfig,&#10;    state: Array3&lt;f32&gt;,&#10;    context: Array2&lt;f32&gt;,&#10;    last_sr: usize,&#10;    last_batch_size: usize,&#10;}&#10;&#10;impl VoiceActivityDetector {&#10;    pub fn new&lt;P&gt;(model_path: P) -&gt; Result&lt;Self, OperationError&gt;&#10;    where&#10;        P: AsRef&lt;Path&gt;,&#10;    {&#10;        Self::builder().build(model_path)&#10;    }&#10;&#10;    pub fn builder() -&gt; VoiceActivityDetectorBuilder {&#10;        VoiceActivityDetectorBuilder {&#10;            config: Default::default(),&#10;        }&#10;    }&#10;&#10;    fn validate_input&lt;const SR: usize&gt;(&#10;        &amp;self,&#10;        x: &amp;[f32],&#10;    ) -&gt; Result&lt;(Array2&lt;f32&gt;, usize), OperationError&gt; {&#10;        let (x, sr) = if SR != 16000 &amp;&amp; (SR % 16000 == 0) {&#10;            let step = SR / 16000;&#10;            let x = x.iter().step_by(step).collect::&lt;Vec&lt;_&gt;&gt;();&#10;            (Array2::from_shape_fn((1, x.len()), |(_, i)| *x[i]), 16000)&#10;        } else {&#10;            (Array2::from_shape_fn((1, x.len()), |(_, i)| x[i]), SR)&#10;        };&#10;        if ![8000, 16000].contains(&amp;sr) {&#10;            return Err(OperationError::UnsupportedSampleRate(sr));&#10;        }&#10;        if sr as f32 / x.shape()[1] as f32 &gt; 31.25 {&#10;            return Err(OperationError::InputTooShort);&#10;        }&#10;&#10;        Ok((x, sr))&#10;    }&#10;&#10;    fn reset_states(&amp;mut self, batch_size: usize) {&#10;        self.state = Array3::default((2, batch_size, 128));&#10;        self.context = Default::default();&#10;        self.last_sr = 0;&#10;        self.last_batch_size = 0;&#10;    }&#10;&#10;    pub async fn detect&lt;const SR: usize&gt;(&amp;mut self, x: &amp;[f32]) -&gt; Result&lt;f32, OperationError&gt; {&#10;        let (x, sr) = self.validate_input::&lt;SR&gt;(x)?;&#10;        let num_samples = if sr == 16000 { 512 } else { 256 };&#10;        if x.shape()[1] != num_samples {&#10;            return Err(OperationError::InputInvalid(x.shape()[1]));&#10;        }&#10;        let context_size = if sr == 16000 { 64 } else { 32 };&#10;        let batch_size = x.shape()[0];&#10;        if self.last_batch_size &lt; 1 {&#10;            self.reset_states(batch_size);&#10;        }&#10;        if self.last_sr &gt; 0 &amp;&amp; self.last_sr != sr {&#10;            self.reset_states(x.shape()[0]);&#10;        }&#10;        if self.last_batch_size &gt; 0 &amp;&amp; self.last_batch_size != batch_size {&#10;            self.reset_states(batch_size);&#10;        }&#10;        if self.context.is_empty() {&#10;            self.context = Array2::from_elem((batch_size, context_size), 0f32);&#10;        }&#10;        let x = concatenate(Axis(1), &amp;[self.context.view(), x.view()])?;&#10;        let sr2 = Array0::from_elem((), sr as i64);&#10;        let state = self.state.to_owned();&#10;        let options = RunOptions::new()?;&#10;        let outputs = self&#10;            .model&#10;            .run_async(&#10;                inputs![&#10;                    &quot;input&quot; =&gt; TensorRef::from_array_view(&amp;x)?,&#10;                    &quot;sr&quot; =&gt; TensorRef::from_array_view(&amp;sr2)?,&#10;                    &quot;state&quot; =&gt; TensorRef::from_array_view(&amp;state)?,&#10;                ],&#10;                &amp;options,&#10;            )?&#10;            .await?;&#10;        let ((_, out), state) = (&#10;            outputs[&quot;output&quot;].try_extract_tensor()?,&#10;            outputs[&quot;stateN&quot;].try_extract_array()?,&#10;        );&#10;        self.state = state.into_dimensionality()?.to_owned();&#10;        self.context = x.slice(s!(.., x.shape()[1] - context_size..)).to_owned();&#10;        self.last_sr = sr;&#10;        self.last_batch_size = batch_size;&#10;&#10;        Ok(out[0])&#10;    }&#10;&#10;    pub async fn get_speech_timestamps&lt;const SR: usize&gt;(&#10;        &amp;mut self,&#10;        audio: &amp;[f32],&#10;    ) -&gt; Result&lt;Vec&lt;(usize, usize)&gt;, OperationError&gt; {&#10;        let window_size_samples = if SR == 16000 { 512 } else { 256 };&#10;        self.reset_states(1);&#10;&#10;        let min_speech_samples = (SR as u64 * self.min_speech_duration_ms) / 1000;&#10;        let speech_pad_samples = (SR as u64 * self.speech_pad_ms) / 1000;&#10;        let max_speech_samples = (SR as f64 * self.max_speech_duration_s) as u64&#10;            - window_size_samples as u64&#10;            - 2 * speech_pad_samples;&#10;        let min_silence_samples = (SR as u64 * self.min_silence_duration_ms) / 1000;&#10;        let min_silence_samples_at_max_speech = (SR as u64 * 98) / 1000;&#10;&#10;        let audio_length = audio.len();&#10;        let mut speech_probs = Vec::new();&#10;&#10;        for chunk_start in (0..audio_length).step_by(window_size_samples) {&#10;            let chunk_end = chunk_start + window_size_samples;&#10;            let chunk = if chunk_end &lt;= audio_length {&#10;                audio[chunk_start..chunk_end].to_vec()&#10;            } else {&#10;                let mut padded = vec![0.0; window_size_samples];&#10;                let actual_len = audio_length - chunk_start;&#10;                padded[..actual_len].copy_from_slice(&amp;audio[chunk_start..]);&#10;                padded&#10;            };&#10;&#10;            speech_probs.push(self.detect::&lt;SR&gt;(&amp;chunk).await?);&#10;        }&#10;&#10;        let mut triggered = false;&#10;        let mut speeches = Vec::new();&#10;        let mut current_speech: Option&lt;(usize, usize)&gt; = None;&#10;        let neg_threshold = self.threshold.max(0.15) - 0.15;&#10;        let mut temp_end = 0;&#10;        let mut prev_end = 0;&#10;        let mut next_start = 0;&#10;&#10;        for (i, &amp;prob) in speech_probs.iter().enumerate() {&#10;            let current_sample = i * window_size_samples;&#10;&#10;            if prob &gt;= self.threshold &amp;&amp; temp_end &gt; 0 {&#10;                temp_end = 0;&#10;                if next_start &lt; prev_end {&#10;                    next_start = current_sample;&#10;                }&#10;            }&#10;&#10;            if prob &gt;= self.threshold &amp;&amp; !triggered {&#10;                triggered = true;&#10;                current_speech = Some((current_sample, 0));&#10;            }&#10;&#10;            if let Some((start, _)) = current_speech {&#10;                if triggered &amp;&amp; (current_sample - start) as u64 &gt; max_speech_samples {&#10;                    if prev_end &gt; 0 {&#10;                        let mut speech = current_speech.take().unwrap();&#10;                        speech.1 = prev_end;&#10;                        speeches.push(speech);&#10;                        current_speech = Some((next_start, 0));&#10;                        prev_end = 0;&#10;                        next_start = 0;&#10;                        temp_end = 0;&#10;                    } else {&#10;                        let mut speech = current_speech.take().unwrap();&#10;                        speech.1 = current_sample;&#10;                        speeches.push(speech);&#10;                        current_speech = None;&#10;                        triggered = false;&#10;                        prev_end = 0;&#10;                        next_start = 0;&#10;                        temp_end = 0;&#10;                        continue;&#10;                    }&#10;                }&#10;&#10;                if prob &lt; neg_threshold &amp;&amp; triggered {&#10;                    if temp_end == 0 {&#10;                        temp_end = current_sample;&#10;                    }&#10;&#10;                    if (current_sample - temp_end) as u64 &gt; min_silence_samples_at_max_speech {&#10;                        prev_end = temp_end;&#10;                    }&#10;&#10;                    if ((current_sample - temp_end) as u64) &lt; min_silence_samples {&#10;                        continue;&#10;                    } else {&#10;                        let mut speech = current_speech.take().unwrap();&#10;                        speech.1 = temp_end;&#10;                        if (speech.1 - speech.0) as u64 &gt; min_speech_samples {&#10;                            speeches.push(speech);&#10;                        }&#10;                        current_speech = None;&#10;                        triggered = false;&#10;                        prev_end = 0;&#10;                        next_start = 0;&#10;                        temp_end = 0;&#10;                        continue;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        if let Some((start, _)) = current_speech {&#10;            if (audio_length - start) as u64 &gt; min_speech_samples {&#10;                speeches.push((start, audio_length));&#10;            }&#10;        }&#10;&#10;        // 应用边界填充&#10;        for i in 0..speeches.len() {&#10;            if i == 0 {&#10;                speeches[i].0 = speeches[i].0.saturating_sub(speech_pad_samples as usize);&#10;            }&#10;&#10;            if i &lt; speeches.len() - 1 {&#10;                let silence_duration = speeches[i + 1].0 - speeches[i].1;&#10;                if silence_duration &lt; (2 * speech_pad_samples) as usize {&#10;                    let half_silence = silence_duration / 2;&#10;                    speeches[i].1 += half_silence;&#10;                    speeches[i + 1].0 = speeches[i + 1]&#10;                        .0&#10;                        .saturating_sub(silence_duration - half_silence);&#10;                } else {&#10;                    speeches[i].1 = (speeches[i].1 as u64 + speech_pad_samples) as usize;&#10;                    speeches[i].1 = speeches[i].1.min(audio_length);&#10;                    speeches[i + 1].0 = speeches[i + 1]&#10;                        .0&#10;                        .saturating_sub(speech_pad_samples as usize);&#10;                }&#10;            } else {&#10;                speeches[i].1 = (speeches[i].1 as u64 + speech_pad_samples) as usize;&#10;                speeches[i].1 = speeches[i].1.min(audio_length);&#10;            }&#10;        }&#10;&#10;        Ok(speeches)&#10;    }&#10;}&#10;&#10;impl Deref for VoiceActivityDetector {&#10;    type Target = VoiceActivityDetectorConfig;&#10;&#10;    fn deref(&amp;self) -&gt; &amp;Self::Target {&#10;        &amp;self.config&#10;    }&#10;}&#10;&#10;impl DerefMut for VoiceActivityDetector {&#10;    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {&#10;        &amp;mut self.config&#10;    }&#10;}&#10;" />
                  </map>
                </option>
                <option name="messageId" value="0197902d17337ffd916b2820b68d7367" />
                <option name="question" value="添加文档注释" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1750470578065" />
        </Conversation>
      </list>
    </option>
  </component>
</project>